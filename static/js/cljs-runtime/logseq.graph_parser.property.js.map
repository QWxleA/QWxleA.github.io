{"version":3,"sources":["logseq/graph_parser/property.cljs"],"mappings":";AAMA,qDAAA,rDAAMA,kHACHC;AADH,AAEE,SACC,AAACC,wBAAQD,YACT,0BAAA,iFAAA,uBAAA,lIAACE,mKACU,AAACC,gBAAMH;;AAErB,GAAA,QAAAI,mCAAAC,gDAAAC,yDAAAC;AAAA;AAAA,AAAA,gDAAA,hDAASC;;AACT,GAAA,QAAAJ,mCAAAC,gDAAAC,yDAAAG;AAAA;AAAA,AAAA,8CAAA,9CAASC;;AACT,GAAA,QAAAN,mCAAAC,gDAAAC,yDAAAK;AAAA;AAAA,AAAA,AAASC,sDACP,AAACC,qBAAW,mBAAA,nBAACC,4CAAwCJ,4CAAeA;;AAEtE,0DAAA,1DAAMK,4HACHC;AADH,AAEE,oBAAMA;AAAN,AACE,IAAAC,oBAAK,AAACC,+BAAiBF,QAAQR;AAA/B,AAAA,GAAAS;AACK,OAACE,sCAAqBP,oDAAuBI;;AADlDC;;;AADF;;;AAIF;;;mDAAA,nDAAMG,8GAEHJ;AAFH,AAGE,oBAAI,AAACD,wDAAqBC;AACxB,IAAMK,QAAM,AAACC,2BAAmBN;IAC1BO,YAAU,AAAUF,cAAMb;IAC1BgB,UAAQ,AAAUH,cAAMX;AAF9B,AAGE,GAAI,0BAAA,xBAAK,cAAA,bAAIa,yBAAa,WAAA,VAAGC,oBAAW,CAAGA,UAAQD;AACjD,IAAME,SAAO,qDAAA,rDAACC,+CAAOL,UAAQE;IACvBI,SACY,AAACC,4CAAI,WAAKC;AAAL,AACE,IAAAC,aAAY,qCAAA,rCAACI,yCAAwB,kDAAA,lDAACC,6CAAKN;QAA3C,AAAAE,4CAAAD,WAAA,IAAA,/DAAOE;QAAP,AAAAD,4CAAAD,WAAA,IAAA,/DAASG;AAAT,AACE,oBAAI,iBAAAhB,oBAAKe;AAAL,AAAA,oBAAAf;AAAOgB;;AAAPhB;;;AACF,IAAMe,QAAE,yBAAA,IAAA,7BAACI,uBAAeJ;IAClBK,YAAU,AAACC,gDAAQ,AAACC,0BAAkBP;IACtCA,QAAE,sUAAA,pUAAI,0BAAA,iFAAA,oEAAA,mEAAA,lPAAC9B,wTAAuCmC,iBAAgBL;IAC9DA,QAAE,yNAAA,vNAAI,0BAAA,iFAAA,3GAAC9B,2MAA+BmC,yBAAwBL;AAHpE,AAIE,cAAA,NAAKA,YAAQ,AAACQ,oBAAYP;;AAC5BJ;;GATX,AAACH,+CAAOL,MAAM,aAAA,ZAAKE,iBAAWC;IAU1CiB,QAAM,AAACf,+CAAOL,MAAM,WAAA,VAAKG;IACzBH,YAAM,AAACqB,sDAAOjB,OAAOE,yDAAOc;AAZlC,AAaE,yDAAA,lDAACE,uDAAiBtB;;AACpBL;;;AACJA","names":["logseq.graph-parser.property/properties-ast?","block","cljs.core/vector?","cljs.core/contains?","cljs.core/first","js/logseq","js/logseq.graph-parser","js/logseq.graph-parser.property","js/logseq.graph-parser.property.properties-start","logseq.graph-parser.property/properties-start","js/logseq.graph-parser.property.properties-end","logseq.graph-parser.property/properties-end","js/logseq.graph-parser.property.properties-end-pattern","logseq.graph-parser.property/properties-end-pattern","cljs.core/re-pattern","goog.string/format","logseq.graph-parser.property/contains-properties?","content","and__5041__auto__","clojure.string/includes?","logseq.graph-parser.util/safe-re-find","logseq.graph-parser.property/->new-properties","lines","clojure.string/split-lines","start-idx","end-idx","before","cljs.core.subvec","middle","cljs.core.map","text","vec__59209","cljs.core.nth","k","v","logseq.graph-parser.util/split-first","cljs.core.subs","clojure.string/replace","compare-k","cljs.core.keyword","clojure.string/lower-case","clojure.string/trim","after","cljs.core.concat","clojure.string.join"],"sourcesContent":["(ns logseq.graph-parser.property\n  \"Property fns needed by graph-parser\"\n  (:require [logseq.graph-parser.util :as gp-util]\n            [clojure.string :as string]\n            [goog.string :as gstring]))\n\n(defn properties-ast?\n  [block]\n  (and\n   (vector? block)\n   (contains? #{\"Property_Drawer\" \"Properties\"}\n              (first block))))\n\n(defonce properties-start \":PROPERTIES:\")\n(defonce properties-end \":END:\")\n(defonce properties-end-pattern\n  (re-pattern (gstring/format \"%s[\\t\\r ]*\\n|(%s\\\\s*$)\" properties-end properties-end)))\n\n(defn contains-properties?\n  [content]\n  (when content\n    (and (string/includes? content properties-start)\n         (gp-util/safe-re-find properties-end-pattern content))))\n\n(defn ->new-properties\n  \"New syntax: key:: value\"\n  [content]\n  (if (contains-properties? content)\n    (let [lines (string/split-lines content)\n          start-idx (.indexOf lines properties-start)\n          end-idx (.indexOf lines properties-end)]\n      (if (and (>= start-idx 0) (> end-idx 0) (> end-idx start-idx))\n        (let [before (subvec lines 0 start-idx)\n              middle (->> (subvec lines (inc start-idx) end-idx)\n                          (map (fn [text]\n                                 (let [[k v] (gp-util/split-first \":\" (subs text 1))]\n                                   (if (and k v)\n                                     (let [k (string/replace k \"_\" \"-\")\n                                           compare-k (keyword (string/lower-case k))\n                                           k (if (contains? #{:id :custom_id :custom-id} compare-k) \"id\" k)\n                                           k (if (contains? #{:last-modified-at} compare-k) \"updated-at\" k)]\n                                       (str k \":: \" (string/trim v)))\n                                     text)))))\n              after (subvec lines (inc end-idx))\n              lines (concat before middle after)]\n          (string/join \"\\n\" lines))\n        content))\n    content))\n"]}