{"version":3,"sources":["frontend/db/rules.cljc"],"mappings":";AAEA,0BAAA,AAAA,1BAAKA;AA0DL;;;;;oCAAA,wCAAA,wEAAA,sDAAA,gEAAA,uEAAA,8DAAA,sEAAA,2DAAA,oDAAA,8DAAA,6DAAA,sEAAA,6EAAA,iEAAA,AAAA,2eAAA,AAAA,21BAAA,AAAA,skCAAA,AAAA,mvDAAA,AAAA,ipFAAA,AAAA,m4BAAA,AAAA,smDAAA,AAAA,0zBAAA,AAAA,40BAAA,AAAA,23BAAA,AAAA,4pCAAA,AAAA,iiCAAA,AAAA,10dAAKC","names":["frontend.db.rules/rules","frontend.db.rules/query-dsl-rules"],"sourcesContent":["(ns ^:bb-compatible ^:nbb-compatible frontend.db.rules)\n\n(def rules\n  ;; rule \"parent\" is optimized for child node -> parent node nesting queries\n  '[[(parent ?p ?c)\n     [?c :block/parent ?p]]\n    [(parent ?p ?c)\n     [?c :block/parent ?t]\n     (parent ?p ?t)]\n\n  ;; rule \"child\" is optimized for child node -> parent node nesting queries\n    [(child ?p ?c)\n     [?c :block/parent ?p]]\n    [(child ?p ?c)\n     [?t :block/parent ?p]\n     (child ?t ?c)]\n\n  ;; rule \"namespace\" is optimized for child node -> node of upper namespace level nesting queries\n    [(namespace ?p ?c)\n     [?c :block/namespace ?p]]\n    [(namespace ?p ?c)\n     [?t :block/namespace ?p]\n     (namespace ?t ?c)]\n\n    ;; Select rules carefully, as it is critical for performance.\n    ;; The rules have different clause order and resolving directions.\n    ;; Clause order Reference:\n    ;; https://docs.datomic.com/on-prem/query/query-executing.html#clause-order\n    ;; Recursive optimization Reference:\n    ;; https://stackoverflow.com/questions/42457136/recursive-datalog-queries-for-datomic-really-slow\n    ;; Should optimize for query the decendents of a block\n    ;; Quote:\n    ;; My theory is that your rules are not written in a way that Datalog can optimize for this read pattern - probably resulting in a traversal of all the entities. I suggest to rewrite them as follows:\n    ;; [[(ubersymbol ?c ?p)\n    ;;   (?c :ml/parent ?p)]\n    ;;  [(ubersymbol ?c ?p)\n    ;;   ;; we bind a child of the ancestor, instead of a parent of the descendant\n    ;;   (?c1 :ml/parent ?p)\n    ;;   (ubersymbol ?c ?c1)]]\n\n    ;; This way of writing the ruleset is optimized to find the descendants of some node. The way you originally wrote it is optimized to find the anscestors of some node.\n\n    ;; from https://stackoverflow.com/questions/43784258/find-entities-whose-ref-to-many-attribute-contains-all-elements-of-input\n    ;; Quote:\n    ;; You're tackling the general problem of 'dynamic conjunction' in Datomic's Datalog.\n    ;; Write a dynamic Datalog query which uses 2 negations and 1 disjunction or a recursive rule\n    ;; Datalog has no direct way of expressing dynamic conjunction (logical AND / 'for all ...' / set intersection).\n    ;; However, you can achieve it in pure Datalog by combining one disjunction\n    ;; (logical OR / 'exists ...' / set union) and two negations, i.e\n    ;; (For all ?g in ?Gs p(?e,?g)) <=> NOT(Exists ?g in ?Gs, such that NOT(p(?e, ?g)))\n\n    ;; [(matches-all ?e ?a ?vs)\n    ;;  [(first ?vs) ?v0]\n    ;;  [?e ?a ?v0]\n    ;;  (not-join [?e ?vs]\n    ;;            [(identity ?vs) [?v ...]]\n    ;;            (not-join [?e ?v]\n    ;;                      [?e ?a ?v]))]\n    ])\n\n(def query-dsl-rules\n  \"Rules used by frontend.db.query-dsl. The symbols ?b and ?p respectively refer\n  to block and page. Do not alter them as they are programatically built by the\n  query-dsl ns\"\n  {:page-property\n   '[(page-property ?p ?key ?val)\n     [?p :block/name]\n     [?p :block/properties ?prop]\n     [(get ?prop ?key) ?v]\n     (or [(= ?v ?val)] [(contains? ?v ?val)])]\n\n   :has-page-property\n   '[(has-page-property ?p ?key)\n     [?p :block/name]\n     [?p :block/properties ?prop]\n     [(get ?prop ?key)]]\n\n   :task\n   '[(task ?b ?markers)\n     [?b :block/marker ?marker]\n     [(contains? ?markers ?marker)]]\n\n   :priority\n   '[(priority ?b ?priorities)\n     [?b :block/priority ?priority]\n     [(contains? ?priorities ?priority)]]\n\n   :page-tags\n   '[(page-tags ?p ?tags)\n     [?p :block/tags ?t]\n     [?t :block/name ?tag]\n     [(contains? ?tags ?tag)]]\n\n   :all-page-tags\n   '[(all-page-tags ?p)\n     [_ :block/tags ?p]]\n\n   :between\n   '[(between ?b ?start ?end)\n     [?b :block/page ?p]\n     [?p :block/journal? true]\n     [?p :block/journal-day ?d]\n     [(>= ?d ?start)]\n     [(<= ?d ?end)]]\n\n   :has-property\n   '[(has-property ?b ?prop)\n     [?b :block/properties ?bp]\n     [(missing? $ ?b :block/name)]\n     [(get ?bp ?prop)]]\n\n   :block-content\n   '[(block-content ?b ?query)\n     [?b :block/content ?content]\n     [(clojure.string/includes? ?content ?query)]]\n\n   :page\n   '[(page ?b ?page-name)\n     [?b :block/page ?bp]\n     [?bp :block/name ?page-name]]\n\n   :namespace\n   '[(namespace ?p ?namespace)\n     [?p :block/namespace ?parent]\n     [?parent :block/name ?namespace]]\n\n   :property\n   '[(property ?b ?key ?val)\n     [?b :block/properties ?prop]\n     [(missing? $ ?b :block/name)]\n     [(get ?prop ?key) ?v]\n     (or-join [?v]\n              [(= ?v ?val)]\n              [(contains? ?v ?val)]\n              ;; For integer pages that aren't strings\n              (and\n               [(str ?val) ?str-val]\n               [(contains? ?v ?str-val)]))]\n\n   :page-ref\n   '[(page-ref ?b ?page-name)\n     [?b :block/path-refs ?bp]\n     [?bp :block/name ?page-name]]})\n"]}