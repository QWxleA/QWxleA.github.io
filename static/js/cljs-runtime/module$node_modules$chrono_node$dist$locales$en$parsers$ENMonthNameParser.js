shadow$provide.module$node_modules$chrono_node$dist$locales$en$parsers$ENMonthNameParser=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});const constants_1=require("module$node_modules$chrono_node$dist$locales$en$constants"),years_1=require("module$node_modules$chrono_node$dist$calculation$years");global=require("module$node_modules$chrono_node$dist$utils$pattern");const constants_2=require("module$node_modules$chrono_node$dist$locales$en$constants");
require=require("module$node_modules$chrono_node$dist$common$parsers$AbstractParserWithWordBoundary");const PATTERN=new RegExp("((?:in)\\s*)?"+`(${global.matchAnyPattern(constants_1.MONTH_DICTIONARY)})`+"\\s*(?:"+`[,-]?\\s*(${constants_2.YEAR_PATTERN})?`+")?(?\x3d[^\\s\\w]|\\s+[^0-9]|\\s+$|$)","i");class ENMonthNameParser extends require.AbstractParserWithWordBoundaryChecking{innerPattern(){return PATTERN}innerExtract(context,match){var monthName=match[2].toLowerCase();if(3>=match[0].length&&!constants_1.FULL_MONTH_NAME_DICTIONARY[monthName])return null;
const result=context.createParsingResult(match.index+(match[1]||"").length,match.index+match[0].length);result.start.imply("day",1);monthName=constants_1.MONTH_DICTIONARY[monthName];result.start.assign("month",monthName);match[3]?(context=constants_2.parseYear(match[3]),result.start.assign("year",context)):(context=years_1.findYearClosestToRef(context.refDate,1,monthName),result.start.imply("year",context));return result}}exports.default=ENMonthNameParser}
//# sourceMappingURL=module$node_modules$chrono_node$dist$locales$en$parsers$ENMonthNameParser.js.map
