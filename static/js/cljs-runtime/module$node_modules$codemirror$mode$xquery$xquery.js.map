{
"version":3,
"file":"module$node_modules$codemirror$mode$xquery$xquery.js",
"lineCount":15,
"mappings":"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",
"sources":["node_modules/codemirror/mode/xquery/xquery.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$codemirror$mode$xquery$xquery\"] = function(global,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xquery\", function() {\n\n  // The keywords object is set to the result of this self executing\n  // function. Each keyword is a property of the keywords object whose\n  // value is {type: atype, style: astyle}\n  var keywords = function(){\n    // convenience functions used to build keywords object\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var operator = kw(\"operator\")\n      , atom = {type: \"atom\", style: \"atom\"}\n      , punctuation = {type: \"punctuation\", style: null}\n      , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n    // kwObj is what is return from this function at the end\n    var kwObj = {\n      ',': punctuation\n    };\n\n    // a list of 'basic' keywords. For each add a property to kwObj with the value of\n    // {type: basic[i], style: \"keyword\"} e.g. 'after' --\u003e {type: \"after\", style: \"keyword\"}\n    var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n    'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n    'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n    'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n    'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n    'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n    'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n    'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n    'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n    'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n    'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n    'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n    'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n    'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n    'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n    'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n    'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n    'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n    'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n    'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n    for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n    // a list of types. For each add a property to kwObj with the value of\n    // {type: \"atom\", style: \"atom\"}\n    var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n    'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n    'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n    'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n    'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n    'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n    'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n    'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n    'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n    'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n    for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n    // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n    var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n    for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n    // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n    var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n    \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n    for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n    return kwObj;\n  }();\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  // the primary mode tokenizer\n  function tokenBase(stream, state) {\n    var ch = stream.next(),\n        mightBeFunction = false,\n        isEQName = isEQNameAhead(stream);\n\n    // an XML tag (if not in some sub, chained tokenizer)\n    if (ch == \"<\") {\n      if(stream.match(\"!--\", true))\n        return chain(stream, state, tokenXMLComment);\n\n      if(stream.match(\"![CDATA\", false)) {\n        state.tokenize = tokenCDATA;\n        return \"tag\";\n      }\n\n      if(stream.match(\"?\", false)) {\n        return chain(stream, state, tokenPreProcessing);\n      }\n\n      var isclose = stream.eat(\"/\");\n      stream.eatSpace();\n      var tagName = \"\", c;\n      while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n      return chain(stream, state, tokenTag(tagName, isclose));\n    }\n    // start code block\n    else if(ch == \"{\") {\n      pushStateStack(state, { type: \"codeblock\"});\n      return null;\n    }\n    // end code block\n    else if(ch == \"}\") {\n      popStateStack(state);\n      return null;\n    }\n    // if we're in an XML block\n    else if(isInXmlBlock(state)) {\n      if(ch == \">\")\n        return \"tag\";\n      else if(ch == \"/\" && stream.eat(\">\")) {\n        popStateStack(state);\n        return \"tag\";\n      }\n      else\n        return \"variable\";\n    }\n    // if a number\n    else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n      return \"atom\";\n    }\n    // comment start\n    else if (ch === \"(\" && stream.eat(\":\")) {\n      pushStateStack(state, { type: \"comment\"});\n      return chain(stream, state, tokenComment);\n    }\n    // quoted string\n    else if (!isEQName && (ch === '\"' || ch === \"'\"))\n      return chain(stream, state, tokenString(ch));\n    // variable\n    else if(ch === \"$\") {\n      return chain(stream, state, tokenVariable);\n    }\n    // assignment\n    else if(ch ===\":\" && stream.eat(\"=\")) {\n      return \"keyword\";\n    }\n    // open paren\n    else if(ch === \"(\") {\n      pushStateStack(state, { type: \"paren\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \")\") {\n      popStateStack(state);\n      return null;\n    }\n    // open paren\n    else if(ch === \"[\") {\n      pushStateStack(state, { type: \"bracket\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \"]\") {\n      popStateStack(state);\n      return null;\n    }\n    else {\n      var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n      // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n      if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n      if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n      // gobble up a word if the character is not known\n      if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n      // gobble a colon in the case that is a lib func type call fn:doc\n      var foundColon = stream.eat(\":\");\n\n      // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n      // which should get matched as a keyword\n      if(!stream.eat(\":\") && foundColon) {\n        stream.eatWhile(/[\\w\\$_-]/);\n      }\n      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n      if(stream.match(/^[ \\t]*\\(/, false)) {\n        mightBeFunction = true;\n      }\n      // is the word a keyword?\n      var word = stream.current();\n      known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n      // if we think it's a function call but not yet known,\n      // set style to variable for now for lack of something better\n      if(mightBeFunction && !known) known = {type: \"function_call\", style: \"variable def\"};\n\n      // if the previous word was element, attribute, axis specifier, this word should be the name of that\n      if(isInXmlConstructor(state)) {\n        popStateStack(state);\n        return \"variable\";\n      }\n      // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n      // push the stack so we know to look for it on the next word\n      if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n      // if the word is known, return the details of that else just call this a generic 'word'\n      return known ? known.style : \"variable\";\n    }\n  }\n\n  // handle comments, including nested\n  function tokenComment(stream, state) {\n    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n    while (ch = stream.next()) {\n      if (ch == \")\" && maybeEnd) {\n        if(nestedCount > 0)\n          nestedCount--;\n        else {\n          popStateStack(state);\n          break;\n        }\n      }\n      else if(ch == \":\" && maybeNested) {\n        nestedCount++;\n      }\n      maybeEnd = (ch == \":\");\n      maybeNested = (ch == \"(\");\n    }\n\n    return \"comment\";\n  }\n\n  // tokenizer for string literals\n  // optionally pass a tokenizer function to set state.tokenize back to when finished\n  function tokenString(quote, f) {\n    return function(stream, state) {\n      var ch;\n\n      if(isInString(state) && stream.current() == quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        return \"string\";\n      }\n\n      pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n      // if we're in a string and in an XML block, allow an embedded code block\n      if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n\n\n      while (ch = stream.next()) {\n        if (ch ==  quote) {\n          popStateStack(state);\n          if(f) state.tokenize = f;\n          break;\n        }\n        else {\n          // if we're in a string and in an XML block, allow an embedded code block in an attribute\n          if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n            state.tokenize = tokenBase;\n            return \"string\";\n          }\n\n        }\n      }\n\n      return \"string\";\n    };\n  }\n\n  // tokenizer for variables\n  function tokenVariable(stream, state) {\n    var isVariableChar = /[\\w\\$_-]/;\n\n    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n    if(stream.eat(\"\\\"\")) {\n      while(stream.next() !== '\\\"'){};\n      stream.eat(\":\");\n    } else {\n      stream.eatWhile(isVariableChar);\n      if(!stream.match(\":=\", false)) stream.eat(\":\");\n    }\n    stream.eatWhile(isVariableChar);\n    state.tokenize = tokenBase;\n    return \"variable\";\n  }\n\n  // tokenizer for XML tags\n  function tokenTag(name, isclose) {\n    return function(stream, state) {\n      stream.eatSpace();\n      if(isclose && stream.eat(\">\")) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n        return \"tag\";\n      }\n      // self closing tag without attributes?\n      if(!stream.eat(\"/\"))\n        pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n      if(!stream.eat(\">\")) {\n        state.tokenize = tokenAttribute;\n        return \"tag\";\n      }\n      else {\n        state.tokenize = tokenBase;\n      }\n      return \"tag\";\n    };\n  }\n\n  // tokenizer for XML attributes\n  function tokenAttribute(stream, state) {\n    var ch = stream.next();\n\n    if(ch == \"/\" && stream.eat(\">\")) {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      if(isInXmlBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \">\") {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \"=\")\n      return null;\n    // quoted string\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, tokenString(ch, tokenAttribute));\n\n    if(!isInXmlAttributeBlock(state))\n      pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n    stream.eat(/[a-zA-Z_:]/);\n    stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n    stream.eatSpace();\n\n    // the case where the attribute has not value and the tag was closed\n    if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n    }\n\n    return \"attribute\";\n  }\n\n  // handle comments, including nested\n  function tokenXMLComment(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"-\" && stream.match(\"->\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n\n  // handle CDATA\n  function tokenCDATA(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"]\" && stream.match(\"]\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n  // handle preprocessing instructions\n  function tokenPreProcessing(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"?\" && stream.match(\">\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment meta\";\n      }\n    }\n  }\n\n\n  // functions to test the current context of the state\n  function isInXmlBlock(state) { return isIn(state, \"tag\"); }\n  function isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\n  function isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\n  function isInString(state) { return isIn(state, \"string\"); }\n\n  function isEQNameAhead(stream) {\n    // assume we've already eaten a quote (\")\n    if(stream.current() === '\"')\n      return stream.match(/^[^\\\"]+\\\"\\:/, false);\n    else if(stream.current() === '\\'')\n      return stream.match(/^[^\\\"]+\\'\\:/, false);\n    else\n      return false;\n  }\n\n  function isIn(state, type) {\n    return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n  }\n\n  function pushStateStack(state, newState) {\n    state.stack.push(newState);\n  }\n\n  function popStateStack(state) {\n    state.stack.pop();\n    var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n    state.tokenize = reinstateTokenize || tokenBase;\n  }\n\n  // the interface for the mode API\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        cc: [],\n        stack: []\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      return style;\n    },\n\n    blockCommentStart: \"(:\",\n    blockCommentEnd: \":)\"\n\n  };\n\n});\n\nCodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","mod","define","amd","CodeMirror","defineMode","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","current","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","tagName","c","tokenTag","stack","push","newState","type","popStateStack","isIn","test","tokenComment","isEQName","tokenVariable","known","keywords","propertyIsEnumerable","eatWhile","foundColon","word","style","tokenString","maybeEnd","maybeNested","nestedCount","quote","name","isInXmlAttributeBlock","isVariableChar","tokenAttribute","length","pop","operator","atom","qualifier","kwObj","punctuation","basic","i","l","types","operators","axis_specifiers","startState","cc","token","blockCommentStart","blockCommentEnd","defineMIME"]
}
