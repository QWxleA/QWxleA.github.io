{"version":3,"sources":["logseq/graph_parser/util.cljs"],"mappings":"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","names":["logseq.graph-parser.util/uuid-pattern","js/logseq","js/logseq.graph-parser","js/logseq.graph-parser.util","js/logseq.graph-parser.util.exactly-uuid-pattern","logseq.graph-parser.util/exactly-uuid-pattern","cljs.core/re-pattern","logseq.graph-parser.util/safe-re-find","pattern","s","js/console.trace","cljs.core/re-find","logseq.graph-parser.util/uuid-string?","logseq.graph-parser.util/path-normalize","logseq.graph-parser.util/remove-nils","nm","clojure.walk/postwalk","el","cljs.core/map?","cljs.core.into","cljs.core.remove","cljs.core.comp","cljs.core/nil?","cljs.core/second","logseq.graph-parser.util/split-first","temp__5720__auto__","first-index","clojure.string.index_of","cljs.core.subs","cljs.core/count","logseq.graph-parser.util/split-last","last-index","clojure.string.last_index_of","logseq.graph-parser.util/tag-valid?","tag-name","cljs.core/not","var_args","G__66015","logseq.graph-parser.util/safe-subs","js/Error","start","c","logseq.graph_parser.util.safe_subs","end","x__4339__auto__","y__4340__auto__","logseq.graph-parser.util/unquote-string","v","clojure.string/trim","logseq.graph-parser.util/wrapped-by-quotes?","cljs.core._EQ_","cljs.core/first","cljs.core/last","logseq.graph-parser.util/parse-int","x","js/parseInt","logseq.graph-parser.util/safe-parse-int","result","js/isNaN","logseq.graph-parser.util/url?","and__4251__auto__","e66021","js/URL","_e","logseq.graph-parser.util/json->clj","json-string","js/JSON.parse","cljs.core.js__GT_clj"],"sourcesContent":["(ns ^:nbb-compatible logseq.graph-parser.util\n  \"Util fns shared between graph-parser and rest of app. Util fns only rely on\n  clojure standard libraries.\"\n  (:require [clojure.walk :as walk]\n            [clojure.string :as string]))\n\n(def uuid-pattern \"[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}\")\n(defonce exactly-uuid-pattern (re-pattern (str \"(?i)^\" uuid-pattern \"$\")))\n\n(defn safe-re-find\n  [pattern s]\n  (when-not (string? s)\n    ;; TODO: sentry\n    (js/console.trace))\n  (when (string? s)\n    (re-find pattern s)))\n\n(defn uuid-string?\n  [s]\n  (safe-re-find exactly-uuid-pattern s))\n\n(defn path-normalize\n  \"Normalize file path (for reading paths from FS, not required by writting)\"\n  [s]\n  (.normalize s \"NFC\"))\n\n(defn remove-nils\n  \"remove pairs of key-value that has nil value from a (possibly nested) map.\"\n  [nm]\n  (walk/postwalk\n   (fn [el]\n     (if (map? el)\n       (into {} (remove (comp nil? second)) el)\n       el))\n   nm))\n\n(defn split-first [pattern s]\n  (when-let [first-index (string/index-of s pattern)]\n    [(subs s 0 first-index)\n     (subs s (+ first-index (count pattern)) (count s))]))\n\n(defn split-last [pattern s]\n  (when-let [last-index (string/last-index-of s pattern)]\n    [(subs s 0 last-index)\n     (subs s (+ last-index (count pattern)) (count s))]))\n\n(defn tag-valid?\n  [tag-name]\n  (when (string? tag-name)\n    (not (safe-re-find #\"[# \\t\\r\\n]+\" tag-name))))\n\n(defn safe-subs\n  ([s start]\n   (let [c (count s)]\n     (safe-subs s start c)))\n  ([s start end]\n   (let [c (count s)]\n     (subs s (min c start) (min c end)))))\n\n(defn unquote-string\n  [v]\n  (string/trim (subs v 1 (dec (count v)))))\n\n(defn wrapped-by-quotes?\n  [v]\n  (and (string? v) (>= (count v) 2) (= \"\\\"\" (first v) (last v))))\n\n(defn parse-int\n  \"Copy of frontend.util/parse-int. Don't want to couple to main app too much\"\n  [x]\n  (if (string? x)\n    (js/parseInt x)\n    x))\n\n(defn safe-parse-int\n  \"Copy of frontend.util/safe-parse-int. Don't want to couple to main app too much\"\n  [x]\n  (let [result (parse-int x)]\n    (if (js/isNaN result)\n      nil\n      result)))\n\n(defn url?\n  [s]\n  (and (string? s)\n       (try\n         (js/URL. s)\n         true\n         (catch js/Error _e\n           false))))\n\n(defn json->clj\n  [json-string]\n  (-> json-string\n      (js/JSON.parse)\n      (js->clj :keywordize-keys true)))\n"]}