{"version":3,"sources":["frontend/rum.cljs"],"mappings":"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","names":["frontend.rum/kebab-case->camel-case","input","words","clojure.string.split","capitalize","cljs.core/rest","p1__86862#","cljs.core.map","cljs.core.apply","cljs.core/str","clojure.string/upper-case","cljs.core/first","var_args","args__5772__auto__","len__5766__auto__","i__5767__auto__","argseq__5773__auto__","cljs.core/IndexedSeq","frontend.rum/map-keys->camel-case","p__86866","map__86867","cljs.core/--destructure-map","cljs.core.get","seq86864","G__86865","cljs.core/next","self__5751__auto__","data","html-props","convert-to-camel","p__86868","vec__86869","cljs.core.nth","key","value","cljs.core/name","clojure.walk/postwalk","x","cljs.core/map?","new-map","clojure.set/rename-keys","cljs.core.into","G__86873","frontend.rum/adapt-class","js/Error","react-class","frontend.rum.adapt_class","skip-opts-transform?","args","vec__86875","opts","children","type#","new-children","cljs.core/sequential?","result","daiquiri.interpreter/interpret","vector->react-elems","p__86878","vec__86879","val","new-options","js/React.createElement","cljs-bean.core/->js","frontend.rum.map_keys__GT_camel_case","frontend.rum/use-atom-fn","a","getter-fn","setter-fn","vec__86892","p1__86882#","set-val","rum.core/use-state","G__86895","cljs.core/deref","rum.core.use_effect_BANG_","id","cljs.core/random-uuid","cljs.core/add-watch","_","prev-state","next-state","prev-value","next-value","cljs.core._EQ_","cljs.core/remove-watch","cljs.core.swap_BANG_","frontend.rum/use-atom","cljs.core/identity","v","frontend.rum/use-mounted","*mounted","rum.core/use-ref","rum.core/set-ref!","rum.core/deref"],"sourcesContent":["(ns frontend.rum\n  (:require [clojure.string :as s]\n            [clojure.set :as set]\n            [clojure.walk :as w]\n            [rum.core :refer [use-state use-effect!] :as rum]\n            [daiquiri.interpreter :as interpreter]\n            [cljs-bean.core :as bean]))\n\n;; copy from https://github.com/priornix/antizer/blob/35ba264cf48b84e6597743e28b3570d8aa473e74/src/antizer/core.cljs\n\n(defn kebab-case->camel-case\n  \"Converts from kebab case to camel case, eg: on-click to onClick\"\n  [input]\n  (let [words (s/split input #\"-\")\n        capitalize (->> (rest words)\n                        (map #(apply str (s/upper-case (first %)) (rest %))))]\n    (apply str (first words) capitalize)))\n\n(defn map-keys->camel-case\n  \"Stringifys all the keys of a cljs hashmap and converts them\n   from kebab case to camel case. If :html-props option is specified,\n   then rename the html properties values to their dom equivalent\n   before conversion\"\n  [data & {:keys [html-props]}]\n  (let [convert-to-camel (fn [[key value]]\n                           [(kebab-case->camel-case (name key)) value])]\n    (w/postwalk (fn [x]\n                  (if (map? x)\n                    (let [new-map (if html-props\n                                    (set/rename-keys x {:class :className :for :htmlFor})\n                                    x)]\n                      (into {} (map convert-to-camel new-map)))\n                    x))\n                data)))\n\n;; adapted from https://github.com/tonsky/rum/issues/20\n(defn adapt-class\n  ([react-class]\n   (adapt-class react-class false))\n  ([react-class skip-opts-transform?]\n   (fn [& args]\n    (let [[opts children] (if (map? (first args))\n                            [(first args) (rest args)]\n                            [{} args])\n          type# (first children)\n          ;; we have to make sure to check if the children is sequential\n          ;; as a list can be returned, eg: from a (for)\n          new-children (if (sequential? type#)\n                         (let [result (interpreter/interpret children)]\n                           (if (sequential? result)\n                             result\n                             [result]))\n                         children)\n          ;; convert any options key value to a react element, if\n          ;; a valid html element tag is used, using sablono\n          vector->react-elems (fn [[key val]]\n                                (if (sequential? val)\n                                  [key (daiquiri.interpreter/interpret val)]\n                                  [key val]))\n          new-options (into {}\n                            (if skip-opts-transform?\n                              opts\n                              (map vector->react-elems opts)))]\n      (apply js/React.createElement react-class\n        ;; sablono html-to-dom-attrs does not work for nested hashmaps\n        (bean/->js (map-keys->camel-case new-options :html-props true))\n        new-children)))))\n\n(defn use-atom-fn\n  [a getter-fn setter-fn]\n  (let [[val set-val] (use-state (getter-fn @a))]\n    (use-effect!\n      (fn []\n        (let [id (str (random-uuid))]\n          (add-watch a id (fn [_ _ prev-state next-state]\n                            (let [prev-value (getter-fn prev-state)\n                                  next-value (getter-fn next-state)]\n                              (when-not (= prev-value next-value)\n                                (set-val next-value)))))\n          #(remove-watch a id)))\n      [])\n    [val #(swap! a setter-fn %)]))\n\n(defn use-atom\n  \"(use-atom my-atom)\"\n  [a]\n  (use-atom-fn a identity (fn [_ v] v)))\n\n(defn use-mounted\n  []\n  (let [*mounted (rum/use-ref false)]\n    (use-effect!\n      (fn []\n         (rum/set-ref! *mounted true)\n         #(rum/set-ref! *mounted false))\n       [])\n    #(rum/deref *mounted)))\n"]}