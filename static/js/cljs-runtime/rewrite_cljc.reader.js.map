{"version":3,"sources":["rewrite_cljc/reader.cljc"],"mappings":"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","names":["var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","rewrite-cljc.reader/throw-reader","seq91750","G__91751","cljs.core/first","cljs.core/next","G__91752","self__4851__auto__","reader","fmt","data","c","cljs.tools.reader.reader-types/get-column-number","l","cljs.tools.reader.reader-types/get-line-number","cljs.core.ex_info","cljs.core.apply","rewrite-cljc.interop/simple-format","rewrite-cljc.reader/boundary?","cljs.core/contains?","rewrite-cljc.reader/comma?","rewrite-cljc.reader/whitespace?","rewrite-cljc.interop/clojure-whitespace?","rewrite-cljc.reader/linebreak?","rewrite-cljc.reader/space?","and__4251__auto__","rewrite-cljc.reader/whitespace-or-boundary?","or__4253__auto__","G__91762","rewrite-cljc.reader/read-while","js/Error","p?","rewrite_cljc.reader.read_while","cljs.core/not","eof?","buf","js/goog.string.StringBuffer","temp__5718__auto__","rewrite-cljc.reader/read-until","cljs.core/complement","rewrite-cljc.reader/read-include-linebreak","p1__91767#","rewrite-cljc.reader/string->edn","s","cljs.tools.reader.edn.read_string","rewrite-cljc.reader/ignore","rewrite-cljc.reader/next","rewrite-cljc.reader/unread","ch","rewrite-cljc.reader/peek","rewrite-cljc.reader/position","row-k","col-k","rewrite-cljc.reader/read-with-meta","read-fn","start-position","temp__5720__auto__","entry","cljs.core.merge","cljs.core/with-meta","rewrite-cljc.reader/read-repeatedly","cljs.core.repeatedly","cljs.core.take_while","cljs.core/identity","cljs.core.doall","rewrite-cljc.reader/read-n","node-tag","n","vs","v","cljs.core.conj","rewrite_cljc.reader.throw_reader","cljs.core._EQ_","rewrite-cljc.reader/string-reader","cljs.tools.reader.reader_types.indexing_push_back_reader","cljs.tools.reader.reader_types.string_push_back_reader"],"sourcesContent":["(ns ^:no-doc rewrite-cljc.reader\n  (:refer-clojure :exclude [peek next])\n  (:require #?@(:clj [[clojure.java.io :as io]])\n            [clojure.tools.reader.edn :as edn]\n            [clojure.tools.reader.reader-types :as r]\n            [rewrite-cljc.interop :as interop])\n  #?(:cljs (:import [goog.string StringBuffer])\n     :clj (:import [java.io PushbackReader])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## Exception\n\n(defn throw-reader\n  \"Throw reader exception, including line line/column.\"\n  [#?(:cljs ^:not-native reader :default reader) fmt & data]\n  (let [c (r/get-column-number reader)\n        l (r/get-line-number reader)]\n    (throw\n     (ex-info\n      (str (apply interop/simple-format fmt data)\n           \" [at line \" l \", column \" c \"]\") {}))))\n\n;; ## Decisions\n\n(defn boundary?\n  \"Check whether a given char is a token boundary.\"\n  [#?(:clj ^java.lang.Character c :default c)]\n  (contains?\n   #{\\\" \\: \\; \\' \\@ \\^ \\` \\~\n     \\( \\) \\[ \\] \\{ \\} \\\\ nil}\n   c))\n\n(defn comma?\n  [#?(:clj ^java.lang.Character c :default c)]\n  (identical? \\, c))\n\n(defn whitespace?\n  \"Checks whether a given character is whitespace\"\n  #?(:clj ^Boolean [^java.lang.Character c]\n     :default [c])\n  (interop/clojure-whitespace? c))\n\n(defn linebreak?\n  \"Checks whether the character is a newline\"\n  [#?(:clj ^java.lang.Character c :default c)]\n  (contains? #{\\newline \\return} c))\n\n(defn space?\n  \"Checks whether the character is a space\"\n  [#?(:clj ^java.lang.Character c :default c)]\n  (and c\n       (interop/clojure-whitespace? c)\n       (not (contains? #{\\newline \\return \\,} c))))\n\n(defn whitespace-or-boundary?\n  #?(:clj ^Boolean [^java.lang.Character c]\n     :default [c])\n  (or (whitespace? c) (boundary? c)))\n\n;; ## Helpers\n\n(defn read-while\n  \"Read while the chars fulfill the given condition. Ignores\n    the unmatching char.\"\n  ([#?(:cljs ^not-native reader :default reader) p?]\n   (read-while reader p? (not (p? nil))))\n\n  ([#?(:cljs ^not-native reader :default reader) p? eof?]\n   (let [buf (StringBuffer.)]\n     (loop []\n       (if-let [c (r/read-char reader)]\n         (if (p? c)\n           (do\n             (.append buf c)\n             (recur))\n           (do\n             (r/unread reader c)\n             (.toString buf)))\n         (if eof?\n           (.toString buf)\n           (throw-reader reader \"unexpected EOF\")))))))\n\n(defn read-until\n  \"Read until a char fulfills the given condition. Ignores the\n   matching char.\"\n  [#?(:cljs ^not-native reader :default reader) p?]\n  (read-while\n    reader\n    (complement p?)\n    (p? nil)))\n\n(defn read-include-linebreak\n  \"Read until linebreak and include it.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (str\n    (read-until\n      reader\n      #(or (nil? %) (linebreak? %)))\n    (r/read-char reader)))\n\n(defn string->edn\n  \"Convert string to EDN value.\"\n  [#?(:clj ^String s :default s)]\n  (edn/read-string s))\n\n(defn ignore\n  \"Ignore the next character.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader)\n  nil)\n\n(defn next\n  \"Read next char.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader))\n\n(defn unread\n  \"Unreads a char. Puts the char back on the reader.\"\n  [#?(:cljs ^not-native reader :default reader) ch]\n  (r/unread reader ch))\n\n(defn peek\n  \"Peek next char.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (r/peek-char reader))\n\n(defn position\n  \"Create map of `row-k` and `col-k` representing the current reader position.\"\n  [#?(:cljs ^not-native reader :default reader) row-k col-k]\n  {row-k (r/get-line-number reader)\n   col-k (r/get-column-number reader)})\n\n(defn read-with-meta\n  \"Use the given function to read value, then attach row/col metadata.\"\n  [#?(:cljs ^not-native reader :default reader) read-fn]\n  (let [start-position (position reader :row :col)]\n    (when-let [entry (read-fn reader)]\n      (->> (position reader :end-row :end-col)\n           (merge start-position)\n           (with-meta entry)))))\n\n(defn read-repeatedly\n  \"Call the given function on the given reader until it returns\n   a non-truthy value.\"\n  [#?(:cljs ^not-native reader :default reader) read-fn]\n  (->> (repeatedly #(read-fn reader))\n       (take-while identity)\n       (doall)))\n\n(defn read-n\n  \"Call the given function on the given reader until `n` values matching `p?` have been\n   collected.\"\n  [#?(:cljs ^not-native reader :default reader) node-tag read-fn p? n]\n  {:pre [(pos? n)]}\n  (loop [c 0\n         vs []]\n    (if (< c n)\n      (if-let [v (read-fn reader)]\n        (recur\n          (if (p? v) (inc c) c)\n          (conj vs v))\n        (throw-reader\n          reader\n          \"%s node expects %d value%s.\"\n          node-tag\n          n\n          (if (= n 1) \"\" \"s\")))\n      vs)))\n\n;; ## Reader Types\n\n(defn string-reader\n  \"Create reader for strings.\"\n  [s]\n  (r/indexing-push-back-reader\n   (r/string-push-back-reader s)))\n\n#?(:clj\n   (defn file-reader\n     \"Create reader for files.\"\n     ^clojure.tools.reader.reader_types.IndexingPushbackReader\n     [f]\n     (-> (io/file f)\n         (io/reader)\n         (PushbackReader. 2)\n         (r/indexing-push-back-reader 2))))\n"]}