shadow$provide.module$node_modules$graphology$dist$graphology_umd_min=function(global,require,module,exports){!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).graphology=t()}(this,function(){function e$jscomp$3(t){return(e$jscomp$3="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&
e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t$jscomp$2(e,t){e.prototype=Object.create(t.prototype);e.prototype.constructor=e;r$jscomp$2(e,t)}function n$jscomp$2(e$jscomp$0){return(n$jscomp$2=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e$jscomp$0)}function r$jscomp$2(e$jscomp$0,t$jscomp$0){return(r$jscomp$2=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e$jscomp$0,t$jscomp$0)}function i$jscomp$1(){if("undefined"==
typeof Reflect||!Reflect.construct||Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}function o$jscomp$1(e$jscomp$0,t$jscomp$0,n$jscomp$0){return(o$jscomp$1=i$jscomp$1()?Reflect.construct:function(e,t,n){var i=[null];i.push.apply(i,t);e=new (Function.bind.apply(e,i));return n&&r$jscomp$2(e,n.prototype),e}).apply(null,arguments)}function a$jscomp$1(e$jscomp$0){var t="function"==
typeof Map?new Map:void 0;return(a$jscomp$1=function(e){function a(){return o$jscomp$1(e,arguments,n$jscomp$2(this).constructor)}if(null===e||(i=e,-1===Function.toString.call(i).indexOf("[native code]")))return e;var i;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,a)}return a.prototype=Object.create(e.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),r$jscomp$2(a,e)})(e$jscomp$0)}
function u$jscomp$1(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function c$jscomp$0(e,t,n,r){return(e=e._nodes.get(t))?"mixed"===r?e.out&&e.out[n]||e.undirected&&e.undirected[n]:"directed"===r?e.out&&e.out[n]:e.undirected&&e.undirected[n]:null}function h$jscomp$0(t){return"object"===e$jscomp$3(t)&&null!==t&&t.constructor===Object}function f$jscomp$0(e){for(var t in e)return!1;return!0}function p$jscomp$0(e,t,n){Object.defineProperty(e,
t,{enumerable:!1,configurable:!1,writable:!0,value:n})}function g$jscomp$0(e,t,n){var r={enumerable:!0,configurable:!0};"function"==typeof n?r.get=n:(r.value=n,r.writable=!1);Object.defineProperty(e,t,r)}function l$jscomp$0(e){return!!h$jscomp$0(e)&&!(e.attributes&&!Array.isArray(e.attributes))}function _(){_.init.call(this)}function G(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e);}function E(e,t,n,r){var i,o,a;if(G(n),
void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),o=e._events),a=o[t]),void 0===a)o[t]=n,++e._eventsCount;else if("function"==typeof a?a=o[t]=r?[n,a]:[a,n]:r?a.unshift(n):a.push(n),0<(i=void 0===e._maxListeners?_.defaultMaxListeners:e._maxListeners)&&a.length>i&&!a.warned)a.warned=!0,n=Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit"),
n.name="MaxListenersExceededWarning",n.emitter=e,n.type=t,n.count=a.length,console&&console.warn&&console.warn(n);return e}function S(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function A(e,t,n){e={fired:!1,wrapFn:void 0,target:e,type:t,listener:n};t=S.bind(e);return t.listener=n,e.wrapFn=t,t}function L(e,t,n){e=e._events;if(void 0===e)return[];t=e[t];if(void 0===
t)n=[];else if("function"==typeof t)n=n?[t.listener||t]:[t];else if(n)for(n=Array(t.length),e=0;e<n.length;++e)n[e]=t[e].listener||t[e];else n=D(t,t.length);return n}function N(e){var t=this._events;if(void 0!==t){e=t[e];if("function"==typeof e)return 1;if(void 0!==e)return e.length}return 0}function D(e,t){for(var n=Array(t),r=0;r<t;++r)n[r]=e[r];return n}function j(e,t,n,r){if("function"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+
typeof e);e.addEventListener(t,function i(o){r.once&&e.removeEventListener(t,i);n(o)})}}function U(e){Object.defineProperty(this,"_next",{writable:!1,enumerable:!1,value:e});this.done=!1}function T(e,t){this.key=e;this.attributes=t;this.undirectedSelfLoops=this.directedSelfLoops=this.undirectedDegree=this.outDegree=this.inDegree=0;this.in={};this.out={};this.undirected={}}function R(e,t){this.key=e;this.attributes=t;this.directedSelfLoops=this.outDegree=this.inDegree=0;this.in={};this.out={}}function F(e,
t){this.key=e;this.attributes=t;this.undirectedSelfLoops=this.undirectedDegree=0;this.undirected={}}function I(e,t,n,r,i,o){this.key=t;this.attributes=o;this.undirected=e;this.source=r;this.target=i;this.generatedKey=n}function W(e,t,n,r,i,o,a){var u,d,c="out",s="in";(t&&(c=s="undirected"),e.multi)?(void 0===(d=(u=o[c])[i])&&(d=new Set,u[i]=d),d.add(n),r===i&&t)||void 0===(u=a[s])[r]&&(u[r]=d):(o[c][i]=n,r===i&&t)||(a[s][r]=n)}function Q(e,t){for(var n in t)e.push(t[n].key)}function V(e,t$jscomp$0){for(var n in t$jscomp$0)t$jscomp$0[n].forEach(function(t){return e.push(t.key)})}
function X(e,t,n){for(var r in e)if(r!==n){var i=e[r];t(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes,i.undirected,i.generatedKey)}}function Z(e$jscomp$0,t,n){for(var r in e$jscomp$0)r!==n&&e$jscomp$0[r].forEach(function(e){return t(e.key,e.attributes,e.source.key,e.target.key,e.source.attributes,e.target.attributes,e.undirected,e.generatedKey)})}function $(e,t,n){for(var r in e)if(r!==n){var i=e[r];if(t(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,
i.target.attributes,i.undirected,i.generatedKey))return!0}return!1}function ee(e,t,n){var r,i,o,a,u,d;for(d in e)if(d!==n)for(r=e[d].values();!0!==(i=r.next()).done;)if(a=(o=i.value).source,u=o.target,t(o.key,o.attributes,a.key,u.key,a.attributes,u.attributes,o.undirected,o.generatedKey))return!0;return!1}function te(e,t){var n=Object.keys(e),r=n.length,i=null,o=0;return new O(function a(){if(i){var u=i.next();if(u.done)return i=null,o++,a();u=u.value}else{if(o>=r)return{done:!0};u=n[o];if(u===t)return o++,
a();if((u=e[u])instanceof Set)return i=u.values(),a();o++}return{done:!1,value:[u.key,u.attributes,u.source.key,u.target.key,u.source.attributes,u.target.attributes]}})}function ne(e,t,n){(t=t[n])&&e.push(t.key)}function re(e,t$jscomp$0,n){(t$jscomp$0=t$jscomp$0[n])&&t$jscomp$0.forEach(function(t){return e.push(t.key)})}function ie(e,t,n){if(e=e[t]){t=e.source;var o=e.target;n(e.key,e.attributes,t.key,o.key,t.attributes,o.attributes,e.undirected,e.generatedKey)}}function oe(e$jscomp$0,t,n){(e$jscomp$0=
e$jscomp$0[t])&&e$jscomp$0.forEach(function(e){return n(e.key,e.attributes,e.source.key,e.target.key,e.source.attributes,e.target.attributes,e.undirected,e.generatedKey)})}function ae(e,t,n){if(e=e[t]){t=e.source;var o=e.target;return n(e.key,e.attributes,t.key,o.key,t.attributes,o.attributes,e.undirected,e.generatedKey)}}function ue(e,t,n){if(e=e[t]){var o;for(t=e.values();!0!==(e=t.next()).done;)if(n((o=e.value).key,o.attributes,o.source.key,o.target.key,o.source.attributes,o.target.attributes,
o.undirected,o.generatedKey))return!0;return!1}}function de(e$jscomp$0,t){e$jscomp$0=e$jscomp$0[t];if(e$jscomp$0 instanceof Set){var r=e$jscomp$0.values();return new O(function(){var e=r.next();if(e.done)return e;e=e.value;return{done:!1,value:[e.key,e.attributes,e.source.key,e.target.key,e.source.attributes,e.target.attributes]}})}return O.of([e$jscomp$0.key,e$jscomp$0.attributes,e$jscomp$0.source.key,e$jscomp$0.target.key,e$jscomp$0.source.attributes,e$jscomp$0.target.attributes])}function fe(e$jscomp$0,
t$jscomp$0){if(0===e$jscomp$0.size)return O.empty();var n="mixed"!==t$jscomp$0&&t$jscomp$0!==e$jscomp$0.type,r="undirected"===t$jscomp$0,i=e$jscomp$0._edges.values();return new O(function(){for(var e,t;;){if((e=i.next()).done)return e;if(t=e.value,!n||t.undirected===r)break}return{value:[t.key,t.attributes,t.source.key,t.target.key,t.source.attributes,t.target.attributes],done:!1}})}function ke(e,t){if(void 0!==t)for(var n in t)e.add(n)}function xe(e,t,n){for(var r in t){var i=t[r];i instanceof Set&&
(i=i.values().next().value);var o=i.source;i=i.target;o=o===e?i:o;n(o.key,o.attributes)}}function Ee(e,t,n,r){for(var i in n){var o=n[i];o instanceof Set&&(o=o.values().next().value);var a=o.source;o=o.target;a=a===t?o:a;e.has(a.key)||(e.add(a.key),r(a.key,a.attributes))}}function Se(e,t,n){for(var r in t){var i=t[r];i instanceof Set&&(i=i.values().next().value);var o=i.source;i=i.target;o=o===e?i:o;if(n(o.key,o.attributes))return!0}return!1}function Ae(e,t,n,r){for(var i in n){var o=n[i];o instanceof
Set&&(o=o.values().next().value);var a=o.source;o=o.target;a=a===t?o:a;if(!e.has(a.key)&&(e.add(a.key),r(a.key,a.attributes)))return!0}return!1}function Le(e,t){var n=Object.keys(t),r=n.length,i=0;return new O(function(){if(i>=r)return{done:!0};var o=t[n[i++]];o instanceof Set&&(o=o.values().next().value);var a=o.source;o=o.target;a=a===e?o:a;return{done:!1,value:[a.key,a.attributes]}})}function Ne(e,t,n){var r=Object.keys(n),i=r.length,o=0;return new O(function a(){if(o>=i)return{done:!0};var u=
n[r[o++]];u instanceof Set&&(u=u.values().next().value);var d=u.source;u=u.target;d=d===t?u:d;return e.has(d.key)?a():(e.add(d.key),{done:!1,value:[d.key,d.attributes]})})}function je(e$jscomp$0,t$jscomp$0){var n$jscomp$0=t$jscomp$0.name,r=t$jscomp$0.type,i$jscomp$0=t$jscomp$0.direction,o="forEach"+n$jscomp$0[0].toUpperCase()+n$jscomp$0.slice(1,-1);e$jscomp$0.prototype[o]=function(e,t){if("mixed"===r||"mixed"===this.type||r===this.type){e=""+e;var n=this._nodes.get(e);if(void 0===n)throw new M("Graph.".concat(o,
': could not find the "').concat(e,'" node in the graph.'));a:{e="mixed"===r?this.type:r;if("mixed"!==e){if("undirected"===e){t=xe(n,n.undirected,t);break a}if("string"==typeof i$jscomp$0){t=xe(n,n[i$jscomp$0],t);break a}}var i=new Set;"undirected"!==e&&("out"!==i$jscomp$0&&Ee(i,n,n.in,t),"in"!==i$jscomp$0&&Ee(i,n,n.out,t));"directed"!==e&&Ee(i,n,n.undirected,t);t=void 0}!t}}}function Ue(e$jscomp$0,t$jscomp$0){var n$jscomp$0=t$jscomp$0.name,r=t$jscomp$0.type,i$jscomp$0=t$jscomp$0.direction,o="forEach"+
n$jscomp$0[0].toUpperCase()+n$jscomp$0.slice(1,-1)+"Until";e$jscomp$0.prototype[o]=function(e,t){if("mixed"===r||"mixed"===this.type||r===this.type){e=""+e;var n=this._nodes.get(e);if(void 0===n)throw new M("Graph.".concat(o,': could not find the "').concat(e,'" node in the graph.'));a:{e="mixed"===r?this.type:r;if("mixed"!==e){if("undirected"===e){t=Se(n,n.undirected,t);break a}if("string"==typeof i$jscomp$0){t=Se(n,n[i$jscomp$0],t);break a}}var i=new Set;if("undirected"!==e){if("out"!==i$jscomp$0&&
Ae(i,n,n.in,t)){t=void 0;break a}if("in"!==i$jscomp$0&&Ae(i,n,n.out,t)){t=void 0;break a}}"directed"===e||Ae(i,n,n.undirected,t);t=void 0}!t}}}function Oe(e$jscomp$1,t$jscomp$0){var r$jscomp$0=t$jscomp$0.type,i$jscomp$0=t$jscomp$0.direction,o=t$jscomp$0.name.slice(0,-1)+"Entries";e$jscomp$1.prototype[o]=function(e$jscomp$0){if("mixed"!==r$jscomp$0&&"mixed"!==this.type&&r$jscomp$0!==this.type)return O.empty();e$jscomp$0=""+e$jscomp$0;var t=this._nodes.get(e$jscomp$0);if(void 0===t)throw new M("Graph.".concat(o,
': could not find the "').concat(e$jscomp$0,'" node in the graph.'));a:{var e="mixed"===r$jscomp$0?this.type:r$jscomp$0;if("mixed"!==e){if("undirected"===e){e$jscomp$0=Le(t,t.undirected);break a}if("string"==typeof i$jscomp$0){e$jscomp$0=Le(t,t[i$jscomp$0]);break a}}var r=O.empty(),i=new Set;e$jscomp$0=("undirected"!==e&&("out"!==i$jscomp$0&&(r=q(r,Ne(i,t,t.in))),"in"!==i$jscomp$0&&(r=q(r,Ne(i,t,t.out)))),"directed"!==e&&(r=q(r,Ne(i,t,t.undirected))),r)}return e$jscomp$0}}function Ce(e,t,n){var r,
o,a,u,d,c,s=t._nodes.values();for(t=t.type;!0!==(r=s.next()).done;){if(r=r.value,"undirected"!==t)for(o in a=r.out)if(d=(u=a[o]).target,c=n(r.key,d.key,r.attributes,d.attributes,u.key,u.attributes,u.undirected,u.generatedKey),e&&c)return;if("directed"!==t)for(o in a=r.undirected)if((d=(u=a[o]).target).key!==o&&(d=u.source),c=n(r.key,d.key,r.attributes,d.attributes,u.key,u.attributes,u.undirected,u.generatedKey),e&&c)return}}function Ke(e,t,n){var r,o,a,u,d,c,s,h,f=t._nodes.values();for(t=t.type;!0!==
(r=f.next()).done;){if(r=r.value,"undirected"!==t)for(o in d=r.out)for(a=d[o].values();!0!==(u=a.next()).done;)if(s=(c=u.value).target,h=n(r.key,s.key,r.attributes,s.attributes,c.key,c.attributes,c.undirected,c.generatedKey),e&&h)return;if("directed"!==t)for(o in d=r.undirected)for(a=d[o].values();!0!==(u=a.next()).done;)if((s=(c=u.value).target).key!==o&&(s=c.source),h=n(r.key,s.key,r.attributes,s.attributes,c.key,c.attributes,c.undirected,c.generatedKey),e&&h)return}}function ze(e,t){e={key:e};
return f$jscomp$0(t.attributes)||(e.attributes=d$jscomp$1({},t.attributes)),e}function Me(e,t){var n={source:t.source.key,target:t.target.key};return t.generatedKey||(n.key=e),f$jscomp$0(t.attributes)||(n.attributes=d$jscomp$1({},t.attributes)),t.undirected&&(n.undirected=!0),n}function We(e,t,n){var r=new e.NodeDataClass(t,n);return e._nodes.set(t,r),e.emit("nodeAdded",{key:t,attributes:n}),r}function Ye(e,t,n,r,i,o,a,u){if(!r&&"undirected"===e.type)throw new P("Graph.".concat(t,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));
if(r&&"directed"===e.type)throw new P("Graph.".concat(t,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(u&&!h$jscomp$0(u))throw new z("Graph.".concat(t,': invalid attributes. Expecting an object but got "').concat(u,'"'));if(o=""+o,a=""+a,u=u||{},!e.allowSelfLoops&&o===a)throw new P("Graph.".concat(t,': source \x26 target are the same ("').concat(o,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));
var d=e._nodes.get(o),c=e._nodes.get(a);if(!d)throw new M("Graph.".concat(t,': source node "').concat(o,'" not found.'));if(!c)throw new M("Graph.".concat(t,': target node "').concat(a,'" not found.'));var s={key:null,undirected:r,source:o,target:a,attributes:u};if(n&&(i=e._edgeKeyGenerator(s)),i=""+i,e._edges.has(i))throw new P("Graph.".concat(t,': the "').concat(i,'" edge already exists in the graph.'));if(!e.multi&&(r?void 0!==d.undirected[a]:void 0!==d.out[a]))throw new P("Graph.".concat(t,': an edge linking "').concat(o,
'" to "').concat(a,"\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option."));t=new I(r,i,n,d,c,u);return e._edges.set(i,t),o===a?r?(d.undirectedSelfLoops++,e._undirectedSelfLoopCount++):(d.directedSelfLoops++,e._directedSelfLoopCount++):r?(d.undirectedDegree++,c.undirectedDegree++):(d.outDegree++,c.inDegree++),W(e,r,t,o,a,d,c),r?e._undirectedSize++:e._directedSize++,s.key=i,e.emit("edgeAdded",s),i}function Be(e,
t,n,r,i,o,a,u,c){if(!r&&"undirected"===e.type)throw new P("Graph.".concat(t,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(r&&"directed"===e.type)throw new P("Graph.".concat(t,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(u)if(c){if("function"!=typeof u)throw new z("Graph.".concat(t,': invalid updater function. Expecting a function but got "').concat(u,'"'));}else if(!h$jscomp$0(u))throw new z("Graph.".concat(t,
': invalid attributes. Expecting an object but got "').concat(u,'"'));var s;if(o=""+o,a=""+a,c&&(s=u,u=void 0),!e.allowSelfLoops&&o===a)throw new P("Graph.".concat(t,': source \x26 target are the same ("').concat(o,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var f,g=e._nodes.get(o),l=e._nodes.get(a);if(!n&&(f=e._edges.get(i))){if(f.source.key!==o||f.target.key!==a||r&&(f.source.key!==a||f.target.key!==o))throw new P("Graph.".concat(t,': inconsistency detected when attempting to merge the "').concat(i,
'" edge with "').concat(o,'" source \x26 "').concat(a,'" target vs. ("').concat(f.source.key,'", "').concat(f.target.key,'").'));var p=f}if(p||e.multi||!g||(p=r?g.undirected[a]:g.out[a]),p){if(c?!s:!u)return p.key;c?(p.attributes=s(p.attributes),e.emit("edgeAttributesUpdated",{type:"replace",key:p.key,attributes:p.attributes})):(d$jscomp$1(p.attributes,u),e.emit("edgeAttributesUpdated",{type:"merge",key:p.key,attributes:p.attributes,data:u}));return p.key}u=u||{};c&&s&&(u=s(u));c={key:null,undirected:r,
source:o,target:a,attributes:u};if(n&&(i=e._edgeKeyGenerator(c)),i=""+i,e._edges.has(i))throw new P("Graph.".concat(t,': the "').concat(i,'" edge already exists in the graph.'));return g||(g=We(e,o,{}),o===a&&(l=g)),l||=We(e,a,{}),f=new I(r,i,n,g,l,u),e._edges.set(i,f),o===a?r?(g.undirectedSelfLoops++,e._undirectedSelfLoopCount++):(g.directedSelfLoops++,e._directedSelfLoopCount++):r?(g.undirectedDegree++,l.undirectedDegree++):(g.outDegree++,l.inDegree++),W(e,r,f,o,a,g,l),r?e._undirectedSize++:e._directedSize++,
c.key=i,e.emit("edgeAdded",c),i}function Ze(e){e.from=function(t,n){n=d$jscomp$1({},t.options,n);n=new e(n);return n.import(t),n}}var d$jscomp$1=function(){for(var e=arguments[0],t=1,n=arguments.length;t<n;t++)if(arguments[t])for(var r in arguments[t])e[r]=arguments[t][r];return e};"function"==typeof Object.assign&&(d$jscomp$1=Object.assign);var JSCompiler_object_inline_exports_4508={},w=(JSCompiler_object_inline_exports_4508="object"==typeof Reflect?Reflect:null)&&"function"==typeof JSCompiler_object_inline_exports_4508.apply?
JSCompiler_object_inline_exports_4508.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};var y=JSCompiler_object_inline_exports_4508&&"function"==typeof JSCompiler_object_inline_exports_4508.ownKeys?JSCompiler_object_inline_exports_4508.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var m=Number.isNaN||function(e){return e!=e};JSCompiler_object_inline_exports_4508=
_;JSCompiler_object_inline_exports_4508.once=function(e$jscomp$0,t$jscomp$0){return new Promise(function(n$jscomp$0,r){function i(n){e$jscomp$0.removeListener(t$jscomp$0,o);r(n)}function o(){"function"==typeof e$jscomp$0.removeListener&&e$jscomp$0.removeListener("error",i);n$jscomp$0([].slice.call(arguments))}j(e$jscomp$0,t$jscomp$0,o,{once:!0});"error"!==t$jscomp$0&&function(e,t,n){"function"==typeof e.on&&j(e,"error",t,n)}(e$jscomp$0,i,{once:!0})})};_.EventEmitter=_;_.prototype._events=void 0;_.prototype._eventsCount=
0;_.prototype._maxListeners=void 0;var k=10;Object.defineProperty(_,"defaultMaxListeners",{enumerable:!0,get:function(){return k},set:function(e){if("number"!=typeof e||0>e||m(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");k=e}});_.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0);this._maxListeners=this._maxListeners||void 0};
_.prototype.setMaxListeners=function(e){if("number"!=typeof e||0>e||m(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this};_.prototype.getMaxListeners=function(){return void 0===this._maxListeners?_.defaultMaxListeners:this._maxListeners};_.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);n="error"===e;var i=this._events;if(void 0!==i)n=n&&void 0===i.error;else if(!n)return!1;
if(n){var o;if(0<t.length&&(o=t[0]),o instanceof Error)throw o;t=Error("Unhandled error."+(o?" ("+o.message+")":""));throw t.context=o,t;}n=i[e];if(void 0===n)return!1;if("function"==typeof n)w(n,this,t);else for(o=n.length,i=D(n,o),n=0;n<o;++n)w(i[n],this,t);return!0};_.prototype.addListener=function(e,t){return E(this,e,t,!1)};_.prototype.on=_.prototype.addListener;_.prototype.prependListener=function(e,t){return E(this,e,t,!0)};_.prototype.once=function(e,t){return G(t),this.on(e,A(this,e,t)),
this};_.prototype.prependOnceListener=function(e,t){return G(t),this.prependListener(e,A(this,e,t)),this};_.prototype.removeListener=function(e,t){var n,r,o;if((G(t),void 0===(r=this._events))||void 0===(n=r[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){var i=-1;for(o=n.length-1;0<=o;o--)if(n[o]===t||n[o].listener===t){var a=n[o].listener;i=o;
break}if(0>i)return this;if(0===i)n.shift();else{for(;i+1<n.length;i++)n[i]=n[i+1];n.pop()}1===n.length&&(r[e]=n[0]);void 0!==r.removeListener&&this.emit("removeListener",e,a||t)}return this};_.prototype.off=_.prototype.removeListener;_.prototype.removeAllListeners=function(e){var t,n;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):
delete n[e]),this;if(0===arguments.length){var o=Object.keys(n);for(n=0;n<o.length;++n)"removeListener"!==(t=o[n])&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;0<=n;n--)this.removeListener(e,t[n]);return this};_.prototype.listeners=function(e){return L(this,e,!0)};_.prototype.rawListeners=function(e){return L(this,e,!1)};
_.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):N.call(e,t)};_.prototype.listenerCount=N;_.prototype.eventNames=function(){return 0<this._eventsCount?y(this._events):[]};U.prototype.next=function(){if(this.done)return{done:!0};var e=this._next();return e.done&&(this.done=!0),e};"undefined"!=typeof Symbol&&(U.prototype[Symbol.iterator]=function(){return this});U.of=function(){var e=arguments,t=e.length,n=0;return new U(function(){return n>=t?{done:!0}:{done:!1,
value:e[n++]}})};U.empty=function(){var e=new U(null);return e.done=!0,e};U.is=function(e){return e instanceof U||"object"==typeof e&&null!==e&&"function"==typeof e.next};var O=U,C=function(e,t){for(var n,r=1<arguments.length?t:1/0,i=r!==1/0?Array(r):[],o=0;;){if(o===r)return i;if((n=e.next()).done)return o!==t?i.slice(0,o):i;i[o++]=n.value}},K=function(e){function n$jscomp$0(t,n){var r;return(r=e.call(this)||this).name="GraphError",r.message=t||"",r.data=n||{},r}return t$jscomp$2(n$jscomp$0,e),n$jscomp$0}(a$jscomp$1(Error)),
z=function(e){function n(t,r){var i;return(i=e.call(this,t,r)||this).name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(u$jscomp$1(i),n.prototype.constructor),i}return t$jscomp$2(n,e),n}(K),M=function(e){function n(t,r){var i;return(i=e.call(this,t,r)||this).name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(u$jscomp$1(i),n.prototype.constructor),i}return t$jscomp$2(n,e),n}(K),P=function(e){function n(t,
r){var i;return(i=e.call(this,t,r)||this).name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(u$jscomp$1(i),n.prototype.constructor),i}return t$jscomp$2(n,e),n}(K);R.prototype.upgradeToMixed=function(){this.undirectedSelfLoops=this.undirectedDegree=0;this.undirected={}};F.prototype.upgradeToMixed=function(){this.directedSelfLoops=this.outDegree=this.inDegree=0;this.in={};this.out={}};var B=[{name:function(e){return"get".concat(e,"Attribute")},attacher:function(e$jscomp$0,
t,n){e$jscomp$0.prototype[t]=function(e,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(2<arguments.length){if(this.multi)throw new P("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+e,a=""+r;if(r=arguments[2],!(i=c$jscomp$0(this,o,a,n)))throw new M("Graph.".concat(t,
': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'));}else if(e=""+e,!(i=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if("mixed"!==n&&i.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" ').concat(n," edge in the graph."));return i.attributes[r]}}},{name:function(e){return"get".concat(e,"Attributes")},attacher:function(e$jscomp$0,t,n){e$jscomp$0.prototype[t]=
function(e){var r;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(1<arguments.length){if(this.multi)throw new P("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var i=""+e,o=""+arguments[1];if(!(r=c$jscomp$0(this,i,o,n)))throw new M("Graph.".concat(t,': could not find an edge for the given path ("').concat(i,
'" - "').concat(o,'").'));}else if(e=""+e,!(r=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if("mixed"!==n&&r.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" ').concat(n," edge in the graph."));return r.attributes}}},{name:function(e){return"has".concat(e,"Attribute")},attacher:function(e$jscomp$0,t,n){e$jscomp$0.prototype[t]=function(e,r){var i;if("mixed"!==this.type&&"mixed"!==n&&
n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(2<arguments.length){if(this.multi)throw new P("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+e,a=""+r;if(r=arguments[2],!(i=c$jscomp$0(this,o,a,n)))throw new M("Graph.".concat(t,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,
'").'));}else if(e=""+e,!(i=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if("mixed"!==n&&i.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" ').concat(n," edge in the graph."));return i.attributes.hasOwnProperty(r)}}},{name:function(e){return"set".concat(e,"Attribute")},attacher:function(e$jscomp$0,t,n){e$jscomp$0.prototype[t]=function(e,r,i){var o;if("mixed"!==this.type&&"mixed"!==n&&
n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(3<arguments.length){if(this.multi)throw new P("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+r;if(r=arguments[2],i=arguments[3],!(o=c$jscomp$0(this,a,u,n)))throw new M("Graph.".concat(t,': could not find an edge for the given path ("').concat(a,
'" - "').concat(u,'").'));}else if(e=""+e,!(o=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if("mixed"!==n&&o.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" ').concat(n," edge in the graph."));return o.attributes[r]=i,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:function(e){return"update".concat(e,"Attribute")},attacher:function(e$jscomp$0,
t,n){e$jscomp$0.prototype[t]=function(e,r,i){var o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(3<arguments.length){if(this.multi)throw new P("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+r;if(r=arguments[2],i=arguments[3],!(o=c$jscomp$0(this,a,u,
n)))throw new M("Graph.".concat(t,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'));}else if(e=""+e,!(o=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if("function"!=typeof i)throw new z("Graph.".concat(t,": updater should be a function."));if("mixed"!==n&&o.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" ').concat(n," edge in the graph."));return o.attributes[r]=
i(o.attributes[r]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:function(e){return"remove".concat(e,"Attribute")},attacher:function(e$jscomp$0,t,n){e$jscomp$0.prototype[t]=function(e,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(2<arguments.length){if(this.multi)throw new P("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
var o=""+e,a=""+r;if(r=arguments[2],!(i=c$jscomp$0(this,o,a,n)))throw new M("Graph.".concat(t,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'));}else if(e=""+e,!(i=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if("mixed"!==n&&i.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" ').concat(n," edge in the graph."));return delete i.attributes[r],this.emit("edgeAttributesUpdated",
{key:i.key,type:"remove",attributes:i.attributes,name:r}),this}}},{name:function(e){return"replace".concat(e,"Attributes")},attacher:function(e$jscomp$0,t,n){e$jscomp$0.prototype[t]=function(e,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(2<arguments.length){if(this.multi)throw new P("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
var o=""+e,a=""+r;if(r=arguments[2],!(i=c$jscomp$0(this,o,a,n)))throw new M("Graph.".concat(t,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'));}else if(e=""+e,!(i=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if(!h$jscomp$0(r))throw new z("Graph.".concat(t,": provided attributes are not a plain object."));if("mixed"!==n&&i.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,
'" ').concat(n," edge in the graph."));return i.attributes=r,this.emit("edgeAttributesUpdated",{key:i.key,type:"replace",attributes:i.attributes}),this}}},{name:function(e){return"merge".concat(e,"Attributes")},attacher:function(e$jscomp$0,t,n){e$jscomp$0.prototype[t]=function(e,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new P("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(2<arguments.length){if(this.multi)throw new P("Graph.".concat(t,
": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+e,a=""+r;if(r=arguments[2],!(i=c$jscomp$0(this,o,a,n)))throw new M("Graph.".concat(t,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'));}else if(e=""+e,!(i=this._edges.get(e)))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'));if(!h$jscomp$0(r))throw new z("Graph.".concat(t,
": provided attributes are not a plain object."));if("mixed"!==n&&i.undirected!==("undirected"===n))throw new M("Graph.".concat(t,': could not find the "').concat(e,'" ').concat(n," edge in the graph."));return d$jscomp$1(i.attributes,r),this.emit("edgeAttributesUpdated",{key:i.key,type:"merge",attributes:i.attributes,data:r}),this}}}],J=O,q=function(){var e,t=arguments,n=-1;return new J(function r(){if(!e){if(++n>=t.length)return{done:!0};e=t[n]}var i=e.next();return i.done?(e=null,r()):i})},H=[{name:"edges",
type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}],_e=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",
type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}],Re=new Set(["directed","undirected","mixed"]),Fe=new Set(["domain","_events","_eventsCount","_maxListeners"]),Ie={allowSelfLoops:!0,edgeKeyGenerator:null,multi:!1,type:"mixed"},Je=function(e$jscomp$2){function n$jscomp$1(t){var n;if(n=e$jscomp$2.call(this)||this,(t=d$jscomp$1({},Ie,t)).edgeKeyGenerator&&"function"!=typeof t.edgeKeyGenerator)throw new z("Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"".concat(t.edgeKeyGenerator,
'".'));if("boolean"!=typeof t.multi)throw new z("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(t.multi,'".'));if(!Re.has(t.type))throw new z('Graph.constructor: invalid \'type\' option. Should be one of "mixed", "directed" or "undirected" but got "'.concat(t.type,'".'));if("boolean"!=typeof t.allowSelfLoops)throw new z("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(t.allowSelfLoops,'".'));var r,i="mixed"===t.type?T:"directed"===
t.type?R:F;return p$jscomp$0(u$jscomp$1(n),"NodeDataClass",i),p$jscomp$0(u$jscomp$1(n),"_attributes",{}),p$jscomp$0(u$jscomp$1(n),"_nodes",new Map),p$jscomp$0(u$jscomp$1(n),"_edges",new Map),p$jscomp$0(u$jscomp$1(n),"_directedSize",0),p$jscomp$0(u$jscomp$1(n),"_undirectedSize",0),p$jscomp$0(u$jscomp$1(n),"_directedSelfLoopCount",0),p$jscomp$0(u$jscomp$1(n),"_undirectedSelfLoopCount",0),p$jscomp$0(u$jscomp$1(n),"_edgeKeyGenerator",t.edgeKeyGenerator||(r=0,function(){return r++})),p$jscomp$0(u$jscomp$1(n),
"_options",t),Fe.forEach(function(e){return p$jscomp$0(u$jscomp$1(n),e,n[e])}),g$jscomp$0(u$jscomp$1(n),"order",function(){return n._nodes.size}),g$jscomp$0(u$jscomp$1(n),"size",function(){return n._edges.size}),g$jscomp$0(u$jscomp$1(n),"directedSize",function(){return n._directedSize}),g$jscomp$0(u$jscomp$1(n),"undirectedSize",function(){return n._undirectedSize}),g$jscomp$0(u$jscomp$1(n),"selfLoopCount",function(){return n._directedSelfLoopCount+n._undirectedSelfLoopCount}),g$jscomp$0(u$jscomp$1(n),
"directedSelfLoopCount",function(){return n._directedSelfLoopCount}),g$jscomp$0(u$jscomp$1(n),"undirectedSelfLoopCount",function(){return n._undirectedSelfLoopCount}),g$jscomp$0(u$jscomp$1(n),"multi",n._options.multi),g$jscomp$0(u$jscomp$1(n),"type",n._options.type),g$jscomp$0(u$jscomp$1(n),"allowSelfLoops",n._options.allowSelfLoops),g$jscomp$0(u$jscomp$1(n),"implementation",function(){return"graphology"}),n}t$jscomp$2(n$jscomp$1,e$jscomp$2);var r$jscomp$1=n$jscomp$1.prototype;return r$jscomp$1.hasNode=
function(e){return this._nodes.has(""+e)},r$jscomp$1.hasDirectedEdge=function(e,t){if("undirected"===this.type)return!1;if(1===arguments.length){var r=this._edges.get(""+e);return!!r&&!r.undirected}if(2===arguments.length){t=""+t;r=this._nodes.get(""+e);if(!r)return!1;r=r.out[t];return!!r&&(!this.multi||!!r.size)}throw new z("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source \x26 a target."));
},r$jscomp$1.hasUndirectedEdge=function(e,t){if("directed"===this.type)return!1;if(1===arguments.length){var r=this._edges.get(""+e);return!!r&&r.undirected}if(2===arguments.length){t=""+t;r=this._nodes.get(""+e);if(!r)return!1;r=r.undirected[t];return!!r&&(!this.multi||!!r.size)}throw new z("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source \x26 a target."));},r$jscomp$1.hasEdge=
function(e,t){if(1===arguments.length)return this._edges.has(""+e);if(2===arguments.length){t=""+t;var r=this._nodes.get(""+e);if(!r)return!1;var i=void 0!==r.out&&r.out[t];return i||=void 0!==r.undirected&&r.undirected[t],!!i&&(!this.multi||!!i.size)}throw new z("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source \x26 a target."));},r$jscomp$1.directedEdge=function(e,t){if("undirected"!==
this.type){if(e=""+e,t=""+t,this.multi)throw new P("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source \x26 target. See #.directedEdges instead.");var n=this._nodes.get(e);if(!n)throw new M('Graph.directedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new M('Graph.directedEdge: could not find the "'.concat(t,'" target node in the graph.'));return(e=n.out&&n.out[t]||void 0)?e.key:void 0}},
r$jscomp$1.undirectedEdge=function(e,t){if("directed"!==this.type){if(e=""+e,t=""+t,this.multi)throw new P("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source \x26 target. See #.undirectedEdges instead.");var n=this._nodes.get(e);if(!n)throw new M('Graph.undirectedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new M('Graph.undirectedEdge: could not find the "'.concat(t,'" target node in the graph.'));
return(e=n.undirected&&n.undirected[t]||void 0)?e.key:void 0}},r$jscomp$1.edge=function(e,t){if(this.multi)throw new P("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source \x26 target. See #.edges instead.");e=""+e;t=""+t;var n=this._nodes.get(e);if(!n)throw new M('Graph.edge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new M('Graph.edge: could not find the "'.concat(t,'" target node in the graph.'));
if(e=n.out&&n.out[t]||n.undirected&&n.undirected[t]||void 0)return e.key},r$jscomp$1.inDegree=function(e){var t=!(1<arguments.length&&void 0!==arguments[1])||arguments[1];if("boolean"!=typeof t)throw new z('Graph.inDegree: Expecting a boolean but got "'.concat(t,'" for the second parameter (allowing self-loops to be counted).'));e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.inDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:n.inDegree+(t?
n.directedSelfLoops:0)},r$jscomp$1.outDegree=function(e){var t=!(1<arguments.length&&void 0!==arguments[1])||arguments[1];if("boolean"!=typeof t)throw new z('Graph.outDegree: Expecting a boolean but got "'.concat(t,'" for the second parameter (allowing self-loops to be counted).'));e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.outDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:n.outDegree+(t?n.directedSelfLoops:0)},r$jscomp$1.directedDegree=
function(e){var t=!(1<arguments.length&&void 0!==arguments[1])||arguments[1];if("boolean"!=typeof t)throw new z('Graph.directedDegree: Expecting a boolean but got "'.concat(t,'" for the second parameter (allowing self-loops to be counted).'));e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.directedDegree: could not find the "'.concat(e,'" node in the graph.'));if("undirected"===this.type)return 0;t=t?n.directedSelfLoops:0;return n.inDegree+t+(n.outDegree+t)},r$jscomp$1.undirectedDegree=function(e){var t=
!(1<arguments.length&&void 0!==arguments[1])||arguments[1];if("boolean"!=typeof t)throw new z('Graph.undirectedDegree: Expecting a boolean but got "'.concat(t,'" for the second parameter (allowing self-loops to be counted).'));e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.undirectedDegree: could not find the "'.concat(e,'" node in the graph.'));return"directed"===this.type?0:n.undirectedDegree+2*(t?n.undirectedSelfLoops:0)},r$jscomp$1.degree=function(e){var t=!(1<arguments.length&&void 0!==
arguments[1])||arguments[1];if("boolean"!=typeof t)throw new z('Graph.degree: Expecting a boolean but got "'.concat(t,'" for the second parameter (allowing self-loops to be counted).'));e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.degree: could not find the "'.concat(e,'" node in the graph.'));var r=0,i=0;return"directed"!==this.type&&(t&&(i=n.undirectedSelfLoops),r+=n.undirectedDegree+2*i),"undirected"!==this.type&&(t&&(i=n.directedSelfLoops),r+=n.inDegree+n.outDegree+2*i),r},r$jscomp$1.source=
function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.source: could not find the "'.concat(e,'" edge in the graph.'));return t.source.key},r$jscomp$1.target=function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.target: could not find the "'.concat(e,'" edge in the graph.'));return t.target.key},r$jscomp$1.extremities=function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.extremities: could not find the "'.concat(e,'" edge in the graph.'));return[t.source.key,
t.target.key]},r$jscomp$1.opposite=function(e,t){e=""+e;t=""+t;var n=this._edges.get(t);if(!n)throw new M('Graph.opposite: could not find the "'.concat(t,'" edge in the graph.'));var r=n.source.key;n=n.target.key;if(e!==r&&e!==n)throw new M('Graph.opposite: the "'.concat(e,'" node is not attached to the "').concat(t,'" edge (').concat(r,", ").concat(n,")."));return e===r?n:r},r$jscomp$1.hasExtremity=function(e,t){e=""+e;t=""+t;var n=this._edges.get(e);if(!n)throw new M('Graph.hasExtremity: could not find the "'.concat(e,
'" edge in the graph.'));return n.source.key===t||n.target.key===t},r$jscomp$1.isUndirected=function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.isUndirected: could not find the "'.concat(e,'" edge in the graph.'));return t.undirected},r$jscomp$1.isDirected=function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.isDirected: could not find the "'.concat(e,'" edge in the graph.'));return!t.undirected},r$jscomp$1.isSelfLoop=function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.isSelfLoop: could not find the "'.concat(e,
'" edge in the graph.'));return t.source===t.target},r$jscomp$1.hasGeneratedKey=function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.hasGeneratedKey: could not find the "'.concat(e,'" edge in the graph.'));return t.generatedKey},r$jscomp$1.addNode=function(e,t){if(t&&!h$jscomp$0(t))throw new z('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(t,'"'));if(e=""+e,t=t||{},this._nodes.has(e))throw new P('Graph.addNode: the "'.concat(e,'" node already exist in the graph.'));
var r=new this.NodeDataClass(e,t);return(this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),r).key},r$jscomp$1.mergeNode=function(e,t){if(t&&!h$jscomp$0(t))throw new z('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(t,'"'));e=""+e;t=t||{};var n=this._nodes.get(e);return n?(t&&(d$jscomp$1(n.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:n.attributes,data:t})),e):(n=new this.NodeDataClass(e,t),this._nodes.set(e,n),this.emit("nodeAdded",
{key:e,attributes:t}),e)},r$jscomp$1.updateNode=function(e,t){if(t&&"function"!=typeof t)throw new z('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(t,'"'));e=""+e;var n=this._nodes.get(e);if(n)return t&&(n.attributes=t(n.attributes),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:n.attributes})),e;t=t?t({}):{};return n=new this.NodeDataClass(e,t),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:t}),e},r$jscomp$1.dropNode=function(e$jscomp$0){var t=
this;e$jscomp$0=""+e$jscomp$0;var n=this._nodes.get(e$jscomp$0);if(!n)throw new M('Graph.dropNode: could not find the "'.concat(e$jscomp$0,'" node in the graph.'));this.forEachEdge(e$jscomp$0,function(e){t.dropEdge(e)});this._nodes.delete(e$jscomp$0);this.emit("nodeDropped",{key:e$jscomp$0,attributes:n.attributes})},r$jscomp$1.dropEdge=function(e){var t;if(1<arguments.length){var n=""+arguments[0],r=""+arguments[1];if(!(t=c$jscomp$0(this,n,r,this.type)))throw new M('Graph.dropEdge: could not find the "'.concat(n,
'" -\x3e "').concat(r,'" edge in the graph.'));}else if(e=""+e,!(t=this._edges.get(e)))throw new M('Graph.dropEdge: could not find the "'.concat(e,'" edge in the graph.'));this._edges.delete(t.key);var i=t;n=i.source;r=i.target;i=i.attributes;var d=t.undirected;n===r?d?(n.undirectedSelfLoops--,this._undirectedSelfLoopCount--):(n.directedSelfLoops--,this._directedSelfLoopCount--):d?(n.undirectedDegree--,r.undirectedDegree--):(n.outDegree--,r.inDegree--);var r$jscomp$0=this.multi,i$jscomp$0=t.source,
o=t.target,a=i$jscomp$0.key,u=o.key;i$jscomp$0=i$jscomp$0[d?"undirected":"out"];var c=d?"undirected":"in";if(u in i$jscomp$0)if(r$jscomp$0){var s=i$jscomp$0[u];1===s.size?(delete i$jscomp$0[u],delete o[c][a]):s.delete(t)}else delete i$jscomp$0[u];r$jscomp$0||delete o[c][a];return d?this._undirectedSize--:this._directedSize--,this.emit("edgeDropped",{key:e,attributes:i,source:n.key,target:r.key,undirected:d}),this},r$jscomp$1.clear=function(){this._edges.clear();this._nodes.clear();this.emit("cleared")},
r$jscomp$1.clearEdges=function(){this._edges.clear();this.clearIndex();this.emit("edgesCleared")},r$jscomp$1.getAttribute=function(e){return this._attributes[e]},r$jscomp$1.getAttributes=function(){return this._attributes},r$jscomp$1.hasAttribute=function(e){return this._attributes.hasOwnProperty(e)},r$jscomp$1.setAttribute=function(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this},r$jscomp$1.updateAttribute=function(e,t){if("function"!=
typeof t)throw new z("Graph.updateAttribute: updater should be a function.");return this._attributes[e]=t(this._attributes[e]),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this},r$jscomp$1.removeAttribute=function(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this},r$jscomp$1.replaceAttributes=function(e){if(!h$jscomp$0(e))throw new z("Graph.replaceAttributes: provided attributes are not a plain object.");
return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},r$jscomp$1.mergeAttributes=function(e){if(!h$jscomp$0(e))throw new z("Graph.mergeAttributes: provided attributes are not a plain object.");return d$jscomp$1(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this},r$jscomp$1.getNodeAttribute=function(e,t){e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.getNodeAttribute: could not find the "'.concat(e,
'" node in the graph.'));return n.attributes[t]},r$jscomp$1.getNodeAttributes=function(e){e=""+e;var t=this._nodes.get(e);if(!t)throw new M('Graph.getNodeAttributes: could not find the "'.concat(e,'" node in the graph.'));return t.attributes},r$jscomp$1.hasNodeAttribute=function(e,t){e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.hasNodeAttribute: could not find the "'.concat(e,'" node in the graph.'));return n.attributes.hasOwnProperty(t)},r$jscomp$1.setNodeAttribute=function(e,t,n){e=
""+e;var r=this._nodes.get(e);if(!r)throw new M('Graph.setNodeAttribute: could not find the "'.concat(e,'" node in the graph.'));if(3>arguments.length)throw new z("Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.");return r.attributes[t]=n,this.emit("nodeAttributesUpdated",{key:e,type:"set",attributes:r.attributes,name:t}),this},r$jscomp$1.updateNodeAttribute=function(e,
t,n){e=""+e;var r=this._nodes.get(e);if(!r)throw new M('Graph.updateNodeAttribute: could not find the "'.concat(e,'" node in the graph.'));if(3>arguments.length)throw new z("Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.");if("function"!=typeof n)throw new z("Graph.updateAttribute: updater should be a function.");var i=r.attributes,o=n(i[t]);return i[t]=o,this.emit("nodeAttributesUpdated",
{key:e,type:"set",attributes:r.attributes,name:t}),this},r$jscomp$1.removeNodeAttribute=function(e,t){e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.hasNodeAttribute: could not find the "'.concat(e,'" node in the graph.'));return delete n.attributes[t],this.emit("nodeAttributesUpdated",{key:e,type:"remove",attributes:n.attributes,name:t}),this},r$jscomp$1.replaceNodeAttributes=function(e,t){e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.replaceNodeAttributes: could not find the "'.concat(e,
'" node in the graph.'));if(!h$jscomp$0(t))throw new z("Graph.replaceNodeAttributes: provided attributes are not a plain object.");return n.attributes=t,this.emit("nodeAttributesUpdated",{key:e,type:"replace",attributes:n.attributes}),this},r$jscomp$1.mergeNodeAttributes=function(e,t){e=""+e;var n=this._nodes.get(e);if(!n)throw new M('Graph.mergeNodeAttributes: could not find the "'.concat(e,'" node in the graph.'));if(!h$jscomp$0(t))throw new z("Graph.mergeNodeAttributes: provided attributes are not a plain object.");
return d$jscomp$1(n.attributes,t),this.emit("nodeAttributesUpdated",{key:e,type:"merge",attributes:n.attributes,data:t}),this},r$jscomp$1.updateEachNodeAttributes=function(e,t){if("function"!=typeof e)throw new z("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!l$jscomp$0(t))throw new z("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var n,r,i=this._nodes.values();!0!==(n=i.next()).done;)(r=n.value).attributes=
e(r.key,r.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})},r$jscomp$1.updateEachEdgeAttributes=function(e,t){if("function"!=typeof e)throw new z("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!l$jscomp$0(t))throw new z("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var n,r,i=this._edges.values();!0!==(n=i.next()).done;)(r=n.value).attributes=e(r.key,r.attributes);this.emit("eachEdgeAttributesUpdated",
{hints:t||null})},r$jscomp$1.forEach=function(e){if("function"!=typeof e)throw new z("Graph.forEach: expecting a callback.");this.multi?Ke(!1,this,e):Ce(!1,this,e)},r$jscomp$1.forEachUntil=function(e){if("function"!=typeof e)throw new z("Graph.forEach: expecting a callback.");this.multi?Ke(!0,this,e):Ce(!0,this,e)},r$jscomp$1.adjacency=function(){return this.multi?(o$jscomp$0=(e$jscomp$1=this)._nodes.values(),a$jscomp$0=e$jscomp$1.type,u$jscomp$0="outer",d$jscomp$0=null,new O(function e(){var c;if("outer"===
u$jscomp$0)return!0===(c=o$jscomp$0.next()).done?c:(t$jscomp$0=c.value,u$jscomp$0="directed",e());if("directed"===u$jscomp$0)return"undirected"===a$jscomp$0?(u$jscomp$0="undirected",e()):(r$jscomp$0=t$jscomp$0.out,n$jscomp$0=Object.keys(t$jscomp$0.out),i$jscomp$0=0,u$jscomp$0="inner-directed",e());if("undirected"===u$jscomp$0){if("directed"===a$jscomp$0)return u$jscomp$0="outer",e();r$jscomp$0=t$jscomp$0.undirected;n$jscomp$0=Object.keys(t$jscomp$0.undirected);i$jscomp$0=0;u$jscomp$0="inner-undirected"}if(!d$jscomp$0&&
i$jscomp$0>=n$jscomp$0.length)return u$jscomp$0="inner-undirected"===u$jscomp$0?"outer":"undirected",e();if(!d$jscomp$0)return c=n$jscomp$0[i$jscomp$0++],d$jscomp$0=r$jscomp$0[c].values(),e();if((c=d$jscomp$0.next()).done)return d$jscomp$0=null,e();c=c.value;var f=c.target;return"inner-undirected"===u$jscomp$0&&f.key===t$jscomp$0.key&&(f=c.source),{done:!1,value:[t$jscomp$0.key,f.key,t$jscomp$0.attributes,f.attributes,c.key,c.attributes]}})):function(e$jscomp$0){var t,n,r,i,o=e$jscomp$0._nodes.values(),
a=e$jscomp$0.type,u="outer";return new O(function e(){var d;if("outer"===u)return!0===(d=o.next()).done?d:(t=d.value,u="directed",e());if("directed"===u)return"undirected"===a?(u="undirected",e()):(r=t.out,n=Object.keys(t.out),i=0,u="inner-directed",e());if("undirected"===u){if("directed"===a)return u="outer",e();r=t.undirected;n=Object.keys(t.undirected);i=0;u="inner-undirected"}if(i>=n.length)return u="inner-undirected"===u?"outer":"undirected",e();d=n[i++];d=r[d];var h=d.target;return"inner-undirected"===
u&&h.key===t.key&&(h=d.source),{done:!1,value:[t.key,h.key,t.attributes,h.attributes,d.key,d.attributes]}})}(this);var e$jscomp$1,t$jscomp$0,n$jscomp$0,r$jscomp$0,i$jscomp$0,o$jscomp$0,a$jscomp$0,u$jscomp$0,d$jscomp$0},r$jscomp$1.nodes=function(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):C(this._nodes.keys(),this._nodes.size)},r$jscomp$1.forEachNode=function(e){if("function"!=typeof e)throw new z("Graph.forEachNode: expecting a callback.");this._nodes.forEach(function(t,n){e(n,
t.attributes)})},r$jscomp$1.forEachNodeUntil=function(e){if("function"!=typeof e)throw new z("Graph.forEachNode: expecting a callback.");for(var t,n,r=this._nodes.values();!0!==(t=r.next())&&!e((n=t.value).key,n.attributes););},r$jscomp$1.nodeEntries=function(){var e=this._nodes.values();return new O(function(){var t=e.next();if(t.done)return t;t=t.value;return{value:[t.key,t.attributes],done:!1}})},r$jscomp$1.exportNode=function(e){e=""+e;var t=this._nodes.get(e);if(!t)throw new M('Graph.exportNode: could not find the "'.concat(e,
'" node in the graph.'));return ze(e,t)},r$jscomp$1.exportEdge=function(e){e=""+e;var t=this._edges.get(e);if(!t)throw new M('Graph.exportEdge: could not find the "'.concat(e,'" edge in the graph.'));return Me(e,t)},r$jscomp$1.export=function(){var e$jscomp$0=Array(this._nodes.size),t=0;this._nodes.forEach(function(n,r){e$jscomp$0[t++]=ze(r,n)});var n$jscomp$0=Array(this._edges.size);return t=0,this._edges.forEach(function(e,r){n$jscomp$0[t++]=Me(r,e)}),{attributes:this.getAttributes(),nodes:e$jscomp$0,
edges:n$jscomp$0,options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops}}},r$jscomp$1.importNode=function(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n;if(n=h$jscomp$0(e)?"key"in e?!("attributes"in e)||h$jscomp$0(e.attributes)&&null!==e.attributes?null:"invalid-attributes":"no-key":"not-object"){if("not-object"===n)throw new z('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if("no-key"===
n)throw new z("Graph.importNode: no key provided.");if("invalid-attributes"===n)throw new z("Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.");}n=e.key;var i=e.attributes;i=void 0===i?{}:i;return t?this.mergeNode(n,i):this.addNode(n,i),this},r$jscomp$1.importEdge=function(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n;if(n=h$jscomp$0(e)?"source"in e?"target"in e?!("attributes"in e)||h$jscomp$0(e.attributes)&&null!==e.attributes?"undirected"in
e&&"boolean"!=typeof e.undirected?"invalid-undirected":null:"invalid-attributes":"no-target":"no-source":"not-object"){if("not-object"===n)throw new z('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a "source" \x26 "target" property.');if("no-source"===n)throw new z("Graph.importEdge: missing souce.");if("no-target"===n)throw new z("Graph.importEdge: missing target.");if("invalid-attributes"===n)throw new z("Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.");
if("invalid-undirected"===n)throw new z("Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.");}n=e.source;var i=e.target,o=e.attributes;o=void 0===o?{}:o;var u=e.undirected;u=void 0!==u&&u;return"key"in e?(t?u?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:u?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,e.key,n,i,o):(t?u?this.mergeUndirectedEdge:this.mergeDirectedEdge:u?this.addUndirectedEdge:this.addDirectedEdge).call(this,n,i,o),
this},r$jscomp$1.import=function(e){var n,r,i=1<arguments.length&&void 0!==arguments[1]&&arguments[1];if(null!==e&&"object"===e$jscomp$3(e)&&"function"==typeof e.addUndirectedEdgeWithKey&&"function"==typeof e.dropNode)return this.import(e.export(),i),this;if(!h$jscomp$0(e))throw new z("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!h$jscomp$0(e.attributes))throw new z("Graph.import: invalid attributes. Expecting a plain object.");
i?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}if(e.nodes){if(r=e.nodes,!Array.isArray(r))throw new z("Graph.import: invalid nodes. Expecting an array.");var t=0;for(n=r.length;t<n;t++)this.importNode(r[t],i)}if(e.edges){if(r=e.edges,!Array.isArray(r))throw new z("Graph.import: invalid edges. Expecting an array.");t=0;for(n=r.length;t<n;t++)this.importEdge(r[t],i)}return this},r$jscomp$1.nullCopy=function(e){return new n$jscomp$1(d$jscomp$1({},this._options,e))},r$jscomp$1.emptyCopy=
function(e$jscomp$0){var t=this.nullCopy(e$jscomp$0);return this._nodes.forEach(function(e,n){e=d$jscomp$1({},e.attributes);e=new t.NodeDataClass(n,e);t._nodes.set(n,e)}),t},r$jscomp$1.copy=function(){var e=new n$jscomp$1(this._options);return e.import(this),e},r$jscomp$1.upgradeToMixed=function(){return"mixed"===this.type||(this._nodes.forEach(function(e){return e.upgradeToMixed()}),this._options.type="mixed",g$jscomp$0(this,"type",this._options.type),p$jscomp$0(this,"NodeDataClass",T)),this},r$jscomp$1.upgradeToMulti=
function(){return this.multi||(this._options.multi=!0,g$jscomp$0(this,"multi",!0),(e=this)._nodes.forEach(function(t,n){if(t.out)for(var r in t.out){var i=new Set;i.add(t.out[r]);t.out[r]=i;e._nodes.get(r).in[n]=i}if(t.undirected)for(var o in t.undirected)o>n||(r=new Set,r.add(t.undirected[o]),t.undirected[o]=r,e._nodes.get(o).undirected[n]=r)})),this;var e},r$jscomp$1.clearIndex=function(){return this._nodes.forEach(function(e){void 0!==e.in&&(e.in={},e.out={});void 0!==e.undirected&&(e.undirected=
{})}),this},r$jscomp$1.toJSON=function(){return this.export()},r$jscomp$1.toString=function(){return"[object Graph]"},r$jscomp$1.inspect=function(){var e$jscomp$0=this,t$jscomp$0={};this._nodes.forEach(function(e,n){t$jscomp$0[n]=e.attributes});var n$jscomp$0={},r={};this._edges.forEach(function(t,i){var o=t.undirected?"--":"-\x3e",a="";o="(".concat(t.source.key,")").concat(o,"(").concat(t.target.key,")");t.generatedKey?e$jscomp$0.multi&&(void 0===r[o]?r[o]=0:r[o]++,a+="".concat(r[o],". ")):a+="[".concat(i,
"]: ");n$jscomp$0[a+=o]=t.attributes});var i$jscomp$0={},o$jscomp$0;for(o$jscomp$0 in this)this.hasOwnProperty(o$jscomp$0)&&!Fe.has(o$jscomp$0)&&"function"!=typeof this[o$jscomp$0]&&(i$jscomp$0[o$jscomp$0]=this[o$jscomp$0]);return i$jscomp$0.attributes=this._attributes,i$jscomp$0.nodes=t$jscomp$0,i$jscomp$0.edges=n$jscomp$0,p$jscomp$0(i$jscomp$0,"constructor",this.constructor),i$jscomp$0},n$jscomp$1}(JSCompiler_object_inline_exports_4508.EventEmitter);"undefined"!=typeof Symbol&&(Je.prototype[Symbol.for("nodejs.util.inspect.custom")]=
Je.prototype.inspect);[{name:function(e){return"".concat(e,"Edge")},generateKey:!0},{name:function(e){return"".concat(e,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function(e){return"".concat(e,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function(e){return"".concat(e,"EdgeWithKey")}},{name:function(e){return"".concat(e,"DirectedEdgeWithKey")},type:"directed"},{name:function(e){return"".concat(e,"UndirectedEdgeWithKey")},type:"undirected"}].forEach(function(e){["add","merge",
"update"].forEach(function(t){var n=e.name(t),r="add"===t?Ye:Be;e.generateKey?Je.prototype[n]=function(i,o,a){return r(this,n,!0,"undirected"===(e.type||this.type),null,i,o,a,"update"===t)}:Je.prototype[n]=function(i,o,a,u){return r(this,n,!1,"undirected"===(e.type||this.type),i,o,a,u,"update"===t)}})});"undefined"!=typeof Symbol&&(Je.prototype[Symbol.iterator]=Je.prototype.adjacency);(function(e){B.forEach(function(t){var n=t.name;t=t.attacher;t(e,n("Edge"),"mixed");t(e,n("DirectedEdge"),"directed");
t(e,n("UndirectedEdge"),"undirected")})})(Je);(function(e$jscomp$1){H.forEach(function(t$jscomp$1){!function(e$jscomp$0,t$jscomp$0){var n=t$jscomp$0.name,r$jscomp$0=t$jscomp$0.type,i=t$jscomp$0.direction;e$jscomp$0.prototype[n]=function(e,t){if("mixed"!==r$jscomp$0&&"mixed"!==this.type&&r$jscomp$0!==this.type)return[];if(!arguments.length){if(0===this.size)var JSCompiler_inline_result=[];else if("mixed"===r$jscomp$0||r$jscomp$0===this.type)JSCompiler_inline_result="function"==typeof Array.from?Array.from(this._edges.keys()):
C(this._edges.keys(),this._edges.size);else{for(var r,o=Array("undirected"===r$jscomp$0?this.undirectedSize:this.directedSize),a="undirected"===r$jscomp$0,u=this._edges.values(),d=0;!0!==(JSCompiler_inline_result=u.next()).done;)(r=JSCompiler_inline_result.value).undirected===a&&(o[d++]=r.key);JSCompiler_inline_result=o}return JSCompiler_inline_result}if(1===arguments.length){e=""+e;JSCompiler_inline_result=this._nodes.get(e);if(void 0===JSCompiler_inline_result)throw new M("Graph.".concat(n,': could not find the "').concat(e,
'" node in the graph.'));r="mixed"===r$jscomp$0?this.type:r$jscomp$0;o=[];a=this.multi?V:Q;return"undirected"!==r&&("out"!==i&&a(o,JSCompiler_inline_result.in),"in"!==i&&a(o,JSCompiler_inline_result.out),!i&&0<JSCompiler_inline_result.directedSelfLoops&&o.splice(o.lastIndexOf(JSCompiler_inline_result.key),1)),"directed"!==r&&a(o,JSCompiler_inline_result.undirected),o}if(2===arguments.length){e=""+e;t=""+t;JSCompiler_inline_result=this._nodes.get(e);if(!JSCompiler_inline_result)throw new M("Graph.".concat(n,
':  could not find the "').concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new M("Graph.".concat(n,':  could not find the "').concat(t,'" target node in the graph.'));r=t;o=this.multi?re:ne;a=[];return"undirected"!==r$jscomp$0&&(void 0!==JSCompiler_inline_result.in&&"out"!==i&&o(a,JSCompiler_inline_result.in,r),void 0!==JSCompiler_inline_result.out&&"in"!==i&&o(a,JSCompiler_inline_result.out,r),!i&&0<JSCompiler_inline_result.directedSelfLoops&&a.splice(a.lastIndexOf(JSCompiler_inline_result.key),
1)),"directed"!==r$jscomp$0&&void 0!==JSCompiler_inline_result.undirected&&o(a,JSCompiler_inline_result.undirected,r),a}throw new z("Graph.".concat(n,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."));}}(e$jscomp$1,t$jscomp$1);(function(e$jscomp$0,t$jscomp$0){var n$jscomp$1=t$jscomp$0.name,r$jscomp$0=t$jscomp$0.type,i$jscomp$0=t$jscomp$0.direction,o$jscomp$0="forEach"+n$jscomp$1[0].toUpperCase()+n$jscomp$1.slice(1,-1);e$jscomp$0.prototype[o$jscomp$0]=function(e,t,
n$jscomp$0){if("mixed"===r$jscomp$0||"mixed"===this.type||r$jscomp$0===this.type)if(1===arguments.length){var n=n$jscomp$0=e;if(0!==this.size)for(var r,i,o="mixed"!==r$jscomp$0&&r$jscomp$0!==this.type,a="undirected"===r$jscomp$0,u=this._edges.values();!0!==(r=u.next()).done;)if(i=r.value,!o||i.undirected===a){r=i;var h=r.source,f=r.target;n(r.key,r.attributes,h.key,f.key,h.attributes,f.attributes,i.undirected,i.generatedKey)}}else if(2===arguments.length){e=""+e;n$jscomp$0=t;n=this._nodes.get(e);
if(void 0===n)throw new M("Graph.".concat(o$jscomp$0,': could not find the "').concat(e,'" node in the graph.'));i="mixed"===r$jscomp$0?this.type:r$jscomp$0;o=n$jscomp$0;a=this.multi?Z:X;"undirected"!==i&&("out"!==i$jscomp$0&&a(n.in,o),"in"!==i$jscomp$0&&a(n.out,o,i$jscomp$0?null:n.key));"directed"!==i&&a(n.undirected,o)}else if(3===arguments.length){e=""+e;t=""+t;n=this._nodes.get(e);if(!n)throw new M("Graph.".concat(o$jscomp$0,':  could not find the "').concat(e,'" source node in the graph.'));
if(!this._nodes.has(t))throw new M("Graph.".concat(o$jscomp$0,':  could not find the "').concat(t,'" target node in the graph.'));i=t;o=n$jscomp$0;a=this.multi?oe:ie;"undirected"!==r$jscomp$0&&(void 0!==n.in&&"out"!==i$jscomp$0&&a(n.in,i,o),n.key!==i&&void 0!==n.out&&"in"!==i$jscomp$0&&a(n.out,i,o));"directed"!==r$jscomp$0&&void 0!==n.undirected&&a(n.undirected,i,o)}else throw new z("Graph.".concat(o$jscomp$0,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."));}})(e$jscomp$1,
t$jscomp$1);(function(e$jscomp$0,t$jscomp$0){var n$jscomp$1=t$jscomp$0.name,r$jscomp$0=t$jscomp$0.type,i$jscomp$0=t$jscomp$0.direction,o$jscomp$0="forEach"+n$jscomp$1[0].toUpperCase()+n$jscomp$1.slice(1,-1)+"Until";e$jscomp$0.prototype[o$jscomp$0]=function(e,t,n$jscomp$0){if("mixed"===r$jscomp$0||"mixed"===this.type||r$jscomp$0===this.type)if(1===arguments.length){var n=n$jscomp$0=e;if(0!==this.size)for(var r,i,o="mixed"!==r$jscomp$0&&r$jscomp$0!==this.type,a="undirected"===r$jscomp$0,u=this._edges.values();!0!==
(r=u.next()).done;)if(i=r.value,!o||i.undirected===a){r=i;var h=r.source,f=r.target;if(n(r.key,r.attributes,h.key,f.key,h.attributes,f.attributes,i.undirected,i.generatedKey))break}}else{if(2===arguments.length){e=""+e;n$jscomp$0=t;n=this._nodes.get(e);if(void 0===n)throw new M("Graph.".concat(o$jscomp$0,': could not find the "').concat(e,'" node in the graph.'));a:{i="mixed"===r$jscomp$0?this.type:r$jscomp$0;o=n$jscomp$0;a=this.multi?ee:$;if("undirected"!==i){if("out"!==i$jscomp$0&&a(n.in,o)){n=
void 0;break a}if("in"!==i$jscomp$0&&a(n.out,o,i$jscomp$0?null:n.key)){n=void 0;break a}}"directed"===i||a(n.undirected,o);n=void 0}return n}if(3===arguments.length){e=""+e;t=""+t;n=this._nodes.get(e);if(!n)throw new M("Graph.".concat(o$jscomp$0,':  could not find the "').concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new M("Graph.".concat(o$jscomp$0,':  could not find the "').concat(t,'" target node in the graph.'));a:{i=t;o=n$jscomp$0;a=this.multi?ue:ae;if("undirected"!==
r$jscomp$0){if(void 0!==n.in&&"out"!==i$jscomp$0&&a(n.in,i,o)){n=void 0;break a}if(n.key!==i&&void 0!==n.out&&"in"!==i$jscomp$0&&a(n.out,i,o,i$jscomp$0?null:n.key)){n=void 0;break a}}"directed"===r$jscomp$0||void 0===n.undirected||a(n.undirected,i,o);n=void 0}return n}throw new z("Graph.".concat(o$jscomp$0,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."));}}})(e$jscomp$1,t$jscomp$1);(function(e$jscomp$0,t$jscomp$0){var r$jscomp$0=t$jscomp$0.type,i$jscomp$0=t$jscomp$0.direction,
o=t$jscomp$0.name.slice(0,-1)+"Entries";e$jscomp$0.prototype[o]=function(e,t){if("mixed"!==r$jscomp$0&&"mixed"!==this.type&&r$jscomp$0!==this.type)return O.empty();if(!arguments.length)return fe(this,r$jscomp$0);if(1===arguments.length){e=""+e;var n=this._nodes.get(e);if(!n)throw new M("Graph.".concat(o,': could not find the "').concat(e,'" node in the graph.'));var r=O.empty();return"undirected"!==r$jscomp$0&&("out"!==i$jscomp$0&&void 0!==n.in&&(r=q(r,te(n.in))),"in"!==i$jscomp$0&&void 0!==n.out&&
(r=q(r,te(n.out,i$jscomp$0?null:n.key)))),"directed"!==r$jscomp$0&&void 0!==n.undirected&&(r=q(r,te(n.undirected))),r}if(2===arguments.length){e=""+e;t=""+t;n=this._nodes.get(e);if(!n)throw new M("Graph.".concat(o,':  could not find the "').concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new M("Graph.".concat(o,':  could not find the "').concat(t,'" target node in the graph.'));r=t;var i=O.empty();return"undirected"!==r$jscomp$0&&(void 0!==n.in&&"out"!==i$jscomp$0&&r in n.in&&
(i=q(i,de(n.in,r))),void 0!==n.out&&"in"!==i$jscomp$0&&r in n.out&&(i=q(i,de(n.out,r)))),"directed"!==r$jscomp$0&&void 0!==n.undirected&&r in n.undirected&&(i=q(i,de(n.undirected,r))),i}throw new z("Graph.".concat(o,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."));}})(e$jscomp$1,t$jscomp$1)})})(Je);(function(e$jscomp$1){_e.forEach(function(t$jscomp$1){!function(e$jscomp$0,t$jscomp$0){var n=t$jscomp$0.name,r=t$jscomp$0.type,i=t$jscomp$0.direction;e$jscomp$0.prototype[n]=
function(e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];if(2===arguments.length){var t=""+arguments[0],o=""+arguments[1];if(!this._nodes.has(t))throw new M("Graph.".concat(n,': could not find the "').concat(t,'" node in the graph.'));if(!this._nodes.has(o))throw new M("Graph.".concat(n,': could not find the "').concat(o,'" node in the graph.'));a:{t=this._nodes.get(t);if("undirected"!==r){if("out"!==i&&void 0!==t.in)for(var a in t.in)if(a===o){o=!0;break a}if("in"!==i&&void 0!==t.out)for(var u in t.out)if(u===
o){o=!0;break a}}if("directed"!==r&&void 0!==t.undirected)for(var d in t.undirected)if(d===o){o=!0;break a}o=!1}return o}if(1===arguments.length){e=""+e;o=this._nodes.get(e);if(void 0===o)throw new M("Graph.".concat(n,': could not find the "').concat(e,'" node in the graph.'));a:{a="mixed"===r?this.type:r;if("mixed"!==a){if("undirected"===a){o=Object.keys(o.undirected);break a}if("string"==typeof i){o=Object.keys(o[i]);break a}}u=new Set;o=("undirected"!==a&&("out"!==i&&ke(u,o.in),"in"!==i&&ke(u,
o.out)),"directed"!==a&&ke(u,o.undirected),C(u.values(),u.size))}return o}throw new z("Graph.".concat(n,": invalid number of arguments (expecting 1 or 2 and got ").concat(arguments.length,")."));}}(e$jscomp$1,t$jscomp$1);je(e$jscomp$1,t$jscomp$1);Ue(e$jscomp$1,t$jscomp$1);Oe(e$jscomp$1,t$jscomp$1)})})(Je);JSCompiler_object_inline_exports_4508=function(e){function n(t){t=d$jscomp$1({type:"directed"},t);if("multi"in t&&!1!==t.multi)throw new z("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
if("directed"!==t.type)throw new z('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');return e.call(this,t)||this}return t$jscomp$2(n,e),n}(Je);K=function(e){function n(t){t=d$jscomp$1({type:"undirected"},t);if("multi"in t&&!1!==t.multi)throw new z("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==t.type)throw new z('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');return e.call(this,t)||
this}return t$jscomp$2(n,e),n}(Je);var Qe=function(e){function n(t){t=d$jscomp$1({multi:!0},t);if("multi"in t&&!0!==t.multi)throw new z("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return e.call(this,t)||this}return t$jscomp$2(n,e),n}(Je),Ve=function(e){function n(t){t=d$jscomp$1({type:"directed",multi:!0},t);if("multi"in t&&!0!==t.multi)throw new z("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
if("directed"!==t.type)throw new z('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');return e.call(this,t)||this}return t$jscomp$2(n,e),n}(Je),Xe=function(e){function n(t){t=d$jscomp$1({type:"undirected",multi:!0},t);if("multi"in t&&!0!==t.multi)throw new z("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==t.type)throw new z('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');
return e.call(this,t)||this}return t$jscomp$2(n,e),n}(Je);return Ze(Je),Ze(JSCompiler_object_inline_exports_4508),Ze(K),Ze(Qe),Ze(Ve),Ze(Xe),Je.Graph=Je,Je.DirectedGraph=JSCompiler_object_inline_exports_4508,Je.UndirectedGraph=K,Je.MultiGraph=Qe,Je.MultiDirectedGraph=Ve,Je.MultiUndirectedGraph=Xe,Je.InvalidArgumentsGraphError=z,Je.NotFoundGraphError=M,Je.UsageGraphError=P,Je})}
//# sourceMappingURL=module$node_modules$graphology$dist$graphology_umd_min.js.map
