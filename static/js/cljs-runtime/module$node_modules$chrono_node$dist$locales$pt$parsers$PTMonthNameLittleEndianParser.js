shadow$provide.module$node_modules$chrono_node$dist$locales$pt$parsers$PTMonthNameLittleEndianParser=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});const years_1=require("module$node_modules$chrono_node$dist$calculation$years"),constants_1=require("module$node_modules$chrono_node$dist$locales$pt$constants"),constants_2=require("module$node_modules$chrono_node$dist$locales$pt$constants");global=require("module$node_modules$chrono_node$dist$utils$pattern");
require=require("module$node_modules$chrono_node$dist$common$parsers$AbstractParserWithWordBoundary");const PATTERN=new RegExp("([0-9]{1,2})(?:º|ª|°)?(?:\\s*(?:desde|de|\\-|\\–|ao?|\\s)\\s*([0-9]{1,2})(?:º|ª|°)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)"+`(${global.matchAnyPattern(constants_1.MONTH_DICTIONARY)})`+`(?:\\s*(?:de|,)?\\s*(${constants_2.YEAR_PATTERN}))?`+"(?\x3d\\W|$)","i");class PTMonthNameLittleEndianParser extends require.AbstractParserWithWordBoundaryChecking{innerPattern(){return PATTERN}innerExtract(context,
match){const result=context.createParsingResult(match.index,match[0]),month=constants_1.MONTH_DICTIONARY[match[3].toLowerCase()],day=parseInt(match[1]);if(31<day)return match.index+=match[1].length,null;result.start.assign("month",month);result.start.assign("day",day);match[4]?(context=constants_2.parseYear(match[4]),result.start.assign("year",context)):(context=years_1.findYearClosestToRef(context.refDate,day,month),result.start.imply("year",context));match[2]&&(match=parseInt(match[2]),result.end=
result.start.clone(),result.end.assign("day",match));return result}}exports.default=PTMonthNameLittleEndianParser}
//# sourceMappingURL=module$node_modules$chrono_node$dist$locales$pt$parsers$PTMonthNameLittleEndianParser.js.map
