shadow$provide.module$node_modules$capacitor_voice_recorder$dist$plugin_cjs=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$$capacitor$core$dist$index_cjs");var getBlobDuration__default=(require=require("module$node_modules$get_blob_duration$dist$getBlobDuration"))&&"object"===typeof require&&"default"in require?require:{"default":require};require=global.registerPlugin("VoiceRecorder",{web:()=>Promise.resolve().then(function(){return web}).then(m=>
new m.VoiceRecorderWeb)});const recordingHasNotStartedError=()=>Error("RECORDING_HAS_NOT_STARTED"),possibleMimeTypes=["audio/aac","audio/webm;codecs\x3dopus","audio/mp4","audio/webm","audio/ogg;codecs\x3dopus"],neverResolvingPromise=()=>new Promise(()=>{});class VoiceRecorderImpl{constructor(){this.mediaRecorder=null;this.chunks=[];this.pendingResult=neverResolvingPromise()}static async canDeviceVoiceRecord(){var _a;return null==(null===(_a=null===navigator||void 0===navigator?void 0:navigator.mediaDevices)||
void 0===_a?void 0:_a.getUserMedia)||null==VoiceRecorderImpl.getSupportedMimeType()?{value:!1}:{value:!0}}async startRecording(){if(null!=this.mediaRecorder)throw Error("ALREADY_RECORDING");if(!(await VoiceRecorderImpl.canDeviceVoiceRecord()).value)throw Error("DEVICE_CANNOT_VOICE_RECORD");if(!(await VoiceRecorderImpl.hasAudioRecordingPermission().catch(()=>({value:!0}))).value)throw Error("MISSING_PERMISSION");navigator.mediaDevices.getUserMedia({audio:!0}).then(this.onSuccessfullyStartedRecording.bind(this)).catch(this.onFailedToStartRecording.bind(this));
return{value:!0}}async stopRecording(){if(null==this.mediaRecorder)throw recordingHasNotStartedError();try{return this.mediaRecorder.stop(),this.pendingResult}catch(ignore){throw Error("FAILED_TO_FETCH_RECORDING");}finally{this.prepareInstanceForNextOperation()}}static async hasAudioRecordingPermission(){return navigator.permissions.query({name:"microphone"}).then(result=>({value:"granted"===result.state})).catch(()=>{throw Error("COULD_NOT_QUERY_PERMISSION_STATUS");})}static async requestAudioRecordingPermission(){return(await VoiceRecorderImpl.hasAudioRecordingPermission().catch(()=>
({value:!1}))).value?{value:!0}:navigator.mediaDevices.getUserMedia({audio:!0}).then(()=>({value:!0})).catch(()=>({value:!1}))}pauseRecording(){if(null==this.mediaRecorder)throw recordingHasNotStartedError();return"recording"===this.mediaRecorder.state?(this.mediaRecorder.pause(),Promise.resolve({value:!0})):Promise.resolve({value:!1})}resumeRecording(){if(null==this.mediaRecorder)throw recordingHasNotStartedError();return"paused"===this.mediaRecorder.state?(this.mediaRecorder.resume(),Promise.resolve({value:!0})):
Promise.resolve({value:!1})}getCurrentStatus(){return null==this.mediaRecorder?Promise.resolve({status:"NONE"}):"recording"===this.mediaRecorder.state?Promise.resolve({status:"RECORDING"}):"paused"===this.mediaRecorder.state?Promise.resolve({status:"PAUSED"}):Promise.resolve({status:"NONE"})}static getSupportedMimeType(){if(null==(null===MediaRecorder||void 0===MediaRecorder?void 0:MediaRecorder.isTypeSupported))return null;const foundSupportedType=possibleMimeTypes.find(type=>MediaRecorder.isTypeSupported(type));
return null!==foundSupportedType&&void 0!==foundSupportedType?foundSupportedType:null}onSuccessfullyStartedRecording(stream){this.pendingResult=new Promise((resolve,reject)=>{this.mediaRecorder=new MediaRecorder(stream);this.mediaRecorder.onerror=()=>{reject(Error("FAILED_TO_RECORD"));this.prepareInstanceForNextOperation()};this.mediaRecorder.onstop=async()=>{const mimeType=VoiceRecorderImpl.getSupportedMimeType();if(null==mimeType)reject(Error("FAILED_TO_FETCH_RECORDING"));else{var blobVoiceRecording=
new Blob(this.chunks,{type:mimeType});const recordDataBase64=await VoiceRecorderImpl.blobToBase64(blobVoiceRecording);blobVoiceRecording=await getBlobDuration__default["default"](blobVoiceRecording);this.prepareInstanceForNextOperation();resolve({value:{recordDataBase64,mimeType,msDuration:1E3*blobVoiceRecording}})}};this.mediaRecorder.ondataavailable=event=>this.chunks.push(event.data);this.mediaRecorder.start()})}onFailedToStartRecording(){this.prepareInstanceForNextOperation();throw Error("FAILED_TO_RECORD");
}static blobToBase64(blob){return new Promise(resolve=>{const reader=new FileReader;reader.onloadend=()=>resolve(String(reader.result));reader.readAsDataURL(blob)})}prepareInstanceForNextOperation(){if(null!=this.mediaRecorder&&"recording"===this.mediaRecorder.state)try{this.mediaRecorder.stop()}catch(ignore){}this.pendingResult=neverResolvingPromise();this.mediaRecorder=null;this.chunks=[]}}class VoiceRecorderWeb extends global.WebPlugin{constructor(){super(...arguments);this.voiceRecorderInstance=
new VoiceRecorderImpl}canDeviceVoiceRecord(){return VoiceRecorderImpl.canDeviceVoiceRecord()}hasAudioRecordingPermission(){return VoiceRecorderImpl.hasAudioRecordingPermission()}requestAudioRecordingPermission(){return VoiceRecorderImpl.requestAudioRecordingPermission()}startRecording(){return this.voiceRecorderInstance.startRecording()}stopRecording(){return this.voiceRecorderInstance.stopRecording()}pauseRecording(){return this.voiceRecorderInstance.pauseRecording()}resumeRecording(){return this.voiceRecorderInstance.resumeRecording()}getCurrentStatus(){return this.voiceRecorderInstance.getCurrentStatus()}}
var web=Object.freeze({__proto__:null,VoiceRecorderWeb});exports.VoiceRecorder=require}
//# sourceMappingURL=module$node_modules$capacitor_voice_recorder$dist$plugin_cjs.js.map
