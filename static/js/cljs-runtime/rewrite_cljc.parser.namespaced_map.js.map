{"version":3,"sources":["rewrite_cljc/parser/namespaced_map.cljc"],"mappings":";AAOA,8DAAA,9DAAOA,oIACJC;AADH,AAEE,IAAAC,WAAM,AAACE,yBAAYH;AAAnB,AAAA,GAAA,AAAAE,6CAAA,KAAAD;AACM,4IAAA,rIAACG,4EAAeJ;;AADtB,GAAA,AAAAE,6CAAA,IAAAD;AAEM,AAAI,AAACI,2BAAcL;;AAAnB;;AAFN,AAAA;;;;;AAKF,6DAAA,7DAAOM,kIACJN;AADH,AAEE,IAAMO,IAAE,AAACJ,yBAAYH;AAArB,AACE,SAAK,AAACQ,cAAI,AAACC,sCAAmBF,SACzB,GAAK,6CAAA,7CAACL,iDAAKK;;AAEpB,mDAAA,nDAAOG,8GACJV,OAAOW,UAAUC;AADpB,AAEE,IAAMC,IAAE,CAACF,0CAAAA,kDAAAA,VAAUX,8BAAAA;AAAnB,AACE,GACE,MAAA,LAAMa;AACN,4IAAA,rIAACT,4EAAeJ;;AAFlB,GAIE,gDAAA,hDAACc,wGAAY,AAACC,sBAASF;AACvB,oBAAID;AACF,4IAAA,rIAACR,4EAAeJ;;AAChB,4IAAA,rIAACI,4EAAeJ;;;AAPpB,AAQQ,OAACgB,2DAAgB,AAACC,gDAAQ,CAAK,kCAAA,AAAA,IAAA,pBAAML,sEAAc,AAACM,yBAAYL;;;;;AAE5E,0DAAA,1DAAOM,4HACJnB,OAAOW;AADV,AAEE,SAAA,LAAOS;;AAAP,AACE,GAAI,EACC,AAACC,cAAID,SACL,AAACZ,cAAI,AAACc,wCAAqB,AAACC,eAAKH;AACpCA;;AACA,IAAAI,qBAAW,CAACb,0CAAAA,kDAAAA,VAAUX,8BAAAA;AAAtB,AAAA,oBAAAwB;AAAA,QAAAA,JAASC;AAAT,AACE,eAAO,AAACC,6CAAKN,GAAGK;;;;AADlB;;;;;;AAIN,mDAAA,nDAAOE,8GACJ3B,OAAOW;AADV,AAEE,IAAMiB,IAAE,AAACT,wDAAqBnB,OAAOW;AAArC,AACE,GACE,MAAA,LAAMiB;AACN,4IAAA,rIAACxB,4EAAeJ;;AAFlB,GAIE,gDAAA,hDAACc,mGAAU,AAACC,sBAAS,AAACQ,eAAKK;AAC3B,4IAAA,rIAACxB,4EAAeJ;;AALlB,AAMQ4B;;;;;AAEZ,0DAAA,1DAAMC,4HACH7B,OAAOW;AADV,AAEE,AAACN,2BAAcL;;AACf,IAAMY,iBAAS,AAACb,4DAAmBC;AAAnC,AACE,GAAI,AAACM,2DAAkBN;AACrB,OAAC8B,sCACA,6CAAA,7CAACC,gIAAM,AAACrB,iDAAcV,OAAOW,UAAUC,wBACjC,AAACe,iDAAc3B,OAAOW;;AAC7B,GAAIC;AACF,OAACkB,sCACA,6CAAA,7CAACC,gIAAM,AAACf,2DAAgB,gDAAA,hDAACC,8DACnB,AAACU,iDAAc3B,OAAOW;;AAC7B,4IAAA,rIAACP,4EAAeJ","names":["rewrite-cljc.parser.namespaced-map/specifies-aliased?","reader","G__78567","cljs.core._EQ_","rewrite-cljc.reader/peek","rewrite_cljc.parser.utils.throw_reader","rewrite-cljc.reader/ignore","rewrite-cljc.parser.namespaced-map/includes-keyword?","c","cljs.core/not","rewrite-cljc.reader/whitespace?","rewrite-cljc.parser.namespaced-map/parse-keyword","read-next","aliased?","k","cljs.core.not_EQ_","rewrite-cljc.node/tag","rewrite_cljc.node.token_node","cljs.core.keyword","rewrite-cljc.node/string","rewrite-cljc.parser.namespaced-map/parse-upto-printable","vs","cljs.core/seq","rewrite-cljc.node/printable-only?","cljs.core/last","temp__5718__auto__","v","cljs.core.conj","rewrite-cljc.parser.namespaced-map/parse-for-map","m","rewrite-cljc.parser.namespaced-map/parse-namespaced-map","rewrite-cljc.node/namespaced-map-node","cljs.core.into"],"sourcesContent":["(ns ^:no-doc rewrite-cljc.parser.namespaced-map\n  (:require [rewrite-cljc.node :as node]\n            [rewrite-cljc.parser.utils :as u]\n            [rewrite-cljc.reader :as reader] ))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn- specifies-aliased?\n  [reader]\n  (case (reader/peek reader)\n    nil (u/throw-reader reader \"Unexpected EOF.\")\n    \\:  (do (reader/ignore reader) true)\n    false))\n\n(defn- includes-keyword?\n  [reader]\n  (let [c (reader/peek reader)]\n    (and (not (reader/whitespace? c))\n         (not (= \\{ c)))))\n\n(defn- parse-keyword\n  [reader read-next aliased?]\n  (let [k (read-next reader)]\n    (cond\n      (nil? k)\n      (u/throw-reader reader \"Unexpected EOF.\")\n\n      (not= :token (node/tag k))\n      (if aliased?\n        (u/throw-reader reader \":namespaced-map expected namespace alias or map\")\n        (u/throw-reader reader \":namespaced-map expected namespace prefix\"))\n      :else (node/token-node (keyword (str (when aliased? \":\") (node/string k)))))))\n\n(defn- parse-upto-printable\n  [reader read-next]\n  (loop [vs []]\n    (if (and\n         (seq vs)\n         (not (node/printable-only? (last vs))))\n      vs\n      (if-let [v (read-next reader)]\n        (recur (conj vs v))\n        nil))))\n\n(defn- parse-for-map\n  [reader read-next]\n  (let [m (parse-upto-printable reader read-next)]\n    (cond\n      (nil? m)\n      (u/throw-reader reader \"Unexpected EOF.\")\n\n      (not= :map (node/tag (last m)))\n      (u/throw-reader reader \":namespaced-map expects a map\")\n      :else m)))\n\n(defn parse-namespaced-map\n  [reader read-next]\n  (reader/ignore reader)\n  (let [aliased? (specifies-aliased? reader)]\n    (if (includes-keyword? reader)\n      (node/namespaced-map-node\n       (into [(parse-keyword reader read-next aliased?)]\n             (parse-for-map reader read-next)))\n      (if aliased?\n        (node/namespaced-map-node\n         (into [(node/token-node (keyword \":\"))]\n               (parse-for-map reader read-next)))\n        (u/throw-reader reader \":namespaced-map expected namespace prefix\")))))\n"]}