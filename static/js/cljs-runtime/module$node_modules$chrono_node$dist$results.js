shadow$provide.module$node_modules$chrono_node$dist$results=function(global,require,module,exports){global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.ParsingResult=exports.ParsingComponents=void 0;module=global(require("module$node_modules$dayjs$plugin$quarterOfYear"));const dayjs_1=global(require("module$node_modules$dayjs$dayjs_min")),dayjs_2=require("module$node_modules$chrono_node$dist$utils$dayjs");
dayjs_1.default.extend(module.default);class ParsingComponents{constructor(refDate,knownComponents){this.knownValues={};this.impliedValues={};if(knownComponents)for(const key in knownComponents)this.knownValues[key]=knownComponents[key];refDate=dayjs_1.default(refDate);this.imply("day",refDate.date());this.imply("month",refDate.month()+1);this.imply("year",refDate.year());this.imply("hour",12);this.imply("minute",0);this.imply("second",0);this.imply("millisecond",0)}get(component){return component in
this.knownValues?this.knownValues[component]:component in this.impliedValues?this.impliedValues[component]:null}date(){return this.dayjs().toDate()}isCertain(component){return component in this.knownValues}getCertainComponents(){return Object.keys(this.knownValues)}imply(component,value){if(component in this.knownValues)return this;this.impliedValues[component]=value;return this}assign(component,value){this.knownValues[component]=value;delete this.impliedValues[component];return this}delete(component){delete this.knownValues[component];
delete this.impliedValues[component]}clone(){const component=new ParsingComponents(new Date);component.knownValues={};component.impliedValues={};for(const key in this.knownValues)component.knownValues[key]=this.knownValues[key];for(const key in this.impliedValues)component.impliedValues[key]=this.impliedValues[key];return component}isOnlyDate(){return!this.isCertain("hour")&&!this.isCertain("minute")&&!this.isCertain("second")}isOnlyTime(){return!this.isCertain("weekday")&&!this.isCertain("day")&&
!this.isCertain("month")}isOnlyWeekdayComponent(){return this.isCertain("weekday")&&!this.isCertain("day")&&!this.isCertain("month")}isOnlyDayMonthComponent(){return this.isCertain("day")&&this.isCertain("month")&&!this.isCertain("year")}isValidDate(){let dateMoment=this.dayjs();if(this.isCertain("timezoneOffset")){const adjustTimezoneOffset=this.get("timezoneOffset")-dateMoment.utcOffset();dateMoment=dateMoment.add(adjustTimezoneOffset,"minute")}return dateMoment.get("year")!=this.get("year")||dateMoment.get("month")!=
this.get("month")-1||dateMoment.get("date")!=this.get("day")||null!=this.get("hour")&&dateMoment.get("hour")!=this.get("hour")||null!=this.get("minute")&&dateMoment.get("minute")!=this.get("minute")?!1:!0}dayjs(){let result=dayjs_1.default();result=result.year(this.get("year"));result=result.month(this.get("month")-1);result=result.date(this.get("day"));result=result.hour(this.get("hour"));result=result.minute(this.get("minute"));result=result.second(this.get("second"));result=result.millisecond(this.get("millisecond"));
const currentTimezoneOffset=result.utcOffset(),targetTimezoneOffset=null!==this.get("timezoneOffset")?this.get("timezoneOffset"):currentTimezoneOffset;return result=result.add(-(targetTimezoneOffset-currentTimezoneOffset),"minute")}toString(){return`[ParsingComponents {knownValues: ${JSON.stringify(this.knownValues)}, impliedValues: ${JSON.stringify(this.impliedValues)}}]`}static createRelativeFromRefDate(refDate,fragments){let date=dayjs_1.default(refDate);for(const key in fragments)date=date.add(fragments[key],
key);refDate=new ParsingComponents(refDate);fragments.hour||fragments.minute||fragments.second?(dayjs_2.assignSimilarTime(refDate,date),dayjs_2.assignSimilarDate(refDate,date)):(dayjs_2.implySimilarTime(refDate,date),fragments.d?(refDate.assign("day",date.date()),refDate.assign("month",date.month()+1),refDate.assign("year",date.year())):(fragments.week&&refDate.imply("weekday",date.day()),refDate.imply("day",date.date()),fragments.month?(refDate.assign("month",date.month()+1),refDate.assign("year",
date.year())):(refDate.imply("month",date.month()+1),fragments.year?refDate.assign("year",date.year()):refDate.imply("year",date.year()))));return refDate}}exports.ParsingComponents=ParsingComponents;class ParsingResult{constructor(refDate,index,text,start,end){this.refDate=refDate;this.index=index;this.text=text;this.start=start||new ParsingComponents(this.refDate);this.end=end}clone(){const result=new ParsingResult(this.refDate,this.index,this.text);result.start=this.start?this.start.clone():null;
result.end=this.end?this.end.clone():null;return result}date(){return this.start.date()}toString(){return`[ParsingResult {index: ${this.index}, text: '${this.text}', ...}]`}}exports.ParsingResult=ParsingResult}
//# sourceMappingURL=module$node_modules$chrono_node$dist$results.js.map
