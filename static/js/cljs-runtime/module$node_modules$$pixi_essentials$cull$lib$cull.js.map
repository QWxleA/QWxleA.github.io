{
"version":3,
"file":"module$node_modules$$pixi_essentials$cull$lib$cull.js",
"lineCount":5,
"mappings":"AAAAA,cAAA,CAAA,kDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAc/GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAIA,OAAMC,SAAW,KAFNN,OAAAO,CAAQ,8CAARA,CAEeC,CAAAA,SAAT,CAsBjB,MAAMC,KAAN,CAYIC,WAAW,CAACC,OAAA,CAAU,EAAX,CACX,CACI,IAAKC,CAAAA,UAAL,CAA+C,SAA7B,GAAA,MAAOD,QAAQE,CAAAA,SAAf,CAAyCF,OAAQE,CAAAA,SAAjD,CAA6D,CAAA,CAC/E,KAAKC,CAAAA,OAAL,CAAeH,OAAQI,CAAAA,MAAvB,EAAiC,SACjC,KAAKC,CAAAA,WAAL,CAAmB,IAAIC,GAH3B,CAYAC,GAAG,CAACC,MAAD,CACH,CACI,IAAKH,CAAAA,WAAYE,CAAAA,GAAjB,CAAqBC,MAArB,CAEA,OAAO,KAHX,CAYAC,MAAM,CAACC,OAAD,CACN,CACI,IAAK,IAAIC,EAAI,CAAR;AAAWC,EAAIF,OAAQG,CAAAA,MAA5B,CAAoCF,CAApC,CAAwCC,CAAxC,CAA2CD,CAAA,EAA3C,CAEI,IAAKN,CAAAA,WAAYE,CAAAA,GAAjB,CAAqBG,OAAA,CAAQC,CAAR,CAArB,CAGJ,OAAO,KANX,CAeAG,MAAM,CAACN,MAAD,CACN,CACI,IAAKH,CAAAA,WAAYU,CAAAA,MAAjB,CAAwBP,MAAxB,CAEA,OAAO,KAHX,CAYAQ,SAAS,CAACN,OAAD,CACT,CACI,IAAK,IAAIC,EAAI,CAAR,CAAWC,EAAIF,OAAQG,CAAAA,MAA5B,CAAoCF,CAApC,CAAwCC,CAAxC,CAA2CD,CAAA,EAA3C,CAEI,IAAKN,CAAAA,WAAYU,CAAAA,MAAjB,CAAwBL,OAAA,CAAQC,CAAR,CAAxB,CAGJ,OAAO,KANX,CAcAM,KAAK,EACL,CACI,IAAKZ,CAAAA,WAAYY,CAAAA,KAAjB,EAEA,OAAO,KAHX,CAaAC,IAAI,CAACC,IAAD,CAAOC,UAAA,CAAa,CAAA,CAApB,CACJ,CACSA,UAAL,EAEI,IAAKC,CAAAA,MAAL,EAGJ,KAAKhB,CAAAA,WAAYiB,CAAAA,OAAjB,CAA0Bd,MAAD,EACzB,CACSY,UAAL,EAGIZ,MAAOe,CAAAA,SAAP,CAAiB,CAAA,CAAjB,CAAwB5B,QAAxB,CAGA,KAAKM,CAAAA,UAAT,CAEI,IAAKuB,CAAAA,aAAL,CAAmBL,IAAnB,CAAyBX,MAAzB,CAAiCY,UAAjC,CAFJ,EAOQA,UAKJ,EAHIZ,MAAOiB,CAAAA,OAAQC,CAAAA,YAAf,CAA4BP,IAA5B,CAGJ;AAAAX,MAAA,CAAO,IAAKL,CAAAA,OAAZ,CAAA,CAAuBR,QAASgC,CAAAA,KAAhC,CAAwCR,IAAKS,CAAAA,IAA7C,EACOjC,QAASiC,CAAAA,IADhB,CACuBT,IAAKQ,CAAAA,KAD5B,EAEOhC,QAASkC,CAAAA,MAFhB,CAEyBV,IAAKW,CAAAA,GAF9B,EAGOnC,QAASmC,CAAAA,GAHhB,CAGsBX,IAAKU,CAAAA,MAf/B,CAPJ,CADA,CA2BA,OAAO,KAjCX,CA4CAR,MAAM,EACN,CACI,IAAKhB,CAAAA,WAAYiB,CAAAA,OAAjB,CAA0Bd,MAAD,EACzB,CACQ,IAAKP,CAAAA,UAAT,CAEI,IAAK8B,CAAAA,eAAL,CAAqBvB,MAArB,CAFJ,CAMIA,MAAA,CAAO,IAAKL,CAAAA,OAAZ,CANJ,CAM2B,CAAA,CAP/B,CADA,CAYA,OAAO,KAbX,CAuBCqB,aAAa,CAACL,IAAD,CAAOa,aAAP,CAAsBZ,UAAtB,CACd,CAEUa,UAAAA,CAASb,UAAA,CACTY,aAAcP,CAAAA,OAAQC,CAAAA,YAAtB,CAAmC/B,QAAnC,CADS,CAETqC,aAAcT,CAAAA,SAAd,CAAwB,CAAA,CAAxB,CAA8B5B,QAA9B,CAENqC,cAAA,CAAc,IAAK7B,CAAAA,OAAnB,CAAA,CAA8B8B,UAAON,CAAAA,KAArC,CAA6CR,IAAKS,CAAAA,IAAlD,EACOK,UAAOL,CAAAA,IADd,CACqBT,IAAKQ,CAAAA,KAD1B,EAEOM,UAAOJ,CAAAA,MAFd;AAEuBV,IAAKW,CAAAA,GAF5B,EAGOG,UAAOH,CAAAA,GAHd,CAGoBX,IAAKU,CAAAA,MAWzB,IAAI,EATiBI,UAAOL,CAAAA,IASxB,EATgCT,IAAKS,CAAAA,IASrC,EARGK,UAAOH,CAAAA,GAQV,EARiBX,IAAKW,CAAAA,GAQtB,EAPGG,UAAON,CAAAA,KAOV,EAPmBR,IAAKQ,CAAAA,KAOxB,EANGM,UAAOJ,CAAAA,MAMV,EANoBV,IAAKU,CAAAA,MAMzB,CAAJ,EACWG,aAAA,CAAc,IAAK7B,CAAAA,OAAnB,CADX,EAEY6B,aAAgBE,CAAAA,QAF5B,EAGYF,aAAgBE,CAAAA,QAASrB,CAAAA,MAHrC,CAIA,CACUqB,aAAAA,CAAYF,aAAgBE,CAAAA,QAElC,KAAK,IAAIvB,EAAI,CAAR,CAAWC,EAAIsB,aAASrB,CAAAA,MAA7B,CAAqCF,CAArC,CAAyCC,CAAzC,CAA4CD,CAAA,EAA5C,CAEI,IAAKa,CAAAA,aAAL,CAAmBL,IAAnB,CAAyBe,aAAA,CAASvB,CAAT,CAAzB,CALR,CAxBJ,CAuCCoB,eAAe,CAACC,aAAD,CAChB,CACIA,aAAA,CAAc,IAAK7B,CAAAA,OAAnB,CAAA,CAA8B,CAAA,CAE9B,IAAK6B,aAAgBE,CAAAA,QAArB,EAAkCF,aAAgBE,CAAAA,QAASrB,CAAAA,MAA3D,CACA,CACUqB,aAAAA,CAAYF,aAAgBE,CAAAA,QAElC;IAAK,IAAIvB,EAAI,CAAR,CAAWC,EAAIsB,aAASrB,CAAAA,MAA7B,CAAqCF,CAArC,CAAyCC,CAAzC,CAA4CD,CAAA,EAA5C,CAEI,IAAKoB,CAAAA,eAAL,CAAqBG,aAAA,CAASvB,CAAT,CAArB,CALR,CAJJ,CA9MJ,CA6NApB,OAAQO,CAAAA,IAAR,CAAeA,IArQgG;",
"sources":["node_modules/@pixi-essentials/cull/lib/cull.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$pixi_essentials$cull$lib$cull\"] = function(global,require,module,exports) {\n/* eslint-disable */\n \n/*!\n * @pixi-essentials/cull - v1.0.12\n * Compiled Wed, 17 Mar 2021 16:10:19 UTC\n *\n * @pixi-essentials/cull is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Shukant Pal <shukantpal@outlook.com>, All Rights Reserved\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar math = require('@pixi/math');\n\nconst tempRect = new math.Rectangle();\n\n/**\n * The culling options for {@code Cull}.\n *\n * @ignore\n * @public\n */\n\n\n\n\n\n\n/**\n * Provides a simple, configurable mechanism for culling a subtree of your scene graph.\n *\n * If your scene graph is not static, culling needs to be done before rendering. You\n * can run it on the `prerender` event fired by the renderer.\n *\n * @public\n */\nclass Cull\n{\n    \n    \n    \n\n    /**\n     * @param options\n     * @param [options.recursive] - whether culling should be recursive\n     * @param [options.toggle='renderable'] - which property of display-object was be set to indicate\n     *      its culling state. It should be one of `renderable`, `visible`.\n     */\n    constructor(options = {})\n    {\n        this._recursive = typeof options.recursive === 'boolean' ? options.recursive : true;\n        this._toggle = options.toggle || 'visible';\n        this._targetList = new Set();\n    }\n\n    /**\n     * Adds a display-object to the culling list\n     *\n     * @param target - the display-object to be culled\n     * @return this\n     */\n    add(target)\n    {\n        this._targetList.add(target);\n\n        return this;\n    }\n\n    /**\n     * Adds all the display-objects to the culling list\n     *\n     * @param targets - the display-objects to be culled\n     * @return this\n     */\n    addAll(targets)\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.add(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the culling list\n     *\n     * @param target - the display-object to be removed\n     * @return this\n     */\n    remove(target)\n    {\n        this._targetList.delete(target);\n\n        return this;\n    }\n\n    /**\n     * Removes all the passed display-objects from the culling list\n     *\n     * @param targets - the display-objects to be removed\n     * @return this\n     */\n    removeAll(targets)\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.delete(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the culling list\n     *\n     * @return this\n     */\n    clear()\n    {\n        this._targetList.clear();\n\n        return this;\n    }\n\n    /**\n     * @param rect - the rectangle outside of which display-objects should be culled\n     * @param skipUpdate - whether to skip unculling, transform update, bounds calculation. It is\n     *  highly recommended you enable this by calling _this.uncull()_ and _root.getBounds(false)_ manually\n     *  before your render loop.\n     * @return this\n     */\n    cull(rect, skipUpdate = false)\n    {\n        if (!skipUpdate)\n        {\n            this.uncull();\n        }\n\n        this._targetList.forEach((target) =>\n        {\n            if (!skipUpdate)\n            {\n                // Update transforms, bounds of display-objects in this target's subtree\n                target.getBounds(false, tempRect);\n            }\n\n            if (this._recursive)\n            {\n                this.cullRecursive(rect, target, skipUpdate);\n            }\n            else\n            {\n                // NOTE: If skipUpdate is false, then tempRect already contains the bounds of the target\n                if (skipUpdate)\n                {\n                    target._bounds.getRectangle(rect);\n                }\n\n                target[this._toggle] = tempRect.right > rect.left\n                    && tempRect.left < rect.right\n                    && tempRect.bottom > rect.top\n                    && tempRect.top < rect.bottom;\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets all display-objects to the unculled state.\n     *\n     * This happens regardless of whether the culling toggle was set by {@code this.cull} or manually. This\n     * is why it is recommended to one of `visible` or `renderable` for normal use and the other for culling.\n     *\n     * @return this\n     */\n    uncull()\n    {\n        this._targetList.forEach((target) =>\n        {\n            if (this._recursive)\n            {\n                this.uncullRecursive(target);\n            }\n            else\n            {\n                target[this._toggle] = false;\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Recursively culls the subtree of {@code displayObject}.\n     *\n     * @param rect - the visiblity rectangle\n     * @param displayObject - the root of the subtree to cull\n     * @param skipUpdate - whether to skip bounds calculation. However, transforms are expected to be updated by the caller.\n     */\n     cullRecursive(rect, displayObject, skipUpdate)\n    {\n        // NOTE: getBounds can skipUpdate because updateTransform is invoked before culling.\n        const bounds = skipUpdate\n            ? displayObject._bounds.getRectangle(tempRect)\n            : displayObject.getBounds(true, tempRect);\n\n        displayObject[this._toggle] = bounds.right > rect.left\n            && bounds.left < rect.right\n            && bounds.bottom > rect.top\n            && bounds.top < rect.bottom;\n\n        const fullyVisible = bounds.left >= rect.left\n            && bounds.top >= rect.top\n            && bounds.right <= rect.right\n            && bounds.bottom <= rect.bottom;\n\n        // Only cull children if this display-object is *not* fully-visible. It is expected that the bounds\n        // of children lie inside of its own. Hence, further culling is only required if the display-object\n        // intersects with the boundaries of \"rect\". Otherwise, if the object is fully outside/inside the\n        // screen, the children don't need to be evaluated as they are presumed to be unculled.\n        if (!fullyVisible\n                && displayObject[this._toggle]\n                && (displayObject ).children\n                && (displayObject ).children.length)\n        {\n            const children = (displayObject ).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.cullRecursive(rect, children[i]);\n            }\n        }\n    }\n\n    /**\n     * Recursively unculls the subtree of {@code displayObject}.\n     *\n     * @param displayObject\n     */\n     uncullRecursive(displayObject)\n    {\n        displayObject[this._toggle] = true;\n\n        if ((displayObject ).children && (displayObject ).children.length)\n        {\n            const children = (displayObject ).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.uncullRecursive(children[i]);\n            }\n        }\n    }\n}\n\nexports.Cull = Cull;\n//# sourceMappingURL=cull.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","tempRect","math","Rectangle","Cull","constructor","options","_recursive","recursive","_toggle","toggle","_targetList","Set","add","target","addAll","targets","i","j","length","remove","delete","removeAll","clear","cull","rect","skipUpdate","uncull","forEach","getBounds","cullRecursive","_bounds","getRectangle","right","left","bottom","top","uncullRecursive","displayObject","bounds","children"]
}
