{"version":3,"sources":["frontend/util/datalog.cljc"],"mappings":";AAGA;;;;;4CAAA,5CAAMA,gGAIHC,MAAMC;AAJT,qEAQO,+CAAA,WAAAG,1DAACC,rEACD,OAACI,4CAAIC;AADL,AAAS,SAAK,CAAAN,4BAAAE,uBAAY,AAACC,0BAAUN,YAAY,gDAAAG,hDAACI;sEAHlDR,lBACAE,jDACAC,AACA,iDAAA;;AAGP;;;;;0CAAA,1CAAMQ,4FAIHC;AAJH,AAKE,IAAOC,SAkiFF,AAAAyB;UAliFL,NAA0BxB;IAAQC,KAAGH;;AAArC,AACE,IAAAI,qBAAW,AAACE,gBAAMH;AAAlB,AAAA,oBAAAC;AAAA,QAAAA,JAASC;AAAT,AACE,GAAI,cAAAE,bAAUF;AACZ,eAAOJ;eAAOI;eAAE,AAACG,eAAKL;;;;;;AACtB,eAAO,yDAAA,zDAACM,kDAAUR,0FAAQC,YAAK,4DAAA,5DAACQ,6CAAKC,iDAASN;eAAGH;eAAI,AAACM,eAAKL;;;;;;;AAC7DF;;;;;AAEN;;;oDAAA,pDAAMW,gHAEHZ,UAAUa,SAASC;AAFtB,AAGE,IAAMC,YAAU,AAAChB,wCAAeC;AAAhC,AACE,OAACgB,cACA,AAACC,+CAAO,eAAAC,JAAKG;AAAL,AAAA,IAAAF,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAAUG;QAAV,AAAAF,4CAAAD,WAAA,IAAA,/DAAYI;AAAZ,AACE,iEAAA,1DAACC,sDAAOH,uFAAKC,4DAAGC,EAAE,4DAAA,MAAA,hEAAM,AAACE,6CAAEH,EAAET,WAAUC;GADjD,AAAA,qBAGQC","names":["frontend.util.datalog/find-rules-in-where","where","valid-rules","cljs.core/flatten","cljs.core.distinct","p1__86942#","cljs.core.filter","cljs.core/Symbol","cljs.core/contains?","cljs.core.keyword","cljs.core.map","cljs.core/keyword","frontend.util.datalog/query-vec->map","query-vec","parsed","key","qs","temp__5718__auto__","q","cljs.core/first","cljs.core/Keyword","cljs.core/next","cljs.core.update_in","cljs.core.fnil","cljs.core/conj","frontend.util.datalog/add-to-end-of-query-section","query-kw","elems","query-map","cljs.core/vec","cljs.core.reduce","p__86943","vec__86944","cljs.core.nth","acc","k","v","cljs.core.concat","cljs.core._EQ_","cljs.core/PersistentArrayMap"],"sourcesContent":["(ns frontend.util.datalog\n  \"Utility fns related to datalog queries and rules\")\n\n(defn find-rules-in-where\n  \"Given where clauses and a set of valid rules, returns rules found in where\n  clause as keywords. A more advanced version of this would use a datalog parser\nand not require valid-rules\"\n  [where valid-rules]\n  (->> where\n       flatten\n       distinct\n       (filter #(and (symbol? %) (contains? valid-rules (keyword %))))\n       (map keyword)))\n\n(defn query-vec->map\n  \"Converts query vec to query map. Modified version of\n  datascript.parser/query->map which preserves insertion order in case map is\n  converted back to vec\"\n  [query-vec]\n  (loop [parsed (array-map) key nil qs query-vec]\n    (if-let [q (first qs)]\n      (if (keyword? q)\n        (recur parsed q (next qs))\n        (recur (update-in parsed [key] (fnil conj []) q) key (next qs)))\n      parsed)))\n\n(defn add-to-end-of-query-section\n  \"Adds vec of elements to end of a query section e.g. :find or :in\"\n  [query-vec query-kw elems]\n  (let [query-map (query-vec->map query-vec)]\n    (vec\n     (reduce (fn [acc [k v]]\n               (concat acc [k] v (when (= k query-kw) elems)))\n             '()\n             query-map))))\n"]}