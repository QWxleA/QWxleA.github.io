{"version":3,"sources":["borkdude/rewrite_edn.cljc"],"mappings":";AAOA;;;oCAAA,pCAAMA,gFAEHC;AAFH,AAGE,OAACC,qCAAmBD;;AAEtB;;;6BAAA,7BAAME,kEAEHC;AAFH,AAGE,OAACC,wBAAWD;;AAEd;;;;6BAAA,7BAAME,kEAGFF,KAAKG,EAAEC;AAHX,AAIG,OAACC,gCAAWL,KAAKG,EAAEC;;AAEtB;;;gCAAA,hCAAME,wEAEHN,KAAKO,GAAGH;AAFX,AAGE,OAACI,mCAAcR,KAAKO,GAAGH;;AAEzB;;;;8BAAA,9BAAMK,oEAGHT,KAAKG,EAAEO;AAHV,AAIE,OAACC,iCAAYX,KAAKG,EAAEO;;AAEtB;;;;iCAAA,jCAAME,0EAGHZ,KAAKO,GAAGG;AAHX,AAIE,OAACG,oCAAeb,KAAKO,GAAGG;;AAE1B;;;;gCAAA,hCAAMI,wEAGHJ,EAAEV;AAHL,AAIE,OAACe,mCAAcL,EAAEV","names":["borkdude.rewrite-edn/parse-string","s","rewrite-cljc.parser/parse-string-all","borkdude.rewrite-edn/sexpr","node","rewrite-cljc.node/sexpr","borkdude.rewrite-edn/assoc","k","v","borkdude.rewrite-edn.impl/assoc","borkdude.rewrite-edn/assoc-in","ks","borkdude.rewrite-edn.impl/assoc-in","borkdude.rewrite-edn/update","f","borkdude.rewrite-edn.impl/update","borkdude.rewrite-edn/update-in","borkdude.rewrite-edn.impl/update-in","borkdude.rewrite-edn/map-keys","borkdude.rewrite-edn.impl/map-keys"],"sourcesContent":["(ns borkdude.rewrite-edn\n  (:refer-clojure :exclude [assoc assoc-in update update-in])\n  (:require [borkdude.rewrite-edn.impl :as impl]\n            [clojure.core :as c]\n            [rewrite-cljc.node :as node]\n            [rewrite-cljc.parser :as p]))\n\n(defn parse-string\n  \"Same as rewrite-cljc.parser/parse-string-all\"\n  [s]\n  (p/parse-string-all s))\n\n(defn sexpr\n  \"Same as rewrite-cljc.node/sexpr\"\n  [node]\n  (node/sexpr node))\n\n(defn assoc\n  \"Associates k to v in node (which may be a forms node as returned by parse-string or map node).\n  Both k and v are coerced into nodes.\"\n  ([node k v]\n   (impl/assoc node k v)))\n\n(defn assoc-in\n  \"Associates value under keys ks in map node with v.\"\n  [node ks v]\n  (impl/assoc-in node ks v))\n\n(defn update\n  \"Updates value under key k in map node. Function f receives\n  node. Return value is coerced into node.\"\n  [node k f]\n  (impl/update node k f))\n\n(defn update-in\n  \"Updates value under keys ks in map node. Function f receives\n  node. Return value is coerced into node.\"\n  [node ks f]\n  (impl/update-in node ks f))\n\n(defn map-keys\n  \"Maps f over keys of node (which may be a forms node as returned by\n  parse-string or map node).\"\n  [f node]\n  (impl/map-keys f node))\n"]}