{
"version":3,
"file":"module$node_modules$codemirror$mode$verilog$verilog.js",
"lineCount":21,
"mappings":"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",
"sources":["node_modules/codemirror/mode/verilog/verilog.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$codemirror$mode$verilog$verilog\"] = function(global,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"verilog\", function(config, parserConfig) {\n\n  var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n    \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n    \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n    \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n    \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n    \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n    \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n    \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n    \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n    \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n    \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n    \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n    \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n    \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n    \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n    \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n    \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n    \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n     unary_operator ::=\n       + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_operator ::=\n       + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n       | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n       | -> | <->\n     inc_or_dec_operator ::= ++ | --\n     unary_module_path_operator ::=\n       ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_module_path_operator ::=\n       == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n    \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n\n    // Regex to force current line to reindent\n    electricInput: buildElectricInputRegEx(),\n\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if ((curPunc == \";\" && ctx.type == \"statement\") ||\n               (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n      else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;\n      else return ctx.indented + (closing ? 0 : indentUnit);\n    },\n\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\",\n    fold: \"indent\"\n  };\n});\n\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  });\n\n\n\n  // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",  // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",  // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  };\n\n  // Lines starting with these characters define scope (result in indentation).\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifiere.\n  // Note that ':' is excluded, because of it's use in [:].\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/;\n\n\n  // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit;  // TODO: Pass this in instead.\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  }\n\n  // Return true if the next thing in the stream is an identifier with a mnemonic.\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n\n    hooks: {\n\n      electricInput: false,\n\n\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function(stream, state) {\n        var style = undefined;\n        var match;  // Return value of pattern matches.\n\n        // Set highlighting mode based on code region (TLV or SV).\n        if (stream.sol() && ! state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)){\n              state.tlvCodeActive = true;\n            }\n          }\n          // Correct indentation in the face of a line prefix char.\n          if (state.tlvCodeActive && stream.pos == 0 &&\n              (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          }\n\n          // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n              if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                  tlvIdentifierStyle[match[1]])) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit;\n                // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                  if (tlvTrackStatements) {state.statementComment = false;}\n                  depth++;\n                }\n              }\n            }\n            // Clear out deeper indentation levels unless line is blank.\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          }\n          // Set next level of indentation.\n          state.tlvNextIndent = indented;\n        }\n\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n\n          var beginStatement = false;\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement =\n                   (stream.peek() != \" \") &&   // not a space\n                   (style === undefined) &&    // not a region identifier\n                   !state.tlvInBlockComment && // not in block comment\n                   //!stream.match(tlvCommentMatch, false) && // not comment start\n                   (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n              state.statementComment =\n                   stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n\n          var match;\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\")\n          } else if (((stream.pos / tlvIndentUnit) < state.tlvIndentationStyle.length) &&\n                     (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style = // make this style distinct from the previous one to prevent\n                    // codemirror from combining spans\n                    \"tlv-indent-\" + (((stream.pos % 2) == 0) ? \"even\" : \"odd\") +\n                    // and style it\n                    \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\");\n            // Style the line prefix character.\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            }\n            // Place a class before a scope identifier.\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n            if (// is identifier prefix\n                tlvIdentifierStyle.hasOwnProperty(prefix) &&\n                // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n                (mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\")\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = (match[1] == \"+\") ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)){\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n        return style;\n      },\n\n      indent: function(state) {\n        return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n      },\n\n      startState: function(state) {\n        state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n        state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n        state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n        state.tlvInBlockComment = false;  // True inside /**/ comment.\n        if (tlvTrackStatements) {\n          state.statementComment = false;  // True inside a statement's header comment.\n        }\n      }\n\n    }\n  });\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","mod","define","amd","CodeMirror","tlvScopeStyle","state","indentation","type","tlvIndentationStyle","tlvIndentUnit","defineMode","config","parserConfig","words","str","obj","split","i","length","tokenBase","stream","ch","peek","style","hooks","test","curPunc","next","isBracketChar","eatWhile","tokenize","tokenString","eat","tokenComment","skipToEnd","backUp","match","realLiteral","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","unsignedNumber","isOperatorChar","cur","current","keywords","openClose","statementKeywords","curKeyword","quote","escaped","end","multiLineStrings","maybeEnd","Context","indented","column","align","prev","pushContext","col","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","indentUnit","statementIndentUnit","dontAlignCalls","noIndentKeywords","closingBracketOrWord","closingBracket","blockKeywords","keyword","undefined","electricInput","buildElectricInputRegEx","allClosings","closings","j","push","re","RegExp","join","startState","basecolumn","startOfLine","token","ctx","sol","eatSpace","close","indent","textAfter","Pass","fromHook","firstChar","charAt","closing","possibleClosing","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME","name","tlvIdentifierStyle","tlvScopePrefixChars","tlvIdentMatch","tlvFirstLevelIndentMatch","tlvLineIndentationMatch","tlvCommentMatch","tlvInBlockComment","string","tlvCodeActive","pos","depth","blankline","chPos","bodyString","slice","pop","tlvNextIndent","prefix","mnemonic","hasOwnProperty","eol"]
}
