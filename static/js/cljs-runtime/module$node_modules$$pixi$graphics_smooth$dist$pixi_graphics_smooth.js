shadow$provide.module$node_modules$$pixi$graphics_smooth$dist$pixi_graphics_smooth=function(global,require,module,exports){function matrixEquals(th,matrix,eps=.001){return this===matrix||Math.abs(th.a-matrix.a)<eps&&Math.abs(th.b-matrix.b)<eps&&Math.abs(th.c-matrix.c)<eps&&Math.abs(th.d-matrix.d)<eps&&Math.abs(th.tx-matrix.tx)<eps&&Math.abs(th.ty-matrix.ty)<eps}function quadraticBezierCurve(fromX,fromY,cpX,cpY,toX,toY,out=[]){let xb,yb;for(let i=0,j=0;20>=i;++i){j=i/20;var xa=fromX+(cpX-fromX)*j;
var ya=fromY+(cpY-fromY)*j;xb=cpX+(toX-cpX)*j;yb=cpY+(toY-cpY)*j;xa+=(xb-xa)*j;ya+=(yb-ya)*j;out.push(xa,ya)}return out}Object.defineProperty(exports,"__esModule",{value:!0});var math=require("module$node_modules$$pixi$math$dist$cjs$math"),core=require("module$node_modules$$pixi$core$dist$cjs$core"),constants=require("module$node_modules$$pixi$constants$dist$cjs$constants"),graphics=require("module$node_modules$$pixi$graphics$dist$cjs$graphics"),utils=require("module$node_modules$$pixi$utils$dist$cjs$utils"),
display=require("module$node_modules$$pixi$display$dist$cjs$display");class BatchStyleArray{constructor(){this.textureIds=[];this.matrices=[];this.lines=[];this.count=0}clear(){for(let i=0;i<this.count;i++)this.textureIds[i]=null,this.matrices[i]=null;this.count=0}add(textureId,matrix,lineWidth,lineAlignment,settings){const {textureIds,matrices,lines,count}=this;for(let i=0;i<count;i++)if(lines[2*i]===lineWidth&&lines[2*i+1]===lineAlignment&&textureIds[i]===textureId&&matrixEquals(matrices[i],matrix))return i;
if(count>=settings.maxStyles)return-1;textureIds[count]=textureId;matrices[count]=matrix;lines[2*count]=lineWidth;lines[2*count+1]=lineAlignment;this.count++;return count}}class BatchDrawCall{constructor(){this.texArray=new core.BatchTextureArray;this.styleArray=new BatchStyleArray;this.shader=null;this.blend=constants.BLEND_MODES.NORMAL;this.TICK=this.size=this.start=0;this.data=this.settings=null}clear(){this.texArray.clear();this.styleArray.clear();this.shader=this.data=this.settings=null}begin(settings,
shader){this.TICK=++core.BaseTexture._globalBatch;this.settings=settings;this.shader=shader;this.size=this.start=0;this.data=null;shader&&shader.settings&&(this.settings=shader.settings)}check(shader){return 0===this.size?(this.shader=shader,!0):this.shader===shader}add(texture,matrix,lineWidth,lineAlignment){const {texArray,TICK,styleArray,settings}=this;({baseTexture:texture}=texture);if(texture._batchEnabled!==TICK&&texArray.count===settings.maxTextures)return-1;matrix=styleArray.add(texture._batchEnabled!==
TICK?texArray.count:texture._batchLocation,matrix||math.Matrix.IDENTITY,lineWidth,lineAlignment,settings);0<=matrix&&texture._batchEnabled!==TICK&&(texture._batchEnabled=TICK,texture._batchLocation=texArray.count,texArray.elements[texArray.count++]=texture);return matrix}}class BatchPart{constructor(){this.reset()}begin(style,startIndex,attribStart){this.reset();this.style=style;this.start=startIndex;this.attribStart=attribStart;this.jointEnd=0}end(endIndex,endAttrib){this.attribSize=endAttrib-this.attribStart;
this.size=endIndex-this.start}reset(){this.style=null;this.attribSize=this.attribStart=this.start=this.size=0;this.styleId=-1;this.jointEnd=this.rgba=0}}class FillStyle{constructor(){this.reset()}toJSON(){return this.copyTo({})}clone(){return this.copyTo(new FillStyle)}copyTo(obj){obj.color=this.color;obj.alpha=this.alpha;obj.texture=this.texture;obj.matrix=this.matrix;obj.shader=this.shader;obj.visible=this.visible;obj.smooth=this.smooth;obj.matrixTex=null;return obj}packLineWidth(){return 0}reset(){this.color=
16777215;this.alpha=1;this.texture=core.Texture.WHITE;this.shader=this.matrix=null;this.smooth=this.visible=!1;this.matrixTex=null}destroy(){this.matrixTex=this.matrix=this.texture=null}getTextureMatrix(){const tex=this.texture;if(!this.matrix)return null;if(tex.frame.width===tex.baseTexture.width&&tex.frame.height===tex.baseTexture.height)return this.matrix;this.matrixTex?this.matrixTex.copyFrom(this.matrix):this.matrixTex=this.matrix.clone();this.matrixTex.translate(Number(tex.frame.x),Number(tex.frame.y));
return this.matrixTex}}exports.LINE_SCALE_MODE=void 0;(function(LINE_SCALE_MODE){LINE_SCALE_MODE.NONE="none";LINE_SCALE_MODE.NORMAL="normal"})(exports.LINE_SCALE_MODE||(exports.LINE_SCALE_MODE={}));class LineStyle extends FillStyle{clone(){return this.copyTo(new LineStyle)}copyTo(obj){obj.color=this.color;obj.alpha=this.alpha;obj.texture=this.texture;obj.matrix=this.matrix;obj.shader=this.shader;obj.visible=this.visible;obj.width=this.width;obj.alignment=this.alignment;obj.cap=this.cap;obj.join=this.join;
obj.miterLimit=this.miterLimit;obj.scaleMode=this.scaleMode;return obj}packLineWidth(){return this.scaleMode===exports.LINE_SCALE_MODE.NORMAL?this.width:-this.width}reset(){super.reset();this.smooth=!0;this.width=this.color=0;this.alignment=.5;this.cap=graphics.LINE_CAP.BUTT;this.join=graphics.LINE_JOIN.MITER;this.miterLimit=10;this.scaleMode=exports.LINE_SCALE_MODE.NORMAL}}class BuildData{constructor(){BuildData.prototype.__init.call(this);BuildData.prototype.__init2.call(this);BuildData.prototype.__init3.call(this);
BuildData.prototype.__init4.call(this);BuildData.prototype.__init5.call(this)}__init(){this.verts=[]}__init2(){this.joints=[]}__init3(){this.vertexSize=0}__init4(){this.indexSize=0}__init5(){this.closePointEps=1E-4}clear(){this.verts.length=0;this.indexSize=this.vertexSize=this.joints.length=0}destroy(){this.verts.length=0;this.joints.length=0}}exports.JOINT_TYPE=void 0;(function(JOINT_TYPE){JOINT_TYPE[JOINT_TYPE.NONE=0]="NONE";JOINT_TYPE[JOINT_TYPE.FILL=1]="FILL";JOINT_TYPE[JOINT_TYPE.JOINT_BEVEL=
4]="JOINT_BEVEL";JOINT_TYPE[JOINT_TYPE.JOINT_MITER=8]="JOINT_MITER";JOINT_TYPE[JOINT_TYPE.JOINT_ROUND=12]="JOINT_ROUND";JOINT_TYPE[JOINT_TYPE.JOINT_CAP_BUTT=16]="JOINT_CAP_BUTT";JOINT_TYPE[JOINT_TYPE.JOINT_CAP_SQUARE=18]="JOINT_CAP_SQUARE";JOINT_TYPE[JOINT_TYPE.JOINT_CAP_ROUND=20]="JOINT_CAP_ROUND";JOINT_TYPE[JOINT_TYPE.FILL_EXPAND=24]="FILL_EXPAND";JOINT_TYPE[JOINT_TYPE.CAP_BUTT=32]="CAP_BUTT";JOINT_TYPE[JOINT_TYPE.CAP_SQUARE=64]="CAP_SQUARE";JOINT_TYPE[JOINT_TYPE.CAP_ROUND=96]="CAP_ROUND";JOINT_TYPE[JOINT_TYPE.CAP_BUTT2=
128]="CAP_BUTT2"})(exports.JOINT_TYPE||(exports.JOINT_TYPE={}));class SegmentPacker{constructor(){SegmentPacker.prototype.__init.call(this);SegmentPacker.prototype.__init2.call(this);SegmentPacker.prototype.__init3.call(this)}static __initStatic(){this.vertsByJoint=[]}__init(){this.strideFloats=12}updateBufferSize(jointStart,jointLen,triangles,target){const {joints}=target;let foundTriangle=!1,vertexSize=0,indexSize=0;for(let i=jointStart;i<jointStart+jointLen;i++){var prevCap=joints[i]&-32;const joint=
joints[i]&31;joint===exports.JOINT_TYPE.FILL?(foundTriangle=!0,vertexSize++):joint>=exports.JOINT_TYPE.FILL_EXPAND?(vertexSize+=3,indexSize+=3):(prevCap=SegmentPacker.vertsByJoint[joint]+SegmentPacker.vertsByJoint[prevCap],4<=prevCap&&(vertexSize+=prevCap,indexSize+=6+3*Math.max(prevCap-6,0)))}foundTriangle&&(indexSize+=triangles);target.vertexSize+=vertexSize;target.indexSize+=indexSize}__init2(){this.bufferPos=0}__init3(){this.indexPos=0}beginPack(buildData,bufFloat,bufUint,indices,bufferPos=0,
indexPos=0){this.buildData=buildData;this.bufFloat=bufFloat;this.bufUint=bufUint;this.indices=indices;this.bufferPos=bufferPos;this.indexPos=indexPos}endPack(){this.indices=this.bufUint=this.bufFloat=this.buildData=null}packInterleavedGeometry(jointStart,jointLen,triangles,lineStyle,color){const {bufFloat,bufUint,indices,buildData,strideFloats}=this,{joints,verts}=buildData;let bufPos=this.bufferPos,indPos=this.indexPos,index=this.bufferPos/this.strideFloats;let y1,x2,y2,prevX,prevY;let nextY,hasTriangle=
!1,travel=0;for(let j=jointStart;j<jointStart+jointLen;j++){var fullJoint=joints[j];var x1=joints[j]&-32;var nextX=joints[j]&31;if(nextX===exports.JOINT_TYPE.FILL)hasTriangle=!0,x1=verts[2*j],y1=verts[2*j+1],bufFloat[bufPos]=x1,bufFloat[bufPos+1]=y1,bufFloat[bufPos+2]=x1,bufFloat[bufPos+3]=y1,bufFloat[bufPos+4]=x1,bufFloat[bufPos+5]=y1,bufFloat[bufPos+6]=x1,bufFloat[bufPos+7]=y1,bufFloat[bufPos+8]=travel,bufFloat[bufPos+9]=16*nextX,bufFloat[bufPos+10]=lineStyle,bufUint[bufPos+11]=color,bufPos+=strideFloats;
else if(nextX>=exports.JOINT_TYPE.FILL_EXPAND){prevX=verts[2*j];prevY=verts[2*j+1];x1=verts[2*j+2];y1=verts[2*j+3];x2=verts[2*j+4];y2=verts[2*j+5];var bis=j+3;for(var i$jscomp$0=0;3>i$jscomp$0;i$jscomp$0++)bufFloat[bufPos]=prevX,bufFloat[bufPos+1]=prevY,bufFloat[bufPos+2]=x1,bufFloat[bufPos+3]=y1,bufFloat[bufPos+4]=x2,bufFloat[bufPos+5]=y2,bufFloat[bufPos+6]=verts[2*(bis+i$jscomp$0)],bufFloat[bufPos+7]=verts[2*(bis+i$jscomp$0)+1],bufFloat[bufPos+8]=travel,bufFloat[bufPos+9]=16*fullJoint+i$jscomp$0,
bufFloat[bufPos+10]=lineStyle,bufUint[bufPos+11]=color,bufPos+=strideFloats;indices[indPos]=index;indices[indPos+1]=index+1;indices[indPos+2]=index+2;indPos+=3;index+=3}else if(bis=SegmentPacker.vertsByJoint[nextX]+SegmentPacker.vertsByJoint[x1],0!==bis){x1=verts[2*j];y1=verts[2*j+1];x2=verts[2*j+2];y2=verts[2*j+3];prevX=verts[2*j-2];prevY=verts[2*j-1];i$jscomp$0=Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));0===SegmentPacker.vertsByJoint[nextX]&&(travel-=i$jscomp$0);(nextX&-3)!==exports.JOINT_TYPE.JOINT_CAP_BUTT?
(nextX=verts[2*j+4],nextY=verts[2*j+5]):(nextX=x1,nextY=y1);for(let i=0;i<bis;i++)bufFloat[bufPos]=prevX,bufFloat[bufPos+1]=prevY,bufFloat[bufPos+2]=x1,bufFloat[bufPos+3]=y1,bufFloat[bufPos+4]=x2,bufFloat[bufPos+5]=y2,bufFloat[bufPos+6]=nextX,bufFloat[bufPos+7]=nextY,bufFloat[bufPos+8]=travel,bufFloat[bufPos+9]=16*fullJoint+i,bufFloat[bufPos+10]=lineStyle,bufUint[bufPos+11]=color,bufPos+=strideFloats;travel+=i$jscomp$0;indices[indPos]=index;indices[indPos+1]=index+1;indices[indPos+2]=index+2;indices[indPos+
3]=index;indices[indPos+4]=index+2;indices[indPos+5]=index+3;indPos+=6;for(fullJoint=5;fullJoint+1<bis;fullJoint++)indices[indPos]=index+4,indices[indPos+1]=index+fullJoint,indices[indPos+2]=index+fullJoint+1,indPos+=3;index+=bis}}if(hasTriangle){for(jointStart=0;jointStart<triangles.length;jointStart++)indices[indPos+jointStart]=triangles[jointStart]+index;indPos+=triangles.length}this.bufferPos=bufPos;this.indexPos=indPos}}SegmentPacker.__initStatic();global=SegmentPacker.vertsByJoint;for(require=
0;256>require;require++)global.push(0);global[exports.JOINT_TYPE.FILL]=1;for(require=0;8>require;require++)global[exports.JOINT_TYPE.FILL_EXPAND+require]=3;global[exports.JOINT_TYPE.JOINT_BEVEL]=7;global[exports.JOINT_TYPE.JOINT_BEVEL+1]=7;global[exports.JOINT_TYPE.JOINT_BEVEL+2]=7;global[exports.JOINT_TYPE.JOINT_BEVEL+3]=7;global[exports.JOINT_TYPE.JOINT_ROUND]=9;global[exports.JOINT_TYPE.JOINT_ROUND+1]=9;global[exports.JOINT_TYPE.JOINT_ROUND+2]=9;global[exports.JOINT_TYPE.JOINT_ROUND+3]=9;global[exports.JOINT_TYPE.JOINT_MITER]=
8;global[exports.JOINT_TYPE.JOINT_MITER+1]=8;global[exports.JOINT_TYPE.JOINT_MITER+2]=4;global[exports.JOINT_TYPE.JOINT_MITER+3]=4;global[exports.JOINT_TYPE.JOINT_CAP_BUTT]=4;global[exports.JOINT_TYPE.JOINT_CAP_BUTT+1]=4;global[exports.JOINT_TYPE.JOINT_CAP_SQUARE]=4;global[exports.JOINT_TYPE.JOINT_CAP_SQUARE+1]=4;global[exports.JOINT_TYPE.JOINT_CAP_ROUND]=8;global[exports.JOINT_TYPE.JOINT_CAP_ROUND+1]=8;global[exports.JOINT_TYPE.CAP_ROUND]=4;class SmoothGraphicsData{constructor(shape,fillStyle=null,
lineStyle=null,matrix=null){this.shape=shape;this.lineStyle=lineStyle;this.fillStyle=fillStyle;this.matrix=matrix;this.type=shape.type;this.points=[];this.holes=[];this.triangles=[];this.closeStroke=!1;this.clearBuild()}clearPath(){this.points.length=0;this.closeStroke=!0}clearBuild(){this.strokeLen=this.strokeStart=this.fillLen=this.fillStart=this.triangles.length=0;this.fillAA=!1}clone(){return new SmoothGraphicsData(this.shape,this.fillStyle,this.lineStyle,this.matrix)}capType(){let cap;switch(this.lineStyle.cap){case graphics.LINE_CAP.SQUARE:cap=
exports.JOINT_TYPE.CAP_SQUARE;break;case graphics.LINE_CAP.ROUND:cap=exports.JOINT_TYPE.CAP_ROUND;break;default:cap=exports.JOINT_TYPE.CAP_BUTT}return cap}goodJointType(){let joint;switch(this.lineStyle.join){case graphics.LINE_JOIN.BEVEL:joint=exports.JOINT_TYPE.JOINT_BEVEL;break;case graphics.LINE_JOIN.ROUND:joint=exports.JOINT_TYPE.JOINT_ROUND;break;default:joint=exports.JOINT_TYPE.JOINT_MITER+3}return joint}jointType(){let joint;switch(this.lineStyle.join){case graphics.LINE_JOIN.BEVEL:joint=
exports.JOINT_TYPE.JOINT_BEVEL;break;case graphics.LINE_JOIN.ROUND:joint=exports.JOINT_TYPE.JOINT_ROUND;break;default:joint=exports.JOINT_TYPE.JOINT_MITER}return joint}destroy(){this.shape=null;this.holes.length=0;this.holes=null;this.points.length=0;this.triangles=this.fillStyle=this.lineStyle=this.points=null}}class CircleBuilder{path(graphicsData,_target){var circleData=graphicsData.shape;_target=graphicsData.points;const x=circleData.x,y=circleData.y;if(graphicsData.type===math.SHAPES.CIRC)var height=
graphicsData=circleData.radius;else height=graphicsData.shape,graphicsData=height.width,height=height.height;if(!(0>=graphicsData||0>=height)){_target.push(x,y);circleData=Math.floor(30*Math.sqrt(circleData.radius))||Math.floor(15*Math.sqrt(graphicsData+height));circleData/=2.3;3>circleData&&(circleData=3);var seg=2*Math.PI/circleData;for(let i=0;i<circleData-.5;i++)_target.push(x+Math.sin(-seg*i)*graphicsData,y+Math.cos(-seg*i)*height)}}fill(graphicsData,target){const {verts,joints}=target,{points,
triangles}=graphicsData;target=1;if(graphicsData.fillAA){target=points[0];var cy=points[1];graphicsData=graphicsData.shape.radius;for(let i=2;i<points.length;i+=2){const cur=i,next=i+2<points.length?i+2:2;verts.push(target);verts.push(cy);verts.push(points[cur]);verts.push(points[cur+1]);verts.push(points[next]);verts.push(points[next+1]);verts.push(0);verts.push(0);verts.push((points[cur]-target)/graphicsData);verts.push((points[cur+1]-cy)/graphicsData);verts.push((points[next]-target)/graphicsData);
verts.push((points[next+1]-cy)/graphicsData);joints.push(exports.JOINT_TYPE.FILL_EXPAND+2);joints.push(exports.JOINT_TYPE.NONE);joints.push(exports.JOINT_TYPE.NONE);joints.push(exports.JOINT_TYPE.NONE);joints.push(exports.JOINT_TYPE.NONE);joints.push(exports.JOINT_TYPE.NONE)}}else{for(cy=0;cy<points.length;cy+=2)verts.push(points[cy],points[cy+1]),joints.push(exports.JOINT_TYPE.FILL),2<cy&&triangles.push(target++,0,target);triangles.push(target,0,1)}}line(graphicsData,target){const {verts,joints}=
target;({points:target}=graphicsData);graphicsData=graphicsData.goodJointType();const len=target.length;verts.push(target[len-2],target[len-1]);joints.push(exports.JOINT_TYPE.NONE);for(let i=2;i<len;i+=2)verts.push(target[i],target[i+1]),joints.push(graphicsData);verts.push(target[2],target[3]);joints.push(exports.JOINT_TYPE.NONE);verts.push(target[4],target[5]);joints.push(exports.JOINT_TYPE.NONE)}}class RectangleBuilder{path(graphicsData,_target){var rectData=graphicsData.shape;_target=rectData.x;
const y=rectData.y,width=rectData.width;rectData=rectData.height;graphicsData=graphicsData.points;graphicsData.length=0;graphicsData.push(_target,y,_target+width,y,_target+width,y+rectData,_target,y+rectData)}line(graphicsData,target){const {verts,joints}=target;({points:target}=graphicsData);graphicsData=graphicsData.goodJointType();const len=target.length;verts.push(target[len-2],target[len-1]);joints.push(exports.JOINT_TYPE.NONE);for(let i=0;i<len;i+=2)verts.push(target[i],target[i+1]),joints.push(graphicsData);
verts.push(target[0],target[1]);joints.push(exports.JOINT_TYPE.NONE);verts.push(target[2],target[3]);joints.push(exports.JOINT_TYPE.NONE)}fill(graphicsData,target){const {verts,joints}=target,{points,triangles}=graphicsData;triangles.length=0;verts.push(points[0],points[1],points[2],points[3],points[4],points[5],points[6],points[7]);joints.push(exports.JOINT_TYPE.FILL,exports.JOINT_TYPE.FILL,exports.JOINT_TYPE.FILL,exports.JOINT_TYPE.FILL);triangles.push(0,1,2,0,2,3)}}class RoundedRectangleBuilder{path(graphicsData,
_target){_target=graphicsData.shape;({points:graphicsData}=graphicsData);const x=_target.x,y=_target.y,width=_target.width,height=_target.height;_target=Math.max(0,Math.min(_target.radius,Math.min(width,height)/2));graphicsData.length=0;_target?(quadraticBezierCurve(x,y+_target,x,y,x+_target,y,graphicsData),quadraticBezierCurve(x+width-_target,y,x+width,y,x+width,y+_target,graphicsData),quadraticBezierCurve(x+width,y+height-_target,x+width,y+height,x+width-_target,y+height,graphicsData),quadraticBezierCurve(x+
_target,y+height,x,y+height,x,y+height-_target,graphicsData)):graphicsData.push(x,y,x+width,y,x+width,y+height,x,y+height)}line(graphicsData,target){const {verts,joints}=target;({points:target}=graphicsData);graphicsData=8===target.length?graphicsData.goodJointType():exports.JOINT_TYPE.JOINT_MITER+3;const len=target.length;verts.push(target[len-2],target[len-1]);joints.push(exports.JOINT_TYPE.NONE);for(let i=0;i<len;i+=2)verts.push(target[i],target[i+1]),joints.push(graphicsData);verts.push(target[0],
target[1]);joints.push(exports.JOINT_TYPE.NONE);verts.push(target[2],target[3]);joints.push(exports.JOINT_TYPE.NONE)}fill(graphicsData,target){const {verts,joints}=target;({points:target}=graphicsData);graphicsData.triangles=utils.earcut(target,null,2);for(let i=0,j=target.length;i<j;i++)verts.push(target[i],target[++i]),joints.push(exports.JOINT_TYPE.FILL)}}const tempArr=[];class PolyBuilder{path(graphicsData,buildData){var shape=graphicsData.shape;const points=graphicsData.points=shape.points.slice();
buildData=buildData.closePointEps;const eps2=buildData*buildData;if(0!==points.length){var firstPoint=new math.Point(points[0],points[1]),lastPoint=new math.Point(points[points.length-2],points[points.length-1]);graphicsData=graphicsData.closeStroke=shape.closeStroke;shape=points.length;var newLen=2;for(var i=2;i<shape;i+=2){var y1=points[i-1],y2$jscomp$0=points[i+1],flag=!0;Math.abs(points[i-2]-points[i])<buildData&&Math.abs(y1-y2$jscomp$0)<buildData&&(flag=!1);flag&&(points[newLen]=points[i],points[newLen+
1]=points[i+1],newLen+=2)}points.length=shape=newLen;newLen=2;for(i=2;i+2<shape;i+=2){y1=points[i-2];y2$jscomp$0=points[i-1];var x2=points[i];const y2=points[i+1];flag=points[i+2];let y3=points[i+3];y1-=x2;y2$jscomp$0-=y2;flag-=x2;y3-=y2;x2=!0;Math.abs(flag*y2$jscomp$0-y3*y1)<eps2&&y1*flag+y2$jscomp$0*y3<-eps2&&(x2=!1);x2&&(points[newLen]=points[i],points[newLen+1]=points[i+1],newLen+=2)}points[newLen]=points[shape-2];points[newLen+1]=points[shape-1];points.length=shape=newLen+2;!(2>=shape)&&graphicsData&&
Math.abs(firstPoint.x-lastPoint.x)<buildData&&Math.abs(firstPoint.y-lastPoint.y)<buildData&&(points.pop(),points.pop())}}line(graphicsData,buildData){const {closeStroke,points}=graphicsData,eps=buildData.closePointEps,len=points.length;if(!(2>=len)){var {verts,joints}=buildData;buildData=graphicsData.jointType();graphicsData=graphicsData.capType();var prevCap=0;if(closeStroke){var prevX=points[len-2];var prevY=points[len-1];joints.push(exports.JOINT_TYPE.NONE)}else prevX=points[2],prevY=points[3],
graphicsData===exports.JOINT_TYPE.CAP_ROUND?(verts.push(points[0],points[1]),joints.push(exports.JOINT_TYPE.NONE),joints.push(exports.JOINT_TYPE.CAP_ROUND),prevCap=0):(prevCap=graphicsData,joints.push(exports.JOINT_TYPE.NONE));verts.push(prevX,prevY);for(let i=0;i<len;i+=2){const x1=points[i],y1=points[i+1];var x2=void 0,y2=void 0;i+2<len?(x2=points[i+2],y2=points[i+3]):(x2=points[0],y2=points[1]);const dx=x2-x1,dy=y2-y1;let nextX;var nextY=void 0;let endJoint=buildData;i+2>=len?(nextX=points[2],
nextY=points[3],closeStroke||(endJoint=exports.JOINT_TYPE.NONE)):i+4>=len?(nextX=points[0],nextY=points[1],closeStroke||(graphicsData===exports.JOINT_TYPE.CAP_ROUND&&(endJoint=exports.JOINT_TYPE.JOINT_CAP_ROUND),graphicsData===exports.JOINT_TYPE.CAP_BUTT&&(endJoint=exports.JOINT_TYPE.JOINT_CAP_BUTT),graphicsData===exports.JOINT_TYPE.CAP_SQUARE&&(endJoint=exports.JOINT_TYPE.JOINT_CAP_SQUARE))):(nextX=points[i+4],nextY=points[i+5]);prevX=x1-prevX;prevY=y1-prevY;if(buildData>=exports.JOINT_TYPE.JOINT_BEVEL&&
buildData<=exports.JOINT_TYPE.JOINT_MITER){x2=nextX-x2;y2=nextY-y2;if(endJoint>=exports.JOINT_TYPE.JOINT_BEVEL&&endJoint<=exports.JOINT_TYPE.JOINT_MITER+3&&Math.abs(x2*dy-y2*dx)<eps)switch(buildData&-4){case exports.JOINT_TYPE.JOINT_ROUND:endJoint=exports.JOINT_TYPE.JOINT_CAP_ROUND;break;default:endJoint=exports.JOINT_TYPE.JOINT_CAP_BUTT}buildData===exports.JOINT_TYPE.JOINT_MITER&&(nextY=0,prevX*dx+prevY*dy>-eps&&nextY++,endJoint===exports.JOINT_TYPE.JOINT_MITER&&x2*dx+y2*dy>-eps&&(nextY+=2),endJoint+=
nextY)}0===prevCap&&Math.abs(prevX*dy-prevY*dx)<eps&&(prevCap=exports.JOINT_TYPE.CAP_BUTT2);endJoint+=prevCap;prevCap=0;verts.push(x1,y1);joints.push(endJoint);prevX=x1;prevY=y1}closeStroke?(verts.push(points[0],points[1]),joints.push(exports.JOINT_TYPE.NONE),verts.push(points[2],points[3])):verts.push(points[len-4],points[len-3]);joints.push(exports.JOINT_TYPE.NONE)}}fill(graphicsData,buildData){let points=graphicsData.points;var holes=graphicsData.holes,eps=buildData.closePointEps;const {verts,
joints}=buildData;if(!(6>points.length)){var holeArray=[];buildData=points.length;for(var i=0;i<holes.length;i++){var hole=holes[i];holeArray.push(points.length/2);points=points.concat(hole.points)}tempArr.length<points.length&&(tempArr.length=points.length);for(holes=0;holes<=holeArray.length;holes++)for(i=buildData/2,0<holes&&(i=holes<holeArray.length?holeArray[holes]:points.length>>1),tempArr[0]=i-1,tempArr[2*(i-1)+1]=0,hole=0;hole+1<i;hole++)tempArr[2*hole+1]=hole+1,tempArr[2*hole+2]=hole;graphicsData.triangles=
utils.earcut(points,holeArray,2);if(graphicsData.triangles)if(graphicsData.fillAA){({triangles:graphicsData}=graphicsData);buildData=points.length;for(holeArray=0;holeArray<graphicsData.length;holeArray+=3){holes=0;for(i=0;3>i;i++){hole=graphicsData[holeArray+i];var ind2=graphicsData[holeArray+(i+1)%3];if(tempArr[2*hole]===ind2||tempArr[2*hole+1]===ind2)holes|=1<<i}joints.push(exports.JOINT_TYPE.FILL_EXPAND+holes);joints.push(exports.JOINT_TYPE.NONE);joints.push(exports.JOINT_TYPE.NONE);joints.push(exports.JOINT_TYPE.NONE);
joints.push(exports.JOINT_TYPE.NONE);joints.push(exports.JOINT_TYPE.NONE)}for(holeArray=0;holeArray<buildData/2;holeArray++){ind2=tempArr[2*holeArray];i=tempArr[2*holeArray+1];holes=points[2*i+1]-points[2*holeArray+1];i=-(points[2*i]-points[2*holeArray]);hole=points[2*holeArray+1]-points[2*ind2+1];ind2=-(points[2*holeArray]-points[2*ind2]);var D1=Math.sqrt(holes*holes+i*i);holes/=D1;i/=D1;D1=Math.sqrt(hole*hole+ind2*ind2);hole/=D1;ind2/=D1;hole=holes+hole;ind2=i+ind2;D1=hole*holes+ind2*i;Math.abs(D1)<
eps?(hole=holes,ind2=i):(hole/=D1,ind2/=D1);tempArr[2*holeArray]=hole;tempArr[2*holeArray+1]=ind2}for(eps=0;eps<graphicsData.length;eps+=3){holeArray=graphicsData[eps];holes=graphicsData[eps+1];i=graphicsData[eps+2];buildData=1;0<(points[2*i+1]-points[2*holes+1])*-(points[2*holes]-points[2*holeArray])-(points[2*holes+1]-points[2*holeArray+1])*-(points[2*i]-points[2*holes])&&(buildData=2);for(holeArray=0;3>holeArray;holeArray++)holes=graphicsData[eps+holeArray*buildData%3],verts.push(points[2*holes],
points[2*holes+1]);for(holeArray=0;3>holeArray;holeArray++)holes=graphicsData[eps+holeArray*buildData%3],verts.push(tempArr[2*holes],tempArr[2*holes+1])}}else for(eps=0;eps<points.length;eps+=2)verts.push(points[eps],points[eps+1]),joints.push(exports.JOINT_TYPE.FILL)}}}const FILL_COMMANDS={[math.SHAPES.POLY]:new PolyBuilder,[math.SHAPES.CIRC]:new CircleBuilder,[math.SHAPES.ELIP]:new CircleBuilder,[math.SHAPES.RECT]:new RectangleBuilder,[math.SHAPES.RREC]:new RoundedRectangleBuilder},BATCH_POOL=[],
DRAW_CALL_POOL=[],tmpPoint=new math.Point,tmpBounds=new display.Bounds;class SmoothGraphicsGeometry extends core.Geometry{static __initStatic(){this.BATCHABLE_SIZE=100}__init(){this.indicesUint16=null}get points(){return this.buildData.verts}get closePointEps(){return this.buildData.closePointEps}initAttributes(_static){this._buffer=new core.Buffer(null,_static,!1);this._bufferFloats=new Float32Array;this._bufferUint=new Uint32Array;this._indexBuffer=new core.Buffer(null,_static,!0);this.addAttribute("aPrev",
this._buffer,2,!1,constants.TYPES.FLOAT).addAttribute("aPoint1",this._buffer,2,!1,constants.TYPES.FLOAT).addAttribute("aPoint2",this._buffer,2,!1,constants.TYPES.FLOAT).addAttribute("aNext",this._buffer,2,!1,constants.TYPES.FLOAT).addAttribute("aTravel",this._buffer,1,!1,constants.TYPES.FLOAT).addAttribute("aVertexJoint",this._buffer,1,!1,constants.TYPES.FLOAT).addAttribute("aStyleId",this._buffer,1,!1,constants.TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,constants.TYPES.UNSIGNED_BYTE).addIndex(this._indexBuffer);
this.strideFloats=12}constructor(){super();SmoothGraphicsGeometry.prototype.__init.call(this);this.initAttributes(!1);this.buildData=new BuildData;this.graphicsData=[];this.dirty=0;this.cacheDirty=this.batchDirty=-1;this.clearDirty=0;this.drawCalls=[];this.batches=[];this.shapeBatchIndex=this.shapeBuildIndex=0;this._bounds=new display.Bounds;this.boundsDirty=-1;this.boundsPadding=0;this.batchable=!1;this.packer=this.indicesUint16=null;this.packSize=0;this.pack32index=null}checkInstancing(instanced,
allow32Indices){this.packer||(this.packer=new SegmentPacker,this.pack32index=allow32Indices)}get bounds(){this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds());return this._bounds}invalidate(){this.boundsDirty=-1;this.dirty++;this.batchDirty++;this.packSize=this.shapeBatchIndex=this.shapeBuildIndex=0;this.buildData.clear();for(var i=0;i<this.drawCalls.length;i++)this.drawCalls[i].clear(),DRAW_CALL_POOL.push(this.drawCalls[i]);this.drawCalls.length=0;for(i=0;i<this.batches.length;i++){const batchPart=
this.batches[i];batchPart.reset();BATCH_POOL.push(batchPart)}this.batches.length=0}clear(){0<this.graphicsData.length&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0);return this}drawShape(shape,fillStyle=null,lineStyle=null,matrix=null){shape=new SmoothGraphicsData(shape,fillStyle,lineStyle,matrix);this.graphicsData.push(shape);this.dirty++;return this}drawHole(shape,matrix=null){if(!this.graphicsData.length)return null;shape=new SmoothGraphicsData(shape,null,null,matrix);matrix=
this.graphicsData[this.graphicsData.length-1];shape.lineStyle=matrix.lineStyle;matrix.holes.push(shape);this.dirty++;return this}destroy(){super.destroy();for(let i=0;i<this.graphicsData.length;++i)this.graphicsData[i].destroy();this.buildData.destroy();this.buildData=null;this.indexBuffer.destroy();this.indexBuffer=null;this.graphicsData.length=0;this.graphicsData=null;this.drawCalls.length=0;this.drawCalls=null;this.batches.length=0;this._bounds=this.batches=null}containsPoint(point){const graphicsData=
this.graphicsData;for(let i$jscomp$0=0;i$jscomp$0<graphicsData.length;++i$jscomp$0){const data=graphicsData[i$jscomp$0];if(data.fillStyle.visible&&data.shape&&(data.matrix?data.matrix.applyInverse(point,tmpPoint):tmpPoint.copyFrom(point),data.shape.contains(tmpPoint.x,tmpPoint.y))){let hitHole=!1;if(data.holes)for(let i=0;i<data.holes.length;i++)if(data.holes[i].shape.contains(tmpPoint.x,tmpPoint.y)){hitHole=!0;break}if(!hitHole)return!0}}return!1}updatePoints(){}updateBufferSize(){this._buffer.update(new Float32Array)}updateBuild(){const {graphicsData,
buildData}=this,len=graphicsData.length;for(let i=this.shapeBuildIndex;i<len;i++){const data=graphicsData[i];data.strokeStart=0;data.strokeLen=0;data.fillStart=0;data.fillLen=0;const {fillStyle,lineStyle,holes}=data;if(!fillStyle.visible&&!lineStyle.visible)continue;const command=FILL_COMMANDS[data.type];data.clearPath();command.path(data,buildData);data.matrix&&this.transformPoints(data.points,data.matrix);data.clearBuild();2>=data.points.length||(fillStyle.visible&&(holes.length&&this.processHoles(holes),
data.fillAA=data.fillStyle.smooth&&!(data.lineStyle.visible&&.99<=data.lineStyle.alpha&&.99<=data.lineStyle.width),data.fillStart=buildData.joints.length,command.fill(data,buildData),data.fillLen=buildData.joints.length-data.fillStart),lineStyle.visible&&(data.strokeStart=buildData.joints.length,command.line(data,buildData),data.strokeLen=buildData.joints.length-data.strokeStart))}this.shapeBuildIndex=len}updateBatches(shaderSettings){if(this.graphicsData.length){if(this.updateBuild(),this.validateBatching()){var {buildData,
graphicsData}=this,len=graphicsData.length;this.cacheDirty=this.dirty;var batchPart=null,currentStyle=null;0<this.batches.length&&(batchPart=this.batches[this.batches.length-1],currentStyle=batchPart.style);for(let i=this.shapeBatchIndex;i<len;i++){const data=graphicsData[i],fillStyle=data.fillStyle,lineStyle=data.lineStyle;data.matrix&&this.transformPoints(data.points,data.matrix);if(fillStyle.visible||lineStyle.visible)for(let j=0;2>j;j++){const style=0===j?fillStyle:lineStyle;if(!style.visible)continue;
const attribOld=buildData.vertexSize,indexOld=buildData.indexSize;style.texture.baseTexture.wrapMode=constants.WRAP_MODES.REPEAT;0===j?this.packer.updateBufferSize(data.fillStart,data.fillLen,data.triangles.length,buildData):this.packer.updateBufferSize(data.strokeStart,data.strokeLen,data.triangles.length,buildData);buildData.vertexSize!==attribOld&&(batchPart&&!this._compareStyles(currentStyle,style)&&(batchPart.end(indexOld,attribOld),batchPart=null),batchPart||(batchPart=BATCH_POOL.pop()||new BatchPart,
batchPart.begin(style,indexOld,attribOld),this.batches.push(batchPart),currentStyle=style),batchPart.jointEnd=0===j?data.fillStart+data.fillLen:data.strokeStart+data.strokeLen)}}this.shapeBatchIndex=len;batchPart&&batchPart.end(buildData.indexSize,buildData.vertexSize);0===this.batches.length?this.batchable=!0:(this.batchable=this.isBatchable())?this.packBatches():(this.buildDrawCalls(shaderSettings),this.updatePack())}}else this.batchable=!0}updatePack(){const {vertexSize,indexSize}=this.buildData;
if(this.packSize!==vertexSize){var {strideFloats,packer,buildData,batches}=this,buffer=this._buffer,index=this._indexBuffer,floatsSize=vertexSize*strideFloats;buffer.data.length!==floatsSize&&(floatsSize=new ArrayBuffer(4*floatsSize),this._bufferFloats=new Float32Array(floatsSize),this._bufferUint=new Uint32Array(floatsSize),buffer.data=this._bufferFloats);index.data.length!==indexSize&&(index.data=65535<vertexSize&&this.pack32index?new Uint32Array(indexSize):new Uint16Array(indexSize));packer.beginPack(buildData,
this._bufferFloats,this._bufferUint,index.data);floatsSize=0;for(let i=0;i<this.graphicsData.length;i++){const data=this.graphicsData[i];if(data.fillLen){for(;batches[floatsSize].jointEnd<=data.fillStart;)floatsSize++;packer.packInterleavedGeometry(data.fillStart,data.fillLen,data.triangles,batches[floatsSize].styleId,batches[floatsSize].rgba)}if(data.strokeLen){for(;batches[floatsSize].jointEnd<=data.strokeStart;)floatsSize++;packer.packInterleavedGeometry(data.strokeStart,data.strokeLen,data.triangles,
batches[floatsSize].styleId,batches[floatsSize].rgba)}}buffer.update();index.update();this.packSize=vertexSize}}_compareStyles(styleA,styleB){return styleA&&styleB&&styleA.texture.baseTexture===styleB.texture.baseTexture&&styleA.color+styleA.alpha===styleB.color+styleB.alpha&&styleA.packLineWidth()===styleB.packLineWidth()&&styleA.alignment===styleB.alignment?matrixEquals(styleA.matrix||math.Matrix.IDENTITY,styleB.matrix||math.Matrix.IDENTITY):!1}validateBatching(){if(this.dirty===this.cacheDirty||
!this.graphicsData.length)return!1;for(let i=0,l=this.graphicsData.length;i<l;i++){var data=this.graphicsData[i];const fill=data.fillStyle;data=data.lineStyle;if(fill&&!fill.texture.baseTexture.valid||data&&!data.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++;const batches=this.batches;for(let i=0,l=batches.length;i<l;i++){const batch=batches[i];for(let j=0;j<batch.size;j++){const index=batch.start+j;this.indicesUint16[index]-=batch.attribStart}}}isBatchable(){return!1}buildDrawCalls(shaderSettings){for(var i$jscomp$0=
0;i$jscomp$0<this.drawCalls.length;i$jscomp$0++)this.drawCalls[i$jscomp$0].clear(),DRAW_CALL_POOL.push(this.drawCalls[i$jscomp$0]);this.drawCalls.length=0;i$jscomp$0=DRAW_CALL_POOL.pop()||new BatchDrawCall;i$jscomp$0.begin(shaderSettings,null);let index=0;this.drawCalls.push(i$jscomp$0);for(let i=0;i<this.batches.length;i++){const batchData=this.batches[i],style=batchData.style;if(0===batchData.attribSize)continue;let styleId=-1;const mat=style.getTextureMatrix();i$jscomp$0.check(style.shader)&&(styleId=
i$jscomp$0.add(style.texture,mat,style.packLineWidth(),style.alignment||0));0>styleId&&(i$jscomp$0=DRAW_CALL_POOL.pop()||new BatchDrawCall,this.drawCalls.push(i$jscomp$0),i$jscomp$0.begin(shaderSettings,style.shader),i$jscomp$0.start=index,styleId=i$jscomp$0.add(style.texture,mat,style.packLineWidth(),style.alignment||0));i$jscomp$0.size+=batchData.size;index+=batchData.size;const {color,alpha}=style;batchData.rgba=utils.premultiplyTint((color>>16)+(color&65280)+((color&255)<<16),alpha);batchData.styleId=
styleId}}processHoles(holes){for(let i=0;i<holes.length;i++){const hole=holes[i];FILL_COMMANDS[hole.type].path(hole,this.buildData);hole.matrix&&this.transformPoints(hole.points,hole.matrix)}}calculateBounds(){const bounds=this._bounds;let curMatrix=math.Matrix.IDENTITY;this._bounds.clear();tmpBounds.clear();for(let i=0;i<this.graphicsData.length;i++){var data=this.graphicsData[i],shape=data.shape;const type=data.type,lineStyle=data.lineStyle,nextMatrix=data.matrix||math.Matrix.IDENTITY;data=0;if(lineStyle&&
lineStyle.visible){const alignment=lineStyle.alignment;data=lineStyle.width;data=type===math.SHAPES.POLY?data*(.5+Math.abs(.5-alignment)):data*Math.max(0,alignment)}curMatrix!==nextMatrix&&(tmpBounds.isEmpty()||(bounds.addBoundsMatrix(tmpBounds,curMatrix),tmpBounds.clear()),curMatrix=nextMatrix);type===math.SHAPES.RECT||type===math.SHAPES.RREC?tmpBounds.addFramePad(shape.x,shape.y,shape.x+shape.width,shape.y+shape.height,data,data):type===math.SHAPES.CIRC?tmpBounds.addFramePad(shape.x,shape.y,shape.x,
shape.y,shape.radius+data,shape.radius+data):type===math.SHAPES.ELIP?tmpBounds.addFramePad(shape.x,shape.y,shape.x,shape.y,shape.width+data,shape.height+data):bounds.addVerticesMatrix(curMatrix,shape.points,0,shape.points.length,data,data)}tmpBounds.isEmpty()||bounds.addBoundsMatrix(tmpBounds,curMatrix);bounds.pad(this.boundsPadding,this.boundsPadding)}transformPoints(points,matrix){for(let i=0;i<points.length/2;i++){const x=points[2*i],y=points[2*i+1];points[2*i]=matrix.a*x+matrix.c*y+matrix.tx;
points[2*i+1]=matrix.b*x+matrix.d*y+matrix.ty}}}SmoothGraphicsGeometry.__initStatic();class SmoothGraphicsProgram extends core.Program{constructor(settings,vert="precision highp float;\nconst float FILL \x3d 1.0;\nconst float BEVEL \x3d 4.0;\nconst float MITER \x3d 8.0;\nconst float ROUND \x3d 12.0;\nconst float JOINT_CAP_BUTT \x3d 16.0;\nconst float JOINT_CAP_SQUARE \x3d 18.0;\nconst float JOINT_CAP_ROUND \x3d 20.0;\n\nconst float FILL_EXPAND \x3d 24.0;\n\nconst float CAP_BUTT \x3d 1.0;\nconst float CAP_SQUARE \x3d 2.0;\nconst float CAP_ROUND \x3d 3.0;\nconst float CAP_BUTT2 \x3d 4.0;\n\nconst float MITER_LIMIT \x3d 10.0;\n\n// \x3d\x3d\x3d geom \x3d\x3d\x3d\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float aTravel;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec4 vSignedCoord;\nvarying vec4 vDistance;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\n\n// \x3d\x3d\x3d style \x3d\x3d\x3d\nattribute float aStyleId;\nattribute vec4 aColor;\n\nvarying float vTextureId;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\n\nuniform vec2 styleLine[%MAX_STYLES%];\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\nuniform float styleTextureId[%MAX_STYLES%];\nuniform vec2 samplerSize[%MAX_TEXTURES%];\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect \x3d (norm + norm2) / 2.0;\n    bisect /\x3d dot(norm, bisect);\n    vec2 shift \x3d dy * bisect;\n    if (inner \x3e 0.5) {\n        if (len \x3c len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) \x3e len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) \x3e len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA \x3d (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB \x3d (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis \x3d pointB - pointA;\n    float len \x3d length(xBasis);\n    vec2 forward \x3d xBasis / len;\n    vec2 norm \x3d vec2(forward.y, -forward.x);\n\n    float type \x3d floor(aVertexJoint / 16.0);\n    float vertexNum \x3d aVertexJoint - type * 16.0;\n    float dx \x3d 0.0, dy \x3d 1.0;\n\n\n    vec2 avgDiag \x3d (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n    float avgScale \x3d sqrt(dot(avgDiag, avgDiag) * 0.5);\n\n    float capType \x3d floor(type / 32.0);\n    type -\x3d capType * 32.0;\n\n    int styleId \x3d int(aStyleId + 0.5);\n    float lineWidth \x3d styleLine[styleId].x;\n    if (lineWidth \x3c 0.0) {\n        lineWidth \x3d -lineWidth;\n    } else {\n        lineWidth \x3d lineWidth * avgScale;\n    }\n    lineWidth *\x3d 0.5;\n    float lineAlignment \x3d 2.0 * styleLine[styleId].y - 1.0;\n    vTextureId \x3d styleTextureId[styleId];\n    vTextureCoord \x3d vec2(0.0);\n\n    vec2 pos;\n\n    if (capType \x3d\x3d CAP_ROUND) {\n        vertexNum +\x3d 4.0;\n        type \x3d JOINT_CAP_ROUND;\n        capType \x3d 0.0;\n    }\n\n    if (type \x3d\x3d FILL) {\n        pos \x3d pointA;\n        vDistance \x3d vec4(0.0, -0.5, -0.5, 1.0);\n        vType \x3d 0.0;\n\n        vec2 vTexturePixel;\n        vTexturePixel.x \x3d dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\n        vTexturePixel.y \x3d dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\n        vTextureCoord \x3d vTexturePixel / samplerSize[int(vTextureId)];\n    } else if (type \x3e\x3d FILL_EXPAND \x26\x26 type \x3c FILL_EXPAND + 7.5) {\n        // expand vertices\n        float flags \x3d type - FILL_EXPAND;\n        float flag3 \x3d floor(flags / 4.0);\n        float flag2 \x3d floor((flags - flag3 * 4.0) / 2.0);\n        float flag1 \x3d flags - flag3 * 4.0 - flag2 * 2.0;\n\n        vec2 prev \x3d (translationMatrix * vec3(aPrev, 1.0)).xy;\n\n        if (vertexNum \x3c 0.5) {\n            pos \x3d prev;\n        } else if (vertexNum \x3c 1.5) {\n            pos \x3d pointA;\n        } else {\n            pos \x3d pointB;\n        }\n        float len2 \x3d length(aNext);\n        vec2 bisect \x3d (translationMatrix * vec3(aNext, 0.0)).xy;\n        if (len2 \x3e 0.01) {\n            bisect \x3d normalize(bisect) * len2;\n        }\n\n        vec2 n1 \x3d normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\n        vec2 n2 \x3d normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\n        vec2 n3 \x3d normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\n\n        if (n1.x * n2.y - n1.y * n2.x \x3c 0.0) {\n            n1 \x3d -n1;\n            n2 \x3d -n2;\n            n3 \x3d -n3;\n        }\n\n        vDistance.w \x3d 1.0;\n        pos +\x3d bisect * expand;\n\n        vDistance \x3d vec4(16.0, 16.0, 16.0, -1.0);\n        if (flag1 \x3e 0.5) {\n            vDistance.x \x3d -dot(pos - prev, n1);\n        }\n        if (flag2 \x3e 0.5) {\n            vDistance.y \x3d -dot(pos - pointA, n2);\n        }\n        if (flag3 \x3e 0.5) {\n            vDistance.z \x3d -dot(pos - pointB, n3);\n        }\n        vDistance.xyz *\x3d resolution;\n        vType \x3d 2.0;\n    } else if (type \x3e\x3d BEVEL) {\n        float dy \x3d lineWidth + expand;\n        float inner \x3d 0.0;\n        if (vertexNum \x3e\x3d 1.5) {\n            dy \x3d -dy;\n            inner \x3d 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag \x3d 0.0;\n        float sign2 \x3d 1.0;\n        if (vertexNum \x3c 0.5 || vertexNum \x3e 2.5 \x26\x26 vertexNum \x3c 3.5) {\n            next \x3d (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base \x3d pointA;\n            flag \x3d type - floor(type / 2.0) * 2.0;\n            sign2 \x3d -1.0;\n        } else {\n            next \x3d (translationMatrix * vec3(aNext, 1.0)).xy;\n            base \x3d pointB;\n            if (type \x3e\x3d MITER \x26\x26 type \x3c MITER + 3.5) {\n                flag \x3d step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 \x3d next - base;\n        float len2 \x3d length(xBasis2);\n        vec2 norm2 \x3d vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D \x3d norm.x * norm2.y - norm.y * norm2.x;\n        if (D \x3c 0.0) {\n            inner \x3d 1.0 - inner;\n        }\n\n        norm2 *\x3d sign2;\n\n        if (abs(lineAlignment) \x3e 0.01) {\n            float shift \x3d lineWidth * lineAlignment;\n            pointA +\x3d norm * shift;\n            pointB +\x3d norm * shift;\n            if (abs(D) \x3c 0.01) {\n                base +\x3d norm * shift;\n            } else {\n                base +\x3d doBisect(norm, len, norm2, len2, shift, 0.0);\n            }\n        }\n\n        float collinear \x3d step(0.0, dot(norm, norm2));\n\n        vType \x3d 0.0;\n        float dy2 \x3d -1000.0;\n        float dy3 \x3d -1000.0;\n\n        if (abs(D) \x3c 0.01 \x26\x26 collinear \x3c 0.5) {\n            if (type \x3e\x3d ROUND \x26\x26 type \x3c ROUND + 1.5) {\n                type \x3d JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        if (vertexNum \x3c 3.5) {\n            if (abs(D) \x3c 0.01) {\n                pos \x3d dy * norm;\n            } else {\n                if (flag \x3c 0.5 \x26\x26 inner \x3c 0.5) {\n                    pos \x3d dy * norm;\n                } else {\n                    pos \x3d doBisect(norm, len, norm2, len2, dy, inner);\n                }\n            }\n            if (capType \x3e\x3d CAP_BUTT \x26\x26 capType \x3c CAP_ROUND) {\n                float extra \x3d step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back \x3d -forward;\n                if (vertexNum \x3c 0.5 || vertexNum \x3e 2.5) {\n                    pos +\x3d back * (expand + extra);\n                    dy2 \x3d expand;\n                } else {\n                    dy2 \x3d dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type \x3e\x3d JOINT_CAP_BUTT \x26\x26 type \x3c JOINT_CAP_SQUARE + 0.5) {\n                float extra \x3d step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum \x3c 0.5 || vertexNum \x3e 2.5) {\n                    dy3 \x3d dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos +\x3d forward * (expand + extra);\n                    dy3 \x3d expand;\n                    if (capType \x3e\x3d CAP_BUTT) {\n                        dy2 -\x3d expand + extra;\n                    }\n                }\n            }\n        } else if (type \x3e\x3d JOINT_CAP_ROUND \x26\x26 type \x3c JOINT_CAP_ROUND + 1.5) {\n            if (inner \x3e 0.5) {\n                dy \x3d -dy;\n                inner \x3d 0.0;\n            }\n            vec2 d2 \x3d abs(dy) * vec2(-norm.y, norm.x);\n            if (vertexNum \x3c 4.5) {\n                dy \x3d -dy;\n                pos \x3d dy * norm;\n            } else if (vertexNum \x3c 5.5) {\n                pos \x3d dy * norm;\n            } else if (vertexNum \x3c 6.5) {\n                pos \x3d dy * norm + d2;\n            } else {\n                dy \x3d -dy;\n                pos \x3d dy * norm + d2;\n            }\n            dy \x3d -0.5;\n            dy2 \x3d pos.x;\n            dy3 \x3d pos.y;\n            vType \x3d 3.0;\n        } else if (abs(D) \x3c 0.01) {\n            pos \x3d dy * norm;\n        } else {\n            if (type \x3e\x3d ROUND \x26\x26 type \x3c ROUND + 1.5) {\n                if (inner \x3e 0.5) {\n                    dy \x3d -dy;\n                    inner \x3d 0.0;\n                }\n                if (vertexNum \x3c 4.5) {\n                    pos \x3d doBisect(norm, len, norm2, len2, -dy, 1.0);\n                } else if (vertexNum \x3c 5.5) {\n                    pos \x3d dy * norm;\n                } else if (vertexNum \x3e 7.5) {\n                    pos \x3d dy * norm2;\n                } else {\n                    pos \x3d doBisect(norm, len, norm2, len2, dy, 0.0);\n                    float d2 \x3d abs(dy);\n                    if (length(pos) \x3e abs(dy) * 1.5) {\n                        if (vertexNum \x3c 6.5) {\n                            pos.x \x3d dy * norm.x - d2 * norm.y;\n                            pos.y \x3d dy * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x \x3d dy * norm2.x + d2 * norm2.y;\n                            pos.y \x3d dy * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                }\n                vec2 norm3 \x3d normalize(norm - norm2);\n                dy \x3d pos.x * norm3.y - pos.y * norm3.x - 3.0;\n                dy2 \x3d pos.x;\n                dy3 \x3d pos.y;\n                vType \x3d 3.0;\n            } else {\n                if (type \x3e\x3d MITER \x26\x26 type \x3c MITER + 3.5) {\n                    if (inner \x3e 0.5) {\n                        dy \x3d -dy;\n                        inner \x3d 0.0;\n                    }\n                    float sign \x3d step(0.0, dy) * 2.0 - 1.0;\n                    pos \x3d doBisect(norm, len, norm2, len2, dy, 0.0);\n                    if (length(pos) \x3e abs(dy) * MITER_LIMIT) {\n                        type \x3d BEVEL;\n                    } else {\n                        if (vertexNum \x3c 4.5) {\n                            dy \x3d -dy;\n                            pos \x3d doBisect(norm, len, norm2, len2, dy, 1.0);\n                        } else if (vertexNum \x3c 5.5) {\n                            pos \x3d dy * norm;\n                        } else if (vertexNum \x3e 6.5) {\n                            pos \x3d dy * norm2;\n                            // dy \x3d ...\n                        }\n                    }\n                    vType \x3d 1.0;\n                    dy \x3d -sign * dot(pos, norm);\n                    dy2 \x3d -sign * dot(pos, norm2);\n                }\n                if (type \x3e\x3d BEVEL \x26\x26 type \x3c BEVEL + 1.5) {\n                    if (inner \x3c 0.5) {\n                        dy \x3d -dy;\n                        inner \x3d 1.0;\n                    }\n                    vec2 norm3 \x3d normalize((norm + norm2) / 2.0);\n                    if (vertexNum \x3c 4.5) {\n                        pos \x3d doBisect(norm, len, norm2, len2, dy, 1.0);\n                        dy2 \x3d -abs(dot(pos + dy * norm, norm3));\n                    } else {\n                        dy2 \x3d 0.0;\n                        dy \x3d -dy;\n                        if (vertexNum \x3c 5.5) {\n                            pos \x3d dy * norm;\n                        } else {\n                            pos \x3d dy * norm2;\n                        }\n                    }\n                }\n            }\n        }\n\n        pos +\x3d base;\n        vDistance \x3d vec4(dy, dy2, dy3, lineWidth) * resolution;\n        vTravel \x3d aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x));\n    }\n\n    gl_Position \x3d vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n\n    vColor \x3d aColor * tint;\n}",
frag="\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\n\nvoid main(void){\n    float alpha \x3d 1.0;\n    float lineWidth \x3d vDistance.w;\n    if (vType \x3c 0.5) {\n        float left \x3d max(vDistance.x - 0.5, -vDistance.w);\n        float right \x3d min(vDistance.x + 0.5, vDistance.w);\n        float near \x3d vDistance.y - 0.5;\n        float far \x3d min(vDistance.y + 0.5, 0.0);\n        float top \x3d vDistance.z - 0.5;\n        float bottom \x3d min(vDistance.z + 0.5, 0.0);\n        alpha \x3d max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType \x3c 1.5) {\n        float a1 \x3d clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 \x3d clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 \x3d clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 \x3d clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha \x3d a2 * b2 - a1 * b1;\n    } else if (vType \x3c 2.5) {\n        alpha *\x3d max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *\x3d max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *\x3d max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 \x3d sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad \x3d vDistance.w;\n        float left \x3d max(dist2 - 0.5, -rad);\n        float right \x3d min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha \x3d 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    vec4 texColor;\n    float textureId \x3d floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor \x3d vColor * texColor * alpha;\n}\n",
_uniforms){const {maxStyles,maxTextures}=settings;vert=vert.replace(/%MAX_TEXTURES%/gi,`${maxTextures}`).replace(/%MAX_STYLES%/gi,`${maxStyles}`);frag=frag.replace(/%MAX_TEXTURES%/gi,`${maxTextures}`).replace(/%FOR_LOOP%/gi,SmoothGraphicsShader.generateSampleSrc(maxTextures));super(vert,frag);this.settings=settings}}class SmoothGraphicsShader extends core.Shader{constructor(settings,prog=new SmoothGraphicsProgram(settings),uniforms={}){const {maxStyles,maxTextures}=settings,sampleValues=new Int32Array(maxTextures);
for(let i=0;i<maxTextures;i++)sampleValues[i]=i;super(prog,Object.assign(uniforms,{styleMatrix:new Float32Array(6*maxStyles),styleTextureId:new Float32Array(maxStyles),styleLine:new Float32Array(2*maxStyles),samplerSize:new Float32Array(2*maxTextures),uSamplers:sampleValues,tint:new Float32Array([1,1,1,1]),resolution:1,expand:1}));this.settings=settings}static generateSampleSrc(maxTextures){let src;src="\n\n";for(let i=0;i<maxTextures;i++)0<i&&(src+="\nelse "),i<maxTextures-1&&(src+=`if(textureId < ${i}.5)`),
src+="\n{",src+=`\n\ttexColor = texture2D(uSamplers[${i}], vTextureCoord);`,src+="\n}";return src+"\n\n"}}const settings$jscomp$0={LINE_SCALE_MODE:exports.LINE_SCALE_MODE.NORMAL,SHADER_MAX_STYLES:24,SHADER_MAX_TEXTURES:4},{BezierUtils,QuadraticUtils,ArcUtils}=graphics.graphicsUtils,temp=new Float32Array(3),DEFAULT_SHADERS={};class SmoothGraphics extends display.Container{static __initStatic(){this._TEMP_POINT=new math.Point}get geometry(){return this._geometry}constructor(geometry=null){super();this._geometry=
geometry||new SmoothGraphicsGeometry;this._geometry.refCount++;this.shader=null;this.shaderSettings={maxStyles:settings$jscomp$0.SHADER_MAX_STYLES,maxTextures:settings$jscomp$0.SHADER_MAX_TEXTURES};this.state=core.State.for2d();this._fillStyle=new FillStyle;this._lineStyle=new LineStyle;this._matrix=null;this._holeMode=!1;this.currentPath=null;this.batches=[];this.batchDirty=this.batchTint=-1;this.vertexData=null;this.pluginName="smooth";this._transformID=-1;this.tint=16777215;this.blendMode=constants.BLEND_MODES.NORMAL}clone(){this.finishPoly();
return new SmoothGraphics(this._geometry)}set blendMode(value){this.state.blendMode=value}get blendMode(){return this.state.blendMode}get tint(){return this._tint}set tint(value){this._tint=value}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(options=null,color=0,alpha=1,alignment=.5,scaleMode=settings$jscomp$0.LINE_SCALE_MODE){"number"===typeof options?("boolean"===typeof scaleMode&&(scaleMode=scaleMode?exports.LINE_SCALE_MODE.NONE:exports.LINE_SCALE_MODE.NORMAL),options=
{width:options,color,alpha,alignment,scaleMode}):(color=options.native,void 0!==color&&(options.scaleMode=color?exports.LINE_SCALE_MODE.NONE:exports.LINE_SCALE_MODE.NORMAL));return this.lineTextureStyle(options)}lineTextureStyle(options){options=Object.assign({width:0,texture:core.Texture.WHITE,color:options&&options.texture?16777215:0,alpha:1,matrix:null,alignment:.5,native:!1,cap:graphics.LINE_CAP.BUTT,join:graphics.LINE_JOIN.MITER,miterLimit:10,shader:null,scaleMode:settings$jscomp$0.LINE_SCALE_MODE},
options);this.currentPath&&this.startPoly();const visible=0<options.width&&0<options.alpha;visible?(options.matrix&&(options.matrix=options.matrix.clone(),options.matrix.invert()),Object.assign(this._lineStyle,{visible},options)):this._lineStyle.reset();return this}startPoly(){if(this.currentPath){const points=this.currentPath.points,len=this.currentPath.points.length;2<len&&(this.drawShape(this.currentPath),this.currentPath=new math.Polygon,this.currentPath.closeStroke=!1,this.currentPath.points.push(points[len-
2],points[len-1]))}else this.currentPath=new math.Polygon,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(2<this.currentPath.points.length?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(x,y){this.startPoly();this.currentPath.points[0]=x;this.currentPath.points[1]=y;return this}lineTo(x,y){this.currentPath||this.moveTo(0,0);const points=this.currentPath.points,fromY=points[points.length-1];points[points.length-2]===x&&fromY===y||points.push(x,
y);return this}_initCurve(x=0,y=0){this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[x,y]):this.moveTo(x,y)}quadraticCurveTo(cpX,cpY,toX,toY){this._initCurve();const points=this.currentPath.points;0===points.length&&this.moveTo(0,0);QuadraticUtils.curveTo(cpX,cpY,toX,toY,points);return this}bezierCurveTo(cpX,cpY,cpX2,cpY2,toX,toY){this._initCurve();BezierUtils.curveTo(cpX,cpY,cpX2,cpY2,toX,toY,this.currentPath.points);return this}arcTo(x1,y1,x2,y2,radius$jscomp$0){this._initCurve(x1,
y1);if(x1=ArcUtils.curveTo(x1,y1,x2,y2,radius$jscomp$0,this.currentPath.points)){const {cx,cy,radius,startAngle,endAngle,anticlockwise}=x1;this.arc(cx,cy,radius,startAngle,endAngle,anticlockwise)}return this}arc(cx,cy,radius,startAngle,endAngle,anticlockwise=!1){if(startAngle===endAngle)return this;!anticlockwise&&endAngle<=startAngle?endAngle+=math.PI_2:anticlockwise&&startAngle<=endAngle&&(startAngle+=math.PI_2);if(0===endAngle-startAngle)return this;const startX=cx+Math.cos(startAngle)*radius,
startY=cy+Math.sin(startAngle)*radius,eps=this._geometry.closePointEps;let points=this.currentPath?this.currentPath.points:null;if(points){const yDiff=Math.abs(points[points.length-1]-startY);Math.abs(points[points.length-2]-startX)<eps&&yDiff<eps||points.push(startX,startY)}else this.moveTo(startX,startY),points=this.currentPath.points;ArcUtils.arc(startX,startY,cx,cy,radius,startAngle,endAngle,anticlockwise,points);return this}beginFill(color=0,alpha=1,smooth=!1){return this.beginTextureFill({texture:core.Texture.WHITE,
color,alpha,smooth})}beginTextureFill(options){options=Object.assign({texture:core.Texture.WHITE,color:16777215,alpha:1,matrix:null,smooth:!1},options);this.currentPath&&this.startPoly();const visible=0<options.alpha;visible?(options.matrix&&(options.matrix=options.matrix.clone(),options.matrix.invert()),Object.assign(this._fillStyle,{visible},options)):this._fillStyle.reset();return this}endFill(){this.finishPoly();this._fillStyle.reset();return this}drawRect(x,y,width,height){return this.drawShape(new math.Rectangle(x,
y,width,height))}drawRoundedRect(x,y,width,height,radius){return this.drawShape(new math.RoundedRectangle(x,y,width,height,radius))}drawCircle(x,y,radius){return this.drawShape(new math.Circle(x,y,radius))}drawEllipse(x,y,width,height){return this.drawShape(new math.Ellipse(x,y,width,height))}drawPolygon(...path){let closeStroke=!0;const poly=path[0];poly.points?(closeStroke=poly.closeStroke,path=poly.points):path=Array.isArray(path[0])?path[0]:path;path=new math.Polygon(path);path.closeStroke=closeStroke;
this.drawShape(path);return this}drawShape(shape){this._holeMode?this._geometry.drawHole(shape,this._matrix):this._geometry.drawShape(shape,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix);return this}clear(){this._geometry.clear();this._lineStyle.reset();this._fillStyle.reset();this._boundsID++;this._matrix=null;this._holeMode=!1;this.currentPath=null;return this}isFastRect(){const data=this._geometry.graphicsData;return 1===data.length&&data[0].shape.type===math.SHAPES.RECT&&!(data[0].lineStyle.visible&&
data[0].lineStyle.width)}_renderCanvas(renderer){graphics.Graphics.prototype._renderCanvas.call(this,renderer)}_render(renderer){this.finishPoly();const geometry=this._geometry;geometry.checkInstancing(renderer.geometry.hasInstance,renderer.context.supports.uint32Indices);geometry.updateBatches(this.shaderSettings);geometry.batchable?(this.batchDirty!==geometry.batchDirty&&this._populateBatches(),this._renderBatched(renderer)):(renderer.batch.flush(),this._renderDirect(renderer))}_populateBatches(){const geometry=
this._geometry,blendMode=this.blendMode,len=geometry.batches.length;this._transformID=this.batchTint=-1;this.batchDirty=geometry.batchDirty;this.batches.length=len;this.vertexData=new Float32Array(geometry.points);for(let i=0;i<len;i++){var gI=geometry.batches[i];const color=gI.style.color;gI={vertexData:new Float32Array(this.vertexData.buffer,8*gI.attribStart,2*gI.attribSize),blendMode,_batchRGB:utils.hex2rgb(color),_tintRGB:color,_texture:gI.style.texture,alpha:gI.style.alpha,worldAlpha:1};this.batches[i]=
gI}}_renderBatched(renderer){if(this.batches.length){renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);this.calculateVertices();this.calculateTints();for(let i=0,l=this.batches.length;i<l;i++){const batch=this.batches[i];batch.worldAlpha=this.worldAlpha*batch.alpha;renderer.plugins[this.pluginName].render(batch)}}}_renderDirect(renderer){const directShader=this._resolveDirectShader(renderer);let shader=directShader;const geometry=this._geometry;var tint=this.tint,worldAlpha=this.worldAlpha;
const uniforms=shader.uniforms;var drawCalls=geometry.drawCalls;uniforms.translationMatrix=this.transform.worldTransform;uniforms.tint[0]=(tint>>16&255)/255*worldAlpha;uniforms.tint[1]=(tint>>8&255)/255*worldAlpha;uniforms.tint[2]=(tint&255)/255*worldAlpha;uniforms.tint[3]=worldAlpha;uniforms.resolution=renderer.renderTexture.current?renderer.renderTexture.current.resolution:renderer.resolution;if(tint=renderer.projection.transform)uniforms.resolution*=Math.sqrt(tint.a*tint.a+tint.b*tint.b);uniforms.expand=
(renderer.options.antialias?2:1)/uniforms.resolution;renderer.shader.bind(shader);renderer.geometry.bind(geometry,shader);renderer.state.set(this.state);shader=null;for(let i$jscomp$0=0,l=drawCalls.length;i$jscomp$0<l;i$jscomp$0++){tint=geometry.drawCalls[i$jscomp$0];if(drawCalls=shader!==tint.shader)if(shader=tint.shader)shader.uniforms.translationMatrix=this.transform.worldTransform,shader.uniforms.tint&&(shader.uniforms.tint[0]=uniforms.tint[0],shader.uniforms.tint[1]=uniforms.tint[1],shader.uniforms.tint[2]=
uniforms.tint[2],shader.uniforms.tint[3]=uniforms.tint[3]);const {texArray,styleArray,size,start}=tint;tint=texArray.count;worldAlpha=shader||directShader;var texs=worldAlpha.uniforms.styleTextureId,mats=worldAlpha.uniforms.styleMatrix;const lines=worldAlpha.uniforms.styleLine;for(let i=0;i<styleArray.count;i++){texs[i]=styleArray.textureIds[i];lines[2*i]=styleArray.lines[2*i];lines[2*i+1]=styleArray.lines[2*i+1];const m=styleArray.matrices[i];mats[6*i]=m.a;mats[6*i+1]=m.c;mats[6*i+2]=m.tx;mats[6*
i+3]=m.b;mats[6*i+4]=m.d;mats[6*i+5]=m.ty}texs=worldAlpha.uniforms.samplerSize;for(mats=0;mats<tint;mats++)texs[2*mats]=texArray.elements[mats].width,texs[2*mats+1]=texArray.elements[mats].height;renderer.shader.bind(worldAlpha);drawCalls&&renderer.geometry.bind(geometry);for(drawCalls=0;drawCalls<tint;drawCalls++)renderer.texture.bind(texArray.elements[drawCalls],drawCalls);renderer.geometry.draw(constants.DRAW_MODES.TRIANGLES,size,start)}}_resolveDirectShader(_renderer){_renderer=this.shader;const pluginName=
this.pluginName;_renderer||(DEFAULT_SHADERS[pluginName]||(DEFAULT_SHADERS[pluginName]=new SmoothGraphicsShader(this.shaderSettings)),_renderer=DEFAULT_SHADERS[pluginName]);return _renderer}_calculateBounds(){this.finishPoly();const geometry=this._geometry;if(geometry.graphicsData.length){var {minX,minY,maxX,maxY}=geometry.bounds;this._bounds.addFrame(this.transform,minX,minY,maxX,maxY)}}containsPoint(point){this.worldTransform.applyInverse(point,SmoothGraphics._TEMP_POINT);return this._geometry.containsPoint(SmoothGraphics._TEMP_POINT)}calculateTints(){if(this.batchTint!==
this.tint){this.batchTint=this.tint;const tintRGB=utils.hex2rgb(this.tint,temp);for(let i=0;i<this.batches.length;i++){const batch=this.batches[i];var batchTint=batch._batchRGB;batchTint=(tintRGB[0]*batchTint[0]*255<<16)+(tintRGB[1]*batchTint[1]*255<<8)+(tintRGB[2]*batchTint[2]*255|0);batch._tintRGB=(batchTint>>16)+(batchTint&65280)+((batchTint&255)<<16)}}}calculateVertices(){var wtID=this.transform._worldID;if(this._transformID!==wtID){this._transformID=wtID;var wt=this.transform.worldTransform;
wtID=wt.a;var b=wt.b,c=wt.c,d=wt.d,tx=wt.tx;wt=wt.ty;var data=this._geometry.points,vertexData=this.vertexData,count=0;for(let i=0;i<data.length;i+=2){const x=data[i],y=data[i+1];vertexData[count++]=wtID*x+c*y+tx;vertexData[count++]=d*y+b*x+wt}}}closePath(){const currentPath=this.currentPath;currentPath&&(currentPath.closeStroke=!0);return this}setMatrix(matrix){this._matrix=matrix;return this}beginHole(){this.finishPoly();this._holeMode=!0;return this}endHole(){this.finishPoly();this._holeMode=!1;
return this}destroy(options){this._geometry.refCount--;0===this._geometry.refCount&&this._geometry.dispose();this.currentPath=this._matrix=null;this._lineStyle.destroy();this._lineStyle=null;this._fillStyle.destroy();this.vertexData=this.shader=this._geometry=this._fillStyle=null;this.batches.length=0;this.batches=null;super.destroy(options)}drawStar(x,y,points,radius,innerRadius,rotation=0){return this.drawPolygon(new Star(x,y,points,radius,innerRadius,rotation))}}SmoothGraphics.__initStatic();class Star extends math.Polygon{constructor(x,
y,points,radius,innerRadius,rotation=0){innerRadius=innerRadius||radius/2;rotation=-1*Math.PI/2+rotation;points*=2;const delta=math.PI_2/points,polygon=[];for(let i=0;i<points;i++){const r=i%2?innerRadius:radius,angle=i*delta+rotation;polygon.push(x+r*Math.cos(angle),y+r*Math.sin(angle))}super(polygon)}}class DashLineShader extends SmoothGraphicsShader{constructor(dashParams){const settings={maxStyles:16,maxTextures:1};super(settings,new SmoothGraphicsProgram(settings,void 0,"\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\nuniform float dash;\nuniform float gap;\n\nvoid main(void){\n    float alpha \x3d 1.0;\n    float lineWidth \x3d vDistance.w;\n    if (vType \x3c 0.5) {\n        float left \x3d max(vDistance.x - 0.5, -vDistance.w);\n        float right \x3d min(vDistance.x + 0.5, vDistance.w);\n        float near \x3d vDistance.y - 0.5;\n        float far \x3d min(vDistance.y + 0.5, 0.0);\n        float top \x3d vDistance.z - 0.5;\n        float bottom \x3d min(vDistance.z + 0.5, 0.0);\n        alpha \x3d max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType \x3c 1.5) {\n        float a1 \x3d clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 \x3d clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 \x3d clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 \x3d clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha \x3d a2 * b2 - a1 * b1;\n    } else if (vType \x3c 2.5) {\n        alpha *\x3d max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *\x3d max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *\x3d max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 \x3d sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad \x3d vDistance.w;\n        float left \x3d max(dist2 - 0.5, -rad);\n        float right \x3d min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha \x3d 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    if (dash + gap \x3e 1.0)\n    {\n        float travel \x3d mod(vTravel + gap * 0.5, dash + gap) - (gap * 0.5);\n        float left \x3d max(travel - 0.5, -0.5);\n        float right \x3d min(travel + 0.5, gap + 0.5);\n        alpha *\x3d max(0.0, right - left);\n    }\n\n    vec4 texColor;\n    float textureId \x3d floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor \x3d vColor * texColor * alpha;\n}\n"),
dashParams||{dash:5,gap:8})}}exports.BATCH_POOL=BATCH_POOL;exports.BatchDrawCall=BatchDrawCall;exports.BatchPart=BatchPart;exports.BatchStyleArray=BatchStyleArray;exports.BuildData=BuildData;exports.CircleBuilder=CircleBuilder;exports.DRAW_CALL_POOL=DRAW_CALL_POOL;exports.DashLineShader=DashLineShader;exports.FILL_COMMANDS=FILL_COMMANDS;exports.FillStyle=FillStyle;exports.LineStyle=LineStyle;exports.PolyBuilder=PolyBuilder;exports.RectangleBuilder=RectangleBuilder;exports.RoundedRectangleBuilder=
RoundedRectangleBuilder;exports.SegmentPacker=SegmentPacker;exports.SmoothGraphics=SmoothGraphics;exports.SmoothGraphicsData=SmoothGraphicsData;exports.SmoothGraphicsGeometry=SmoothGraphicsGeometry;exports.SmoothGraphicsProgram=SmoothGraphicsProgram;exports.SmoothGraphicsShader=SmoothGraphicsShader;exports.Star=Star;exports.matrixEquals=matrixEquals;exports.settings=settings$jscomp$0}
//# sourceMappingURL=module$node_modules$$pixi$graphics_smooth$dist$pixi_graphics_smooth.js.map
