{"version":3,"sources":["linked/set.cljc"],"mappings":"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","names":["unused__11779__auto__","self__","G__58997","js/Error","args58991","cljs.core/aclone","this__5327__auto__","writer__5328__auto__","opt__5329__auto__","cljs.core/-write","linked.set/LinkedSet","linked.set/->LinkedSet","linked-map","this","clojure.string.join","cljs.core.map","cljs.core/str","other","_","coll","meta","cljs.core/with-meta","cljs.core/meta","o","cljs.core.assoc","linked.set/empty-linked-set","cljs.core/set?","cljs.core/count","p1__58990#","cljs.core/every?","cljs.core/contains?","cljs.core/hash","cljs.core.into","temp__5720__auto__","s","cljs.core/seq","cljs.core/key","cljs.core/rseq","cljs.core/-count","v","not-found","cljs.core/-contains-key?","cljs.core/-dissoc","k","writer","opts","linked.map/empty-linked-map","linked.set/->linked-set","cljs.core.partial","cljs.core/into","cljs.reader/register-tag-parser!"],"sourcesContent":["(ns linked.set\n  (:require [linked.map :refer [empty-linked-map]]\n            [clojure.string :as string]\n    #?(:cljs [cljs.reader :as reader]))\n  #?(:clj\n     (:import (clojure.lang Counted\n                            IObj\n                            IFn\n                            IHashEq\n                            ILookup\n                            IPersistentCollection\n                            IPersistentSet\n                            IPersistentVector\n                            Reversible\n                            Seqable\n                            SeqIterator)\n              (java.util Set)\n              (java.lang Iterable))))\n\n(declare empty-linked-set)\n\n(deftype LinkedSet [linked-map]\n  #?@(:clj\n      [IPersistentSet\n       (disjoin [_ k]\n         (LinkedSet. (dissoc linked-map k)))\n       (contains [_ k]\n         (contains? linked-map k))\n       (get [this k]\n         (when (.contains this k) k))\n\n       Set\n       (size [this]\n         (.count this))\n\n       Iterable\n       (iterator [this]\n         (SeqIterator. (.seq this)))\n\n       Counted\n\n       IPersistentCollection\n       (count [_]\n         (count linked-map))\n       (cons [this o]\n         (if (contains? linked-map o)\n           this\n           (LinkedSet. (assoc linked-map o nil))))\n       (empty [_]\n         empty-linked-set)\n       (equiv [this other]\n         (or (identical? this other)\n             (and (instance? Set other)\n                  (let [^Set s other]\n                    (and (= (.size this) (.size s))\n                         (every? #(.contains s %) (.seq this)))))))\n       Seqable\n       (seq [_]\n         (when-let [s (seq linked-map)] (map key s)))\n\n       Reversible\n       (rseq [_]\n         (when-let [s (rseq linked-map)] (map key s)))\n\n       IFn\n       (invoke [this k]\n         (get this k))\n\n       IObj\n       (meta [this]\n         (.meta ^IObj linked-map))\n       (withMeta [this m]\n         (LinkedSet. (.withMeta ^IObj linked-map m)))\n\n       IHashEq\n       (hasheq [this] (.hasheq ^IHashEq (into #{} this)))\n\n       Object\n       (toString [this]\n         (str \"[\" (string/join \" \" (map str this)) \"]\"))\n       (hashCode [this]\n         (.hashCode ^Object (into #{} this)))\n       (equals [this other]\n         (.equiv this other))]\n      :cljs\n      [Object\n       (toString [this]\n                 (str \"[\" (string/join \" \" (map str this)) \"]\"))\n       (equiv [this other]\n              (-equiv this other))\n\n       ICloneable\n       (-clone [_] (LinkedSet. linked-map))\n\n       IWithMeta\n       (-with-meta [coll meta] (LinkedSet. (with-meta linked-map meta)))\n\n       IMeta\n       (-meta [coll] (meta linked-map))\n\n       ICollection\n       (-conj [coll o]\n              (LinkedSet. (assoc linked-map o nil)))\n\n       IEmptyableCollection\n       (-empty [coll] (with-meta empty-linked-set meta))\n\n       IEquiv\n       (-equiv [coll other]\n               (and\n                 (set? other)\n                 (== (count coll) (count other))\n                 (every? #(contains? coll %)\n                         other)))\n\n       IHash\n       (-hash [coll] (hash (into #{} coll)))\n\n       ISeqable\n       (-seq [coll] (when-let [s (seq linked-map)] (map key s)))\n\n       IReversible\n       (-rseq [coll] (when-let [s (rseq linked-map)] (map key s)))\n\n       ISequential\n\n       ICounted\n       (-count [coll] (-count linked-map))\n\n       ILookup\n       (-lookup [coll v]\n                (-lookup coll v nil))\n       (-lookup [coll v not-found]\n                (if (-contains-key? linked-map v)\n                  v\n                  not-found))\n\n       ISet\n       (-disjoin [coll v]\n                 (LinkedSet. (-dissoc linked-map v)))\n\n       IFn\n       (-invoke [coll k]\n                (-lookup coll k))\n       (-invoke [coll k not-found]\n                (-lookup coll k not-found))\n\n       ;; IEditableCollection\n\n       IPrintWithWriter\n       (-pr-writer [coll writer opts]\n                   (-write writer (str \"#linked/set \" (into [] coll))))]))\n\n#?(:clj\n   (defmethod print-method LinkedSet [o ^java.io.Writer w]\n     (.write w \"#linked/set \")\n     (print-method (into [] o) w)))\n\n(def ^{:tag LinkedSet} empty-linked-set\n  (LinkedSet. empty-linked-map))\n\n(def ->linked-set (partial into empty-linked-set))\n\n#?(:cljs (reader/register-tag-parser! 'linked/set ->linked-set))\n"]}