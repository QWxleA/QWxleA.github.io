{
"version":3,
"file":"module$node_modules$codemirror$mode$velocity$velocity.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/codemirror/mode/velocity/velocity.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$codemirror$mode$velocity$velocity\"] = function(global,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"velocity\", function() {\n    function parseWords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var keywords = parseWords(\"#end #else #break #stop #[[ #]] \" +\n                              \"#{end} #{else} #{break} #{stop}\");\n    var functions = parseWords(\"#if #elseif #foreach #set #include #parse #macro #define #evaluate \" +\n                               \"#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}\");\n    var specials = parseWords(\"$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent.count $foreach.parent.hasNext $foreach.parent.first $foreach.parent.last $foreach.parent $velocityCount $!bodyContent $bodyContent\");\n    var isOperatorChar = /[+\\-*&%=<>!?:\\/|]/;\n\n    function chain(stream, state, f) {\n        state.tokenize = f;\n        return f(stream, state);\n    }\n    function tokenBase(stream, state) {\n        var beforeParams = state.beforeParams;\n        state.beforeParams = false;\n        var ch = stream.next();\n        // start of unparsed string?\n        if ((ch == \"'\") && !state.inString && state.inParams) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenString(ch));\n        }\n        // start of parsed string?\n        else if ((ch == '\"')) {\n            state.lastTokenWasBuiltin = false;\n            if (state.inString) {\n                state.inString = false;\n                return \"string\";\n            }\n            else if (state.inParams)\n                return chain(stream, state, tokenString(ch));\n        }\n        // is it one of the special signs []{}().,;? Seperator?\n        else if (/[\\[\\]{}\\(\\),;\\.]/.test(ch)) {\n            if (ch == \"(\" && beforeParams)\n                state.inParams = true;\n            else if (ch == \")\") {\n                state.inParams = false;\n                state.lastTokenWasBuiltin = true;\n            }\n            return null;\n        }\n        // start of a number value?\n        else if (/\\d/.test(ch)) {\n            state.lastTokenWasBuiltin = false;\n            stream.eatWhile(/[\\w\\.]/);\n            return \"number\";\n        }\n        // multi line comment?\n        else if (ch == \"#\" && stream.eat(\"*\")) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenComment);\n        }\n        // unparsed content?\n        else if (ch == \"#\" && stream.match(/ *\\[ *\\[/)) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenUnparsed);\n        }\n        // single line comment?\n        else if (ch == \"#\" && stream.eat(\"#\")) {\n            state.lastTokenWasBuiltin = false;\n            stream.skipToEnd();\n            return \"comment\";\n        }\n        // variable?\n        else if (ch == \"$\") {\n            stream.eatWhile(/[\\w\\d\\$_\\.{}-]/);\n            // is it one of the specials?\n            if (specials && specials.propertyIsEnumerable(stream.current())) {\n                return \"keyword\";\n            }\n            else {\n                state.lastTokenWasBuiltin = true;\n                state.beforeParams = true;\n                return \"builtin\";\n            }\n        }\n        // is it a operator?\n        else if (isOperatorChar.test(ch)) {\n            state.lastTokenWasBuiltin = false;\n            stream.eatWhile(isOperatorChar);\n            return \"operator\";\n        }\n        else {\n            // get the whole word\n            stream.eatWhile(/[\\w\\$_{}@]/);\n            var word = stream.current();\n            // is it one of the listed keywords?\n            if (keywords && keywords.propertyIsEnumerable(word))\n                return \"keyword\";\n            // is it one of the listed functions?\n            if (functions && functions.propertyIsEnumerable(word) ||\n                    (stream.current().match(/^#@?[a-z0-9_]+ *$/i) && stream.peek()==\"(\") &&\n                     !(functions && functions.propertyIsEnumerable(word.toLowerCase()))) {\n                state.beforeParams = true;\n                state.lastTokenWasBuiltin = false;\n                return \"keyword\";\n            }\n            if (state.inString) {\n                state.lastTokenWasBuiltin = false;\n                return \"string\";\n            }\n            if (stream.pos > word.length && stream.string.charAt(stream.pos-word.length-1)==\".\" && state.lastTokenWasBuiltin)\n                return \"builtin\";\n            // default: just a \"word\"\n            state.lastTokenWasBuiltin = false;\n            return null;\n        }\n    }\n\n    function tokenString(quote) {\n        return function(stream, state) {\n            var escaped = false, next, end = false;\n            while ((next = stream.next()) != null) {\n                if ((next == quote) && !escaped) {\n                    end = true;\n                    break;\n                }\n                if (quote=='\"' && stream.peek() == '$' && !escaped) {\n                    state.inString = true;\n                    end = true;\n                    break;\n                }\n                escaped = !escaped && next == \"\\\\\";\n            }\n            if (end) state.tokenize = tokenBase;\n            return \"string\";\n        };\n    }\n\n    function tokenComment(stream, state) {\n        var maybeEnd = false, ch;\n        while (ch = stream.next()) {\n            if (ch == \"#\" && maybeEnd) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            maybeEnd = (ch == \"*\");\n        }\n        return \"comment\";\n    }\n\n    function tokenUnparsed(stream, state) {\n        var maybeEnd = 0, ch;\n        while (ch = stream.next()) {\n            if (ch == \"#\" && maybeEnd == 2) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            if (ch == \"]\")\n                maybeEnd++;\n            else if (ch != \" \")\n                maybeEnd = 0;\n        }\n        return \"meta\";\n    }\n    // Interface\n\n    return {\n        startState: function() {\n            return {\n                tokenize: tokenBase,\n                beforeParams: false,\n                inParams: false,\n                inString: false,\n                lastTokenWasBuiltin: false\n            };\n        },\n\n        token: function(stream, state) {\n            if (stream.eatSpace()) return null;\n            return state.tokenize(stream, state);\n        },\n        blockCommentStart: \"#*\",\n        blockCommentEnd: \"*#\",\n        lineComment: \"##\",\n        fold: \"velocity\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/velocity\", \"velocity\");\n\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","mod","define","amd","CodeMirror","defineMode","parseWords","str","obj","words","split","i","length","chain","stream","state","f","tokenize","tokenBase","beforeParams","ch","next","inString","inParams","lastTokenWasBuiltin","tokenString","test","eatWhile","eat","tokenComment","match","tokenUnparsed","skipToEnd","specials","propertyIsEnumerable","current","isOperatorChar","word","keywords","functions","peek","toLowerCase","pos","string","charAt","quote","escaped","end","maybeEnd","startState","token","eatSpace","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME"]
}
