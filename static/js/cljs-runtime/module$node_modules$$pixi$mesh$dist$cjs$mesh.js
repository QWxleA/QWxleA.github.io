shadow$provide.module$node_modules$$pixi$mesh$dist$cjs$mesh=function(global,require,module,exports){function __extends(d,b){function __(){this.constructor=d}extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}Object.defineProperty(exports,"__esModule",{value:!0});var core=require("module$node_modules$$pixi$core$dist$cjs$core"),math=require("module$node_modules$$pixi$math$dist$cjs$math"),constants=require("module$node_modules$$pixi$constants$dist$cjs$constants");
global=require("module$node_modules$$pixi$display$dist$cjs$display");var settings=require("module$node_modules$$pixi$settings$dist$cjs$settings"),utils=require("module$node_modules$$pixi$utils$dist$cjs$utils"),extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)},MeshBatchUvs=function(){function MeshBatchUvs(uvBuffer,
uvMatrix){this.uvBuffer=uvBuffer;this.uvMatrix=uvMatrix;this.data=null;this._textureUpdateId=this._bufferUpdateId=-1;this._updateID=0}MeshBatchUvs.prototype.update=function(forceUpdate){if(forceUpdate||this._bufferUpdateId!==this.uvBuffer._updateID||this._textureUpdateId!==this.uvMatrix._updateID)this._bufferUpdateId=this.uvBuffer._updateID,this._textureUpdateId=this.uvMatrix._updateID,forceUpdate=this.uvBuffer.data,this.data&&this.data.length===forceUpdate.length||(this.data=new Float32Array(forceUpdate.length)),
this.uvMatrix.multiplyUvs(forceUpdate,this.data),this._updateID++};return MeshBatchUvs}(),tempPoint=new math.Point,tempPolygon=new math.Polygon;require=function(_super){function Mesh(geometry,shader,state,drawMode){void 0===drawMode&&(drawMode=constants.DRAW_MODES.TRIANGLES);var _this=_super.call(this)||this;_this.geometry=geometry;_this.shader=shader;_this.state=state||core.State.for2d();_this.drawMode=drawMode;_this.start=0;_this.size=0;_this.uvs=null;_this.indices=null;_this.vertexData=new Float32Array(1);
_this.vertexDirty=-1;_this._transformID=-1;_this._roundPixels=settings.settings.ROUND_PIXELS;_this.batchUvs=null;return _this}__extends(Mesh,_super);Object.defineProperty(Mesh.prototype,"geometry",{get:function(){return this._geometry},set:function(value){this._geometry!==value&&(this._geometry&&(this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose()),(this._geometry=value)&&this._geometry.refCount++,this.vertexDirty=-1)},enumerable:!1,configurable:!0});Object.defineProperty(Mesh.prototype,
"uvBuffer",{get:function(){return this.geometry.buffers[1]},enumerable:!1,configurable:!0});Object.defineProperty(Mesh.prototype,"verticesBuffer",{get:function(){return this.geometry.buffers[0]},enumerable:!1,configurable:!0});Object.defineProperty(Mesh.prototype,"material",{get:function(){return this.shader},set:function(value){this.shader=value},enumerable:!1,configurable:!0});Object.defineProperty(Mesh.prototype,"blendMode",{get:function(){return this.state.blendMode},set:function(value){this.state.blendMode=
value},enumerable:!1,configurable:!0});Object.defineProperty(Mesh.prototype,"roundPixels",{get:function(){return this._roundPixels},set:function(value){this._roundPixels!==value&&(this._transformID=-1);this._roundPixels=value},enumerable:!1,configurable:!0});Object.defineProperty(Mesh.prototype,"tint",{get:function(){return"tint"in this.shader?this.shader.tint:null},set:function(value){this.shader.tint=value},enumerable:!1,configurable:!0});Object.defineProperty(Mesh.prototype,"texture",{get:function(){return"texture"in
this.shader?this.shader.texture:null},set:function(value){this.shader.texture=value},enumerable:!1,configurable:!0});Mesh.prototype._render=function(renderer){var vertices=this.geometry.buffers[0].data;this.shader.batchable&&this.drawMode===constants.DRAW_MODES.TRIANGLES&&vertices.length<2*Mesh.BATCHABLE_SIZE?this._renderToBatch(renderer):this._renderDefault(renderer)};Mesh.prototype._renderDefault=function(renderer){var shader=this.shader;shader.alpha=this.worldAlpha;shader.update&&shader.update();
renderer.batch.flush();shader.uniforms.translationMatrix=this.transform.worldTransform.toArray(!0);renderer.shader.bind(shader);renderer.state.set(this.state);renderer.geometry.bind(this.geometry,shader);renderer.geometry.draw(this.drawMode,this.size,this.start,this.geometry.instanceCount)};Mesh.prototype._renderToBatch=function(renderer){var geometry=this.geometry,shader=this.shader;shader.uvMatrix&&(shader.uvMatrix.update(),this.calculateUvs());this.calculateVertices();this.indices=geometry.indexBuffer.data;
this._tintRGB=shader._tintRGB;this._texture=shader.texture;geometry=this.material.pluginName;renderer.batch.setObjectRenderer(renderer.plugins[geometry]);renderer.plugins[geometry].render(this)};Mesh.prototype.calculateVertices=function(){var verticesBuffer=this.geometry.buffers[0],vertices=verticesBuffer.data;verticesBuffer=verticesBuffer._updateID;if(verticesBuffer!==this.vertexDirty||this._transformID!==this.transform._worldID){this._transformID=this.transform._worldID;this.vertexData.length!==
vertices.length&&(this.vertexData=new Float32Array(vertices.length));var wt=this.transform.worldTransform,a=wt.a,b=wt.b,c=wt.c,d=wt.d,tx=wt.tx,ty=wt.ty;wt=this.vertexData;for(var i=0;i<wt.length/2;i++){var x=vertices[2*i],y=vertices[2*i+1];wt[2*i]=a*x+c*y+tx;wt[2*i+1]=b*x+d*y+ty}if(this._roundPixels)for(vertices=settings.settings.RESOLUTION,i=0;i<wt.length;++i)wt[i]=Math.round((wt[i]*vertices|0)/vertices);this.vertexDirty=verticesBuffer}};Mesh.prototype.calculateUvs=function(){var geomUvs=this.geometry.buffers[1],
shader=this.shader;shader.uvMatrix.isSimple?this.uvs=geomUvs.data:(this.batchUvs||(this.batchUvs=new MeshBatchUvs(geomUvs,shader.uvMatrix)),this.batchUvs.update(),this.uvs=this.batchUvs.data)};Mesh.prototype._calculateBounds=function(){this.calculateVertices();this._bounds.addVertexData(this.vertexData,0,this.vertexData.length)};Mesh.prototype.containsPoint=function(point){if(!this.getBounds().contains(point.x,point.y))return!1;this.worldTransform.applyInverse(point,tempPoint);point=this.geometry.getBuffer("aVertexPosition").data;
for(var points=tempPolygon.points,indices=this.geometry.getIndex().data,len=indices.length,step=4===this.drawMode?3:1,i=0;i+2<len;i+=step){var ind0=2*indices[i],ind1=2*indices[i+1],ind2=2*indices[i+2];points[0]=point[ind0];points[1]=point[ind0+1];points[2]=point[ind1];points[3]=point[ind1+1];points[4]=point[ind2];points[5]=point[ind2+1];if(tempPolygon.contains(tempPoint.x,tempPoint.y))return!0}return!1};Mesh.prototype.destroy=function(options){_super.prototype.destroy.call(this,options);this._cachedTexture&&
(this._cachedTexture.destroy(),this._cachedTexture=null);this.vertexData=this.indices=this.uvs=this.state=this.shader=this.geometry=null};Mesh.BATCHABLE_SIZE=100;return Mesh}(global.Container);global=function(_super){function MeshMaterial(uSampler,options){var _this={uSampler,alpha:1,uTextureMatrix:math.Matrix.IDENTITY,uColor:new Float32Array([1,1,1,1])};options=Object.assign({tint:16777215,alpha:1,pluginName:"batch"},options);options.uniforms&&Object.assign(_this,options.uniforms);_this=_super.call(this,
options.program||core.Program.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position \x3d vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord \x3d (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor \x3d texture2D(uSampler, vTextureCoord) * uColor;\n}\n"),
_this)||this;_this._colorDirty=!1;_this.uvMatrix=new core.TextureMatrix(uSampler);_this.batchable=void 0===options.program;_this.pluginName=options.pluginName;_this.tint=options.tint;_this.alpha=options.alpha;return _this}__extends(MeshMaterial,_super);Object.defineProperty(MeshMaterial.prototype,"texture",{get:function(){return this.uniforms.uSampler},set:function(value){this.uniforms.uSampler!==value&&(this.uniforms.uSampler=value,this.uvMatrix.texture=value)},enumerable:!1,configurable:!0});Object.defineProperty(MeshMaterial.prototype,
"alpha",{get:function(){return this._alpha},set:function(value){value!==this._alpha&&(this._alpha=value,this._colorDirty=!0)},enumerable:!1,configurable:!0});Object.defineProperty(MeshMaterial.prototype,"tint",{get:function(){return this._tint},set:function(value){value!==this._tint&&(this._tint=value,this._tintRGB=(value>>16)+(value&65280)+((value&255)<<16),this._colorDirty=!0)},enumerable:!1,configurable:!0});MeshMaterial.prototype.update=function(){this._colorDirty&&(this._colorDirty=!1,utils.premultiplyTintToRgba(this._tint,
this._alpha,this.uniforms.uColor,this.texture.baseTexture.alphaMode));this.uvMatrix.update()&&(this.uniforms.uTextureMatrix=this.uvMatrix.mapCoord)};return MeshMaterial}(core.Shader);module=function(_super){function MeshGeometry(vertices,uvs,index){var _this=_super.call(this)||this;vertices=new core.Buffer(vertices);uvs=new core.Buffer(uvs,!0);index=new core.Buffer(index,!0,!0);_this.addAttribute("aVertexPosition",vertices,2,!1,constants.TYPES.FLOAT).addAttribute("aTextureCoord",uvs,2,!1,constants.TYPES.FLOAT).addIndex(index);
_this._updateId=-1;return _this}__extends(MeshGeometry,_super);Object.defineProperty(MeshGeometry.prototype,"vertexDirtyId",{get:function(){return this.buffers[0]._updateID},enumerable:!1,configurable:!0});return MeshGeometry}(core.Geometry);exports.Mesh=require;exports.MeshBatchUvs=MeshBatchUvs;exports.MeshGeometry=module;exports.MeshMaterial=global}
//# sourceMappingURL=module$node_modules$$pixi$mesh$dist$cjs$mesh.js.map
