{
"version":3,
"file":"module$node_modules$jszip$lib$generate$index.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,4CAAA,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzG,IAAIC,aAAeH,OAAA,CAAQ,4CAAR,CAAnB,CACII,cAAgBJ,OAAA,CAAQ,sDAAR,CAwBpBE,QAAQG,CAAAA,cAAR,CAAyBC,QAAS,CAACC,GAAD,CAAMC,OAAN,CAAeC,OAAf,CAAwB,CAEtD,IAAIC,cAAgB,IAAIN,aAAJ,CAAkBI,OAAQG,CAAAA,WAA1B,CAAuCF,OAAvC,CAAgDD,OAAQI,CAAAA,QAAxD,CAAkEJ,OAAQK,CAAAA,cAA1E,CAApB,CACIC,aAAe,CACnB,IAAI,CAEAP,GAAIQ,CAAAA,OAAJ,CAAY,QAAS,CAACC,YAAD,CAAeC,IAAf,CAAqB,CACtCH,YAAA,EArBR,KAAII;AAsBqCD,IAAKT,CAAAA,OAAQW,CAAAA,WAtBlDD,EAsB+DV,OAAQW,CAAAA,WAtB3E,CACIA,YAAchB,YAAA,CAAae,eAAb,CAClB,IAAI,CAACC,WAAL,CACI,KAAUC,MAAJ,CAAUF,eAAV,CAA4B,sCAA5B,CAAN,CAqBQG,eAAAA,CAAMJ,IAAKI,CAAAA,GAAf,KAAoBC,KAAOL,IAAKK,CAAAA,IAEhCL,KAAKM,CAAAA,eAAL,CArBDJ,WAqBC,CAHyBF,IAAKT,CAAAA,OAAQgB,CAAAA,kBAGtC,EAH4DhB,OAAQgB,CAAAA,kBAGpE,EAH0F,EAG1F,CACCC,CAAAA,cADD,CACgB,MADhB,CACwB,CACpBC,KAAOV,YADa,CAEpBK,IAAMA,eAFc,CAGbC,IAHa,CAIpBb,QAAUQ,IAAKR,CAAAA,OAAfA,EAA0B,EAJN,CAKpBkB,gBAAkBV,IAAKU,CAAAA,eALH,CAMpBC,eAAiBX,IAAKW,CAAAA,cANF,CADxB,CASCC,CAAAA,IATD,CASMnB,aATN,CANsC,CAA1C,CAiBA;AAAAA,aAAcI,CAAAA,YAAd,CAA6BA,YAnB7B,CAoBF,MAAOgB,CAAP,CAAU,CACRpB,aAAcqB,CAAAA,KAAd,CAAoBD,CAApB,CADQ,CAIZ,MAAOpB,cA5B+C,CA5B+C;",
"sources":["node_modules/jszip/lib/generate/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$jszip$lib$generate$index\"] = function(global,require,module,exports) {\n'use strict';\n\nvar compressions = require('../compressions');\nvar ZipFileWorker = require('./ZipFileWorker');\n\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\nvar getCompression = function (fileCompression, zipCompression) {\n\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\nexports.generateWorker = function (zip, options, comment) {\n\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n\n        zip.forEach(function (relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n\n            file._compressWorker(compression, compressionOptions)\n            .withStreamInfo(\"file\", {\n                name : relativePath,\n                dir : dir,\n                date : date,\n                comment : file.comment || \"\",\n                unixPermissions : file.unixPermissions,\n                dosPermissions : file.dosPermissions\n            })\n            .pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n\n    return zipFileWorker;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","compressions","ZipFileWorker","generateWorker","exports.generateWorker","zip","options","comment","zipFileWorker","streamFiles","platform","encodeFileName","entriesCount","forEach","relativePath","file","compressionName","compression","Error","dir","date","_compressWorker","compressionOptions","withStreamInfo","name","unixPermissions","dosPermissions","pipe","e","error"]
}
