{
"version":3,
"file":"module$node_modules$capacitor_voice_recorder$dist$plugin_cjs.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/capacitor-voice-recorder/dist/plugin.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$capacitor_voice_recorder$dist$plugin_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar core = require('@capacitor/core');\nvar getBlobDuration = require('get-blob-duration');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar getBlobDuration__default = /*#__PURE__*/_interopDefaultLegacy(getBlobDuration);\n\nconst VoiceRecorder = core.registerPlugin('VoiceRecorder', {\n    web: () => Promise.resolve().then(function () { return web; }).then(m => new m.VoiceRecorderWeb()),\n});\n\nconst successResponse = () => ({ value: true });\nconst failureResponse = () => ({ value: false });\nconst missingPermissionError = () => new Error('MISSING_PERMISSION');\nconst alreadyRecordingError = () => new Error('ALREADY_RECORDING');\nconst deviceCannotVoiceRecordError = () => new Error('DEVICE_CANNOT_VOICE_RECORD');\nconst failedToRecordError = () => new Error('FAILED_TO_RECORD');\nconst recordingHasNotStartedError = () => new Error('RECORDING_HAS_NOT_STARTED');\nconst failedToFetchRecordingError = () => new Error('FAILED_TO_FETCH_RECORDING');\nconst couldNotQueryPermissionStatusError = () => new Error('COULD_NOT_QUERY_PERMISSION_STATUS');\n\n// these mime types will be checked one by one in order until one of them is found to be supported by the current browser\nconst possibleMimeTypes = ['audio/aac', 'audio/webm;codecs=opus', 'audio/mp4', 'audio/webm', 'audio/ogg;codecs=opus'];\nconst neverResolvingPromise = () => new Promise(() => undefined);\nclass VoiceRecorderImpl {\n    constructor() {\n        this.mediaRecorder = null;\n        this.chunks = [];\n        this.pendingResult = neverResolvingPromise();\n    }\n    static async canDeviceVoiceRecord() {\n        var _a;\n        if (((_a = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) == null || VoiceRecorderImpl.getSupportedMimeType() == null) {\n            return failureResponse();\n        }\n        else {\n            return successResponse();\n        }\n    }\n    async startRecording() {\n        if (this.mediaRecorder != null) {\n            throw alreadyRecordingError();\n        }\n        const deviceCanRecord = await VoiceRecorderImpl.canDeviceVoiceRecord();\n        if (!deviceCanRecord.value) {\n            throw deviceCannotVoiceRecordError();\n        }\n        const havingPermission = await VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => successResponse());\n        if (!havingPermission.value) {\n            throw missingPermissionError();\n        }\n        navigator.mediaDevices.getUserMedia({ audio: true })\n            .then(this.onSuccessfullyStartedRecording.bind(this))\n            .catch(this.onFailedToStartRecording.bind(this));\n        return successResponse();\n    }\n    async stopRecording() {\n        if (this.mediaRecorder == null) {\n            throw recordingHasNotStartedError();\n        }\n        try {\n            this.mediaRecorder.stop();\n            return this.pendingResult;\n        }\n        catch (ignore) {\n            throw failedToFetchRecordingError();\n        }\n        finally {\n            this.prepareInstanceForNextOperation();\n        }\n    }\n    static async hasAudioRecordingPermission() {\n        return navigator.permissions.query({ name: 'microphone' })\n            .then(result => ({ value: result.state === 'granted' }))\n            .catch(() => { throw couldNotQueryPermissionStatusError(); });\n    }\n    static async requestAudioRecordingPermission() {\n        const havingPermission = await VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => failureResponse());\n        if (havingPermission.value) {\n            return successResponse();\n        }\n        return navigator.mediaDevices.getUserMedia({ audio: true })\n            .then(() => successResponse())\n            .catch(() => failureResponse());\n    }\n    pauseRecording() {\n        if (this.mediaRecorder == null) {\n            throw recordingHasNotStartedError();\n        }\n        else if (this.mediaRecorder.state === 'recording') {\n            this.mediaRecorder.pause();\n            return Promise.resolve(successResponse());\n        }\n        else {\n            return Promise.resolve(failureResponse());\n        }\n    }\n    resumeRecording() {\n        if (this.mediaRecorder == null) {\n            throw recordingHasNotStartedError();\n        }\n        else if (this.mediaRecorder.state === 'paused') {\n            this.mediaRecorder.resume();\n            return Promise.resolve(successResponse());\n        }\n        else {\n            return Promise.resolve(failureResponse());\n        }\n    }\n    getCurrentStatus() {\n        if (this.mediaRecorder == null) {\n            return Promise.resolve({ status: 'NONE' });\n        }\n        else if (this.mediaRecorder.state === 'recording') {\n            return Promise.resolve({ status: 'RECORDING' });\n        }\n        else if (this.mediaRecorder.state === 'paused') {\n            return Promise.resolve({ status: 'PAUSED' });\n        }\n        else {\n            return Promise.resolve({ status: 'NONE' });\n        }\n    }\n    static getSupportedMimeType() {\n        if ((MediaRecorder === null || MediaRecorder === void 0 ? void 0 : MediaRecorder.isTypeSupported) == null)\n            return null;\n        const foundSupportedType = possibleMimeTypes.find(type => MediaRecorder.isTypeSupported(type));\n        return foundSupportedType !== null && foundSupportedType !== void 0 ? foundSupportedType : null;\n    }\n    onSuccessfullyStartedRecording(stream) {\n        this.pendingResult = new Promise((resolve, reject) => {\n            this.mediaRecorder = new MediaRecorder(stream);\n            this.mediaRecorder.onerror = () => {\n                reject(failedToRecordError());\n                this.prepareInstanceForNextOperation();\n            };\n            this.mediaRecorder.onstop = async () => {\n                const mimeType = VoiceRecorderImpl.getSupportedMimeType();\n                if (mimeType == null) {\n                    reject(failedToFetchRecordingError());\n                }\n                else {\n                    const blobVoiceRecording = new Blob(this.chunks, { 'type': mimeType });\n                    const recordDataBase64 = await VoiceRecorderImpl.blobToBase64(blobVoiceRecording);\n                    const recordingDuration = await getBlobDuration__default['default'](blobVoiceRecording);\n                    this.prepareInstanceForNextOperation();\n                    resolve({ value: { recordDataBase64, mimeType, msDuration: recordingDuration * 1000 } });\n                }\n            };\n            this.mediaRecorder.ondataavailable = (event) => this.chunks.push(event.data);\n            this.mediaRecorder.start();\n        });\n    }\n    onFailedToStartRecording() {\n        this.prepareInstanceForNextOperation();\n        throw failedToRecordError();\n    }\n    static blobToBase64(blob) {\n        return new Promise(resolve => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve(String(reader.result));\n            reader.readAsDataURL(blob);\n        });\n    }\n    prepareInstanceForNextOperation() {\n        if (this.mediaRecorder != null && this.mediaRecorder.state === 'recording') {\n            try {\n                this.mediaRecorder.stop();\n            }\n            catch (ignore) { }\n        }\n        this.pendingResult = neverResolvingPromise();\n        this.mediaRecorder = null;\n        this.chunks = [];\n    }\n}\n\nclass VoiceRecorderWeb extends core.WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.voiceRecorderInstance = new VoiceRecorderImpl();\n    }\n    canDeviceVoiceRecord() {\n        return VoiceRecorderImpl.canDeviceVoiceRecord();\n    }\n    hasAudioRecordingPermission() {\n        return VoiceRecorderImpl.hasAudioRecordingPermission();\n    }\n    requestAudioRecordingPermission() {\n        return VoiceRecorderImpl.requestAudioRecordingPermission();\n    }\n    startRecording() {\n        return this.voiceRecorderInstance.startRecording();\n    }\n    stopRecording() {\n        return this.voiceRecorderInstance.stopRecording();\n    }\n    pauseRecording() {\n        return this.voiceRecorderInstance.pauseRecording();\n    }\n    resumeRecording() {\n        return this.voiceRecorderInstance.resumeRecording();\n    }\n    getCurrentStatus() {\n        return this.voiceRecorderInstance.getCurrentStatus();\n    }\n}\n\nvar web = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    VoiceRecorderWeb: VoiceRecorderWeb\n});\n\nexports.VoiceRecorder = VoiceRecorder;\n//# sourceMappingURL=plugin.cjs.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","core","getBlobDuration__default","getBlobDuration","VoiceRecorder","registerPlugin","web","Promise","resolve","then","m","VoiceRecorderWeb","recordingHasNotStartedError","Error","possibleMimeTypes","neverResolvingPromise","undefined","VoiceRecorderImpl","constructor","mediaRecorder","chunks","pendingResult","canDeviceVoiceRecord","_a","navigator","mediaDevices","getUserMedia","getSupportedMimeType","startRecording","deviceCanRecord","havingPermission","hasAudioRecordingPermission","catch","audio","onSuccessfullyStartedRecording","bind","onFailedToStartRecording","stopRecording","stop","ignore","prepareInstanceForNextOperation","permissions","query","name","result","state","requestAudioRecordingPermission","pauseRecording","pause","resumeRecording","resume","getCurrentStatus","status","MediaRecorder","isTypeSupported","foundSupportedType","find","type","stream","reject","onerror","this.mediaRecorder.onerror","onstop","this.mediaRecorder.onstop","mimeType","blobVoiceRecording","Blob","recordDataBase64","blobToBase64","recordingDuration","msDuration","ondataavailable","event","this.mediaRecorder.ondataavailable","push","data","start","blob","reader","FileReader","onloadend","reader.onloadend","String","readAsDataURL","WebPlugin","arguments","voiceRecorderInstance","freeze","__proto__"]
}
