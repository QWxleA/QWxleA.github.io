{"version":3,"sources":["borkdude/rewrite_edn/impl.cljc"],"mappings":"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","names":["borkdude.rewrite-edn.impl/maybe-right","zloc","rewrite-cljc.zip/rightmost?","rewrite-cljc.zip/right","borkdude.rewrite-edn.impl/skip-right","rewrite-cljc.zip/skip","rewrite-cljc.node/whitespace-or-comment?","rewrite-cljc.zip/node","cljs.core._EQ_","rewrite-cljc.zip/tag","borkdude.rewrite-edn.impl/indent","key-count","first-key-loc","current-loc","cljs.core/meta","cljs.core.not_EQ_","rewrite_cljc.zip.insert_space_right","rewrite_cljc.zip.insert_newline_right","borkdude.rewrite-edn.impl/assoc","forms","k","v","rewrite_cljc.zip.edn","t","cljs.core/contains?","node","nil?","rewrite-cljc.node/tag","rewrite-cljc.node/sexpr","rewrite-cljc.zip/replace","rewrite-cljc.node/coerce","empty?","cljs.core/count","rewrite-cljc.zip/append-child","rewrite-cljc.zip/root","rewrite-cljc.zip/down","temp__5720__auto__","first-key","rewrite-cljc.zip/insert-right","current-k","rewrite-cljc.zip/sexpr","borkdude.rewrite-edn.impl/update","f","G__95138","G__95139","G__95140","G__95142","borkdude.rewrite-edn.impl/update-in","keys","cljs.core/first","p1__95143#","G__95145","G__95146","G__95147","cljs.core/rest","borkdude.rewrite-edn.impl/assoc-in","p1__95148#","G__95149","G__95150","G__95151","borkdude.rewrite-edn.impl/map-keys","cljs.core/not","rewrite-cljc.zip/rightmost","new-key","G__95153"],"sourcesContent":["(ns borkdude.rewrite-edn.impl\n  (:refer-clojure :exclude [assoc update assoc-in update-in])\n  (:require [rewrite-cljc.node :as node]\n            [rewrite-cljc.zip :as z]))\n\n(defn maybe-right [zloc]\n  (if (z/rightmost? zloc)\n    zloc\n    (z/right zloc)))\n\n(defn skip-right [zloc]\n  (z/skip z/right\n          (fn [zloc]\n            (and\n             (not (z/rightmost? zloc))\n             (or (node/whitespace-or-comment? (z/node zloc))\n                 (= :uneval (z/tag zloc)))))\n          zloc))\n\n(defn indent [zloc key-count first-key-loc]\n  (let [current-loc (meta (z/node zloc))]\n    (if (or (= 1 key-count)\n            (not= (:row first-key-loc) (:row current-loc)))\n      (let [zloc (-> zloc\n                     (z/insert-space-right (dec (dec (:col first-key-loc))))\n                     z/insert-newline-right)]\n        zloc)\n      zloc)))\n\n(defn assoc\n  [forms k v]\n  (let [zloc (z/edn forms)\n        zloc (z/skip z/right (fn [zloc]\n                               (let [t (z/tag zloc)]\n                                 (not (contains? #{:token :map} t))))\n                     zloc)\n        node (z/node zloc)\n        nil? (and (identical? :token (node/tag node))\n                  (nil? (node/sexpr node)))\n        zloc (if nil?\n               (z/replace zloc (node/coerce {}))\n               zloc)\n        empty? (or nil? (zero? (count (:children (z/node zloc)))))]\n    (if empty?\n      (-> zloc\n          (z/append-child (node/coerce k))\n          (z/append-child (node/coerce v))\n          (z/root))\n      (let [zloc (z/down zloc)\n            zloc (skip-right zloc)\n            ;; the location of the first key:\n            first-key-loc (when-let [first-key (z/node zloc)]\n                            (meta first-key))]\n        (loop [key-count 0\n               zloc zloc]\n          (if (z/rightmost? zloc)\n            (-> zloc\n                (z/insert-right (node/coerce k))\n                (indent key-count first-key-loc)\n                (z/right)\n                (z/insert-right (node/coerce v))\n                (z/root))\n            (let [current-k (z/sexpr zloc)]\n              (if (= current-k k)\n                (let [zloc (-> zloc (z/right) (skip-right))\n                      zloc (z/replace zloc (node/coerce v))]\n                  (z/root zloc))\n                (recur\n                 (inc key-count)\n                 (-> zloc\n                     ;; move over value to next key\n                     (skip-right)\n                     (z/right)\n                     (skip-right)))))))))))\n\n(defn update [forms k f]\n  (let [zloc (z/edn forms)\n        zloc (z/skip z/right (fn [zloc]\n                               (let [t (z/tag zloc)]\n                                 (not (contains? #{:token :map} t)))) zloc)\n        node (z/node zloc)\n        nil? (and (identical? :token (node/tag node))\n                  (nil? (node/sexpr node)))\n        zloc (if nil?\n               (z/replace zloc (node/coerce {}))\n               zloc)\n        empty? (or nil? (zero? (count (:children (z/node zloc)))))]\n    (if empty?\n      (-> zloc\n          (z/append-child (node/coerce k))\n          (z/append-child (node/coerce nil))\n          (z/root)\n          (update k f))\n      (let [zloc (z/down zloc)\n            zloc (skip-right zloc)]\n        (loop [zloc zloc]\n          (if (z/rightmost? zloc)\n            (-> zloc\n                (z/insert-right (node/coerce k))\n                (z/right)\n                (z/insert-right (f nil))\n                (z/root))\n            (let [current-k (z/sexpr zloc)]\n              (if (= current-k k)\n                (let [zloc (-> zloc (z/right) (skip-right))\n                      zloc (z/replace zloc (node/coerce (f (z/node zloc))))]\n                  (z/root zloc))\n                (recur (-> zloc\n                           ;; move over value to next key\n                           (skip-right)\n                           (z/right)\n                           (skip-right)))))))))))\n\n(defn update-in [forms keys f]\n  (if (= 1 (count keys))\n    (update forms (first keys) f)\n    (update forms (first keys) #(update-in % (rest keys) f))))\n\n(defn assoc-in [forms keys v]\n  (if (= 1 (count keys))\n    (assoc forms (first keys) v)\n    (update forms (first keys) #(assoc-in % (rest keys) v))))\n\n(defn map-keys [f forms]\n  (let [zloc (z/edn forms)\n        zloc (if (= :map (z/tag zloc))\n               zloc\n               (z/skip z/right (fn [zloc]\n                                 (and (not (z/rightmost zloc))\n                                      (not= :map (z/tag zloc)))) zloc))\n        zloc (z/down zloc)\n        zloc (skip-right zloc)]\n    (loop [zloc zloc]\n      (if (z/rightmost? zloc)\n        (z/root zloc)\n        (let [zloc (let [new-key (node/coerce (f (z/sexpr zloc)))]\n                     (-> (z/replace zloc new-key)\n                         z/right))]\n          (recur (-> zloc\n                     ;; move over value to next key\n                     (skip-right)\n                     maybe-right\n                     (skip-right))))))))\n"]}