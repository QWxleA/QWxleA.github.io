{
"version":3,
"file":"module$node_modules$jszip$lib$utf8.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/jszip/lib/utf8.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$jszip$lib$utf8\"] = function(global,require,module,exports) {\n'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodejsUtils = require('./nodejsUtils');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    return buf2string(buf);\n};\n\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\nfunction Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8DecodeWorker.prototype.processChunk = function (chunk) {\n\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if(support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n\n    this.push({\n        data : exports.utf8decode(usableData),\n        meta : chunk.meta\n    });\n};\n\n/**\n * @see GenericWorker.flush\n */\nUtf8DecodeWorker.prototype.flush = function () {\n    if(this.leftOver && this.leftOver.length) {\n        this.push({\n            data : exports.utf8decode(this.leftOver),\n            meta : {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\nfunction Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8EncodeWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : exports.utf8encode(chunk.data),\n        meta : chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Utf8DecodeWorker","GenericWorker","call","leftOver","Utf8EncodeWorker","utils","support","nodejsUtils","_utf8len","Array","i","utf8encode","exports.utf8encode","str","nodebuffer","newBufferFrom","m_pos","str_len","length","buf_len","c","charCodeAt","c2","buf","uint8array","Uint8Array","utf8decode","exports.utf8decode","transformTo","toString","out","len","utf16buf","c_len","subarray","applyFromCharCode","inherits","prototype","processChunk","Utf8DecodeWorker.prototype.processChunk","chunk","data","previousData","set","concat","pos","max","usableData","nextBoundary","slice","push","meta","flush","Utf8DecodeWorker.prototype.flush","Utf8EncodeWorker.prototype.processChunk"]
}
