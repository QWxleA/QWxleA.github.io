{"version":3,"sources":["rewrite_cljc/zip/seqz.cljc"],"mappings":"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","names":["rewrite-cljc.zip.seqz/seq?","zloc","cljs.core/contains?","rewrite-cljc.zip.base/tag","rewrite-cljc.zip.seqz/list?","cljs.core._EQ_","rewrite-cljc.zip.seqz/vector?","rewrite-cljc.zip.seqz/set?","rewrite-cljc.zip.seqz/map?","js/Error","rewrite-cljc.zip.seqz/map-seq","f","temp__5718__auto__","n0","rewrite-cljc.zip.move/down","G__78882","cljs.core/iterate","loc","temp__5720__auto__","n","rewrite-cljc.zip.move/right","cljs.core.take_while","cljs.core/identity","cljs.core/last","rewrite-cljc.zip.move/up","rewrite-cljc.zip.seqz/map-vals","parent","cljs.core/not","and__5041__auto__","rewrite-cljc.custom-zipper.core/node","v0","v","rewrite-cljc.zip.seqz/map-keys","rewrite-cljc.zip.seqz/map","rewrite-cljc.zip.seqz/get","k","cljs.core/integer?","G__78889","rewrite_cljc.zip.findz.find_value","cljs.core.nth","G__78891","rewrite-cljc.zip.seqz/assoc","vloc","rewrite-cljc.zip.editz/replace","rewrite-cljc.zip.insert/append-child","cljs.core.ex_info"],"sourcesContent":["(ns ^:no-doc rewrite-cljc.zip.seqz\n  (:refer-clojure :exclude [map get assoc seq? vector? list? map? set?])\n  (:require [rewrite-cljc.custom-zipper.core :as z]\n            [rewrite-cljc.zip.base :as base]\n            [rewrite-cljc.zip.editz :as e]\n            [rewrite-cljc.zip.findz :as f]\n            [rewrite-cljc.zip.insert :as i]\n            [rewrite-cljc.zip.move :as m]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## Predicates\n\n(defn seq?\n  \"Returns true if current node in `zloc` is a sequence.\"\n  [zloc]\n  (contains?\n    #{:forms :list :vector :set :map}\n    (base/tag zloc)))\n\n(defn list?\n  \"Returns true if current node in `zloc` is a list.\"\n  [zloc]\n  (= (base/tag zloc) :list))\n\n(defn vector?\n  \"Returns true if current node in `zloc` is a vector.\"\n  [zloc]\n  (= (base/tag zloc) :vector))\n\n(defn set?\n  \"Returns true if current node in `zloc` is a set.\"\n  [zloc]\n  (= (base/tag zloc) :set))\n\n(defn map?\n  \"Returns true if current node in `zloc` is a map.\"\n  [zloc]\n  (= (base/tag zloc) :map))\n\n;; ## Map Operations\n\n(defn- map-seq\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if-let [n0 (m/down zloc)]\n    (some->> (f n0)\n             (iterate\n               (fn [loc]\n                 (when-let [n (m/right loc)]\n                   (f n))))\n             (take-while identity)\n             (last)\n             (m/up))\n    zloc))\n\n(defn map-vals\n  \"Returns zipper with function `f` applied to all value current node in `zloc`.\n   Current node must be map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v0 (m/right loc)]\n        (if-let [v (f v0)]\n          (recur (m/right v) (m/up v))\n          (recur (m/right v0) parent))\n        parent))))\n\n(defn map-keys\n  \"Returns zipper with function `f` applied to all key nodes of the current node in `zloc`.\n   Current node must be map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v (f loc)]\n        (recur (m/right (m/right v)) (m/up v))\n        (recur (m/right (m/right loc)) parent)))))\n\n(defn map\n  \"Returns zipper with function `f` applied to all value nodes of current node in `zloc`.\n   Current node must be a sequence node.\n\n   Iterates over:\n   - value nodes of maps\n   - each element of a seq\"\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if (map? zloc)\n    (map-vals f zloc)\n    (map-seq f zloc)))\n\n;; ## Get/Assoc\n\n(defn get\n  \"Returns value node mapped to key `k` when current node in `zloc` is a map node.\n   Returns nth `k` value node when current node in `zloc` is a sequence node.\"\n  [zloc k]\n  {:pre [(or (map? zloc) (and (seq? zloc) (integer? k)))]}\n  (if (map? zloc)\n    (some-> zloc m/down (f/find-value k) m/right)\n    (nth\n      (some->> (m/down zloc)\n               (iterate m/right)\n               (take-while identity))\n      k)))\n\n(defn assoc\n  \"Returns zipper with key `k` set to value `v` when current node in `zloc` is a map node.\n   Returns zipper with index `k` set to value `v` when current node in `zloc` is a sequence.\"\n  [zloc k v]\n  (if-let [vloc (get zloc k)]\n    (-> vloc (e/replace v) m/up)\n    (if (map? zloc)\n      (-> zloc\n          (i/append-child k)\n          (i/append-child v))\n      (throw\n        (ex-info (str \"index out of bounds: \" k) {})))))\n"]}