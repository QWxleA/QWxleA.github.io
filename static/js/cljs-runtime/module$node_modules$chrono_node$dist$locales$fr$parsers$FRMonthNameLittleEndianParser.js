shadow$provide.module$node_modules$chrono_node$dist$locales$fr$parsers$FRMonthNameLittleEndianParser=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});const years_1=require("module$node_modules$chrono_node$dist$calculation$years"),constants_1=require("module$node_modules$chrono_node$dist$locales$fr$constants"),constants_2=require("module$node_modules$chrono_node$dist$locales$fr$constants"),constants_3=require("module$node_modules$chrono_node$dist$locales$fr$constants");
global=require("module$node_modules$chrono_node$dist$utils$pattern");require=require("module$node_modules$chrono_node$dist$common$parsers$AbstractParserWithWordBoundary");const PATTERN=new RegExp("(?:on\\s*?)?"+`(${constants_3.ORDINAL_NUMBER_PATTERN})`+`(?:\\s*(?:au|\\-|\\â€“|jusqu'au?|\\s)\\s*(${constants_3.ORDINAL_NUMBER_PATTERN}))?`+"(?:-|/|\\s*(?:de)?\\s*)"+`(${global.matchAnyPattern(constants_1.MONTH_DICTIONARY)})`+`(?:(?:-|/|,?\\s*)(${constants_2.YEAR_PATTERN}(?![^\\s]\\d)))?`+"(?\x3d\\W|$)",
"i");class FRMonthNameLittleEndianParser extends require.AbstractParserWithWordBoundaryChecking{innerPattern(){return PATTERN}innerExtract(context,match){const result=context.createParsingResult(match.index,match[0]),month=constants_1.MONTH_DICTIONARY[match[3].toLowerCase()],day=constants_3.parseOrdinalNumberPattern(match[1]);if(31<day)return match.index+=match[1].length,null;result.start.assign("month",month);result.start.assign("day",day);match[4]?(context=constants_2.parseYear(match[4]),result.start.assign("year",
context)):(context=years_1.findYearClosestToRef(context.refDate,day,month),result.start.imply("year",context));match[2]&&(match=constants_3.parseOrdinalNumberPattern(match[2]),result.end=result.start.clone(),result.end.assign("day",match));return result}}exports.default=FRMonthNameLittleEndianParser}
//# sourceMappingURL=module$node_modules$chrono_node$dist$locales$fr$parsers$FRMonthNameLittleEndianParser.js.map
