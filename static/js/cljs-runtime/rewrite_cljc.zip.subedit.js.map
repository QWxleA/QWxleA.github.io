{"version":3,"sources":["rewrite_cljc/zip/subedit.cljc"],"mappings":";AAOA;;;;;;gCAAA,hCAAOA,wEAKJC;AALH,+PAMO,AAACC,kBAAQC,mCAAKF,3IACd,AAACG,mDAAWD,nMACZ,AAACE,4CAAI,AAACC,6CAAKC,gBAAMC,lIACjB,OAACC;;AAER;;;qCAAA,rCAAOC,kFAEJC,IAAIC;AAFP,AAGE,OAACC,4CACC,AAACX,kBAAQY,sCAAQ,AAACC,qCAAOJ,MACzBC;;AAEJ;;;mCAAA,nCAAOI,8EAEJf,KAAKgB;AAFR,AAGE,IAAMC,OAAK,8DAAA,qCAAIjB,rCAAKkB,9DAAOC;AAA3B,AACE,OAACC,+CAAOX,mCAAUQ,KAAKD;;AAE3B;;;;;qCAAA,rCAAMK,kFAIHrB,KAAKsB;AAJR,AAKE,IAAMC,oBAAM,CAACD,kCAAAA,wCAAAA,RAAEtB,oBAAAA;AAAf,AACE,GAAQ,GAAK,sBAAA,rBAAMuB;AAAnB;AAAA,AAAA,MAAA,KAAAC,MAAA,CAAA,kBAAA,gDAAA,KAAA;;;AACA,OAACT,iCAAQQ,kBAAM,AAACxB,8BAAKC;;AAkBzB;;;kCAAA,lCAAMyB,4EAEHzB;AAFH,AAGE,IAAMuB,oBAAM,iBAAAG,WAAQ1B;IAAR0B,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,qCAAAA,rCAAaC;AAAb,AAAA,GAAA,CAAAD,gBAAA;AAAA;;AAAA,qEAAAA,9DAAoBP;;;AAAhC,AACE,oBAAQI;AAAR;AAAA,AAAA,MAAA,KAAAC,MAAA,CAAA,kBAAA,8BAAA,KAAA;;;AACAD;;AAEJ;;;;wCAAA,xCAAMK,wFAGH5B,KAAKsB;AAHR,AAIE,IAAMC,oBAAM,iBAAAM,WAAG,AAACJ,gCAAOzB;AAAX,AAAA,0EAAA6B,wBAAAA,1FAACP,kCAAAA,4CAAAA;;AAAb,AACE,GAAQ,GAAK,sBAAA,rBAAMC;AAAnB;AAAA,AAAA,MAAA,KAAAC,MAAA,CAAA,kBAAA,mDAAA,KAAA;;;AACA,OAACM,wCAAU9B,KAAK,AAACkB,qCAAOK","names":["rewrite-cljc.zip.subedit/path","zloc","cljs.core/iterate","rewrite-cljc.custom-zipper.core/up","cljs.core.take_while","cljs.core.map","cljs.core.comp","cljs.core/count","rewrite-cljc.custom-zipper.core/lefts","cljs.core/reverse","rewrite-cljc.zip.subedit/move-step","loc","n","cljs.core.nth","rewrite-cljc.custom-zipper.core/right","rewrite-cljc.custom-zipper.core/down","rewrite-cljc.zip.subedit/move-to","path","root","rewrite-cljc.custom-zipper.core/root","rewrite_cljc.zip.base.edn_STAR_","cljs.core.reduce","rewrite-cljc.zip.subedit/edit-node","f","zloc'","js/Error","rewrite-cljc.zip.subedit/subzip","G__80403","rewrite-cljc.custom-zipper.core/node","rewrite-cljc.zip.subedit/subedit-node","G__80404","rewrite-cljc.custom-zipper.core/replace"],"sourcesContent":["(ns ^:no-doc rewrite-cljc.zip.subedit\n  (:require [rewrite-cljc.custom-zipper.core :as z]\n            [rewrite-cljc.zip.base :as base])\n  #?(:cljs (:require-macros [rewrite-cljc.zip.subedit])))\n\n;; ## Edit Scope\n\n(defn- path\n  \"Generate a seq representing a path to the current node\n   starting at the root. Each element represents one `z/down`\n   and the value of each element will be the number of `z/right`s\n   to run.\"\n  [zloc]\n  (->> (iterate z/up zloc)\n       (take-while z/up)\n       (map (comp count z/lefts))\n       (reverse)))\n\n(defn- move-step\n  \"Move one down and `n` steps to the right.\"\n  [loc n]\n  (nth\n    (iterate z/right (z/down loc))\n    n))\n\n(defn- move-to\n  \"Move to the node represented by the given path.\"\n  [zloc path]\n  (let [root (-> zloc z/root base/edn*)]\n    (reduce move-step root path)))\n\n(defn edit-node\n  \"Return zipper applying function `f` to `zloc`. The resulting\n   zipper will be located at the same path (i.e. the same number of\n   downwards and right movements from the root) incoming `zloc`.\"\n  [zloc f]\n  (let [zloc' (f zloc)]\n    (assert (not (nil? zloc')) \"function applied in 'edit-node' returned nil.\")\n    (move-to zloc' (path zloc))))\n\n(defmacro edit->\n  \"Like `->`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\"\n  [zloc & body]\n  `(edit-node ~zloc #(-> % ~@body)))\n\n(defmacro edit->>\n  \"Like `->>`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\"\n  [zloc & body]\n  `(edit-node ~zloc #(->> % ~@body)))\n\n;; ## Sub-Zipper\n\n(defn subzip\n  \"Create and return a zipper whose root is the current node in `zloc`.\"\n  [zloc]\n  (let [zloc' (some-> zloc z/node base/edn*)]\n    (assert zloc' \"could not create subzipper.\")\n    zloc'))\n\n(defn subedit-node\n  \"Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\n   The resulting zipper will be located on the root of the modified sub-tree.\"\n  [zloc f]\n  (let [zloc' (f (subzip zloc))]\n    (assert (not (nil? zloc')) \"function applied in 'subedit-node' returned nil.\")\n    (z/replace zloc (z/root zloc'))))\n\n(defmacro subedit->\n  \"Like `->`, threads `zloc`, as an isolated sub-tree through forms, then zips\n   up to, and locates at, the root of the modified sub-tree.\"\n  [zloc & body]\n  `(subedit-node ~zloc #(-> % ~@body)))\n\n(defmacro subedit->>\n  \"Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\n      up to, and locates at, the root of the modified sub-tree.\"\n  [zloc & body]\n  `(subedit-node ~zloc #(->> % ~@body)))\n"]}