{
"version":3,
"file":"module$node_modules$$sentry$utils$dist$promisebuffer.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,oDAAA,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACjHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACA,KAAIC,QAAUN,OAAA,CAAQ,8CAAR,CAAd,CACIO,cAAgBP,OAAA,CAAQ,oDAAR,CAyFpBE,QAAQM,CAAAA,iBAAR,CApFAA,QAA0B,CAACC,KAAD,CAAQ,CAC9B,IAAIC,OAAS,EA6Eb,OAAO,CACHC,EAAGD,MADA,CAEHE,IAxDJA,QAAY,CAACC,YAAD,CAAe,CACvB,GAAI,EAtBaC,IAAAA,EAsBb,GAtBGL,KAsBH,EAtB0BC,MAAOK,CAAAA,MAsBjC,CAtB0CN,KAsB1C,CAAJ,CACI,MAAOF,cAAcS,CAAAA,mBAAd,CAAkC,IAAIV,OAAQW,CAAAA,WAAZ,CAAwB,iDAAxB,CAAlC,CAGX;IAAIC,KAAOL,YAAA,EACkB,EAAC,CAA9B,GAAIH,MAAOS,CAAAA,OAAP,CAAeD,IAAf,CAAJ,EACIR,MAAOU,CAAAA,IAAP,CAAYF,IAAZ,CAEJ,KAAKA,KACAG,CAAAA,IADA,CACK,QAAS,EAAG,CAAE,MAtBjBX,OAAOY,CAAAA,MAAP,CAAcZ,MAAOS,CAAAA,OAAP,CAsBiBD,IAtBjB,CAAd,CAAoC,CAApC,CAAA,CAAuC,CAAvC,CAsBe,CADjB,CAKAG,CAAAA,IALA,CAKK,IALL,CAKW,QAAS,EAAG,CACxB,MA3BGX,OAAOY,CAAAA,MAAP,CAAcZ,MAAOS,CAAAA,OAAP,CA2BHD,IA3BG,CAAd,CAAoC,CAApC,CAAA,CAAuC,CAAvC,CA2BiBG,CAAAA,IAAb,CAAkB,IAAlB,CAAwB,QAAS,EAAG,EAApC,CADiB,CALvB,CAUL,OAAOH,KAnBgB,CAsDpB,CAGHK,MA3BJA,QAAc,CAACC,OAAD,CAAU,CACpB,MAAO,KAAIjB,aAAckB,CAAAA,WAAlB,CAA8B,QAAS,CAACC,OAAD,CAAUC,MAAV,CAAkB,CAC5D,IAAIC,QAAUlB,MAAOK,CAAAA,MACrB,IAAI,CAACa,OAAL,CACI,MAAOF,QAAA,CAAQ,CAAA,CAAR,CAGX,KAAIG,mBAAqBC,UAAA,CAAW,QAAS,EAAG,CACxCN,OAAJ,EAAyB,CAAzB,CAAeA,OAAf,EACIE,OAAA,CAAQ,CAAA,CAAR,CAFwC,CAAvB,CAItBF,OAJsB,CAMzBd,OAAOqB,CAAAA,OAAP,CAAe,QAAS,CAACC,IAAD,CAAO,CAC3B,IAAKzB,cAAc0B,CAAAA,mBAAd,CAAkCD,IAAlC,CAAwCX,CAAAA,IAAxC,CAA6C,QAAS,EAAG,CAErD,EAAEO,OAAP;CACIM,YAAA,CAAaL,kBAAb,CACA,CAAAH,OAAA,CAAQ,CAAA,CAAR,CAFJ,CAF0D,CAAzD,CAMFC,MANE,CADsB,CAA/B,CAZ4D,CAAzD,CADa,CAwBjB,CA9EuB,CAR+E;",
"sources":["node_modules/@sentry/utils/dist/promisebuffer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$sentry$utils$dist$promisebuffer\"] = function(global,require,module,exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar error_1 = require(\"./error\");\nvar syncpromise_1 = require(\"./syncpromise\");\n/**\n * Creates an new PromiseBuffer object with the specified limit\n * @param limit max number of promises that can be stored in the buffer\n */\nfunction makePromiseBuffer(limit) {\n    var buffer = [];\n    function isReady() {\n        return limit === undefined || buffer.length < limit;\n    }\n    /**\n     * Remove a promise from the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns Removed promise.\n     */\n    function remove(task) {\n        return buffer.splice(buffer.indexOf(task), 1)[0];\n    }\n    /**\n     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n     *\n     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n     *        limit check.\n     * @returns The original promise.\n     */\n    function add(taskProducer) {\n        if (!isReady()) {\n            return syncpromise_1.rejectedSyncPromise(new error_1.SentryError('Not adding Promise due to buffer limit reached.'));\n        }\n        // start the task and add its promise to the queue\n        var task = taskProducer();\n        if (buffer.indexOf(task) === -1) {\n            buffer.push(task);\n        }\n        void task\n            .then(function () { return remove(task); })\n            // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n            // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n            // have promises, so TS has to polyfill when down-compiling.)\n            .then(null, function () {\n            return remove(task).then(null, function () {\n                // We have to add another catch here because `remove()` starts a new promise chain.\n            });\n        });\n        return task;\n    }\n    /**\n     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n     * `false` otherwise\n     */\n    function drain(timeout) {\n        return new syncpromise_1.SyncPromise(function (resolve, reject) {\n            var counter = buffer.length;\n            if (!counter) {\n                return resolve(true);\n            }\n            // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n            var capturedSetTimeout = setTimeout(function () {\n                if (timeout && timeout > 0) {\n                    resolve(false);\n                }\n            }, timeout);\n            // if all promises resolve in time, cancel the timer and resolve to `true`\n            buffer.forEach(function (item) {\n                void syncpromise_1.resolvedSyncPromise(item).then(function () {\n                    // eslint-disable-next-line no-plusplus\n                    if (!--counter) {\n                        clearTimeout(capturedSetTimeout);\n                        resolve(true);\n                    }\n                }, reject);\n            });\n        });\n    }\n    return {\n        $: buffer,\n        add: add,\n        drain: drain,\n    };\n}\nexports.makePromiseBuffer = makePromiseBuffer;\n//# sourceMappingURL=promisebuffer.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","error_1","syncpromise_1","makePromiseBuffer","limit","buffer","$","add","taskProducer","undefined","length","rejectedSyncPromise","SentryError","task","indexOf","push","then","splice","drain","timeout","SyncPromise","resolve","reject","counter","capturedSetTimeout","setTimeout","forEach","item","resolvedSyncPromise","clearTimeout"]
}
