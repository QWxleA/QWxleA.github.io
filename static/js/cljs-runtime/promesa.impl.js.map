{"version":3,"sources":["promesa/impl.cljc"],"mappings":"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","names":["promesa.impl/*default-promise*","js/Promise","promesa.impl/deferred","state","obj","resolve","reject","x51159","cljs.core/PROTOCOL_SENTINEL","_","v","promesa.impl/extend-promise!","t","p","it","f","p1__51161#","e","p1__51162#","p1__51163#","p1__51164#","p1__51165#","p1__51166#","p1__51167#","p1__51168#","p1__51169#","p1__51170#","executor","p1__51171#","p1__51172#","p1__51173#","promesa.protocols/IPromise","promesa.protocols/-map","promesa.protocols/-bind","promesa.protocols/-handle","promesa.protocols/-finally","promesa.protocols/-catch","promesa.protocols/-promise","promesa.impl/resolved","promesa.impl/rejected","promesa.protocols/IPromiseFactory","js/Error","promesa.impl/promise->str","writer","opts","cljs.core/-write"],"sourcesContent":[";; Copyright (c) 2015-2019 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.impl\n  \"Implementation of promise protocols.\"\n  (:require [promesa.protocols :as pt]\n            [promesa.util :as pu]\n            [promesa.exec :as exec])\n  #?(:clj (:import java.util.concurrent.CompletableFuture\n                   java.util.concurrent.CompletionStage\n                   java.util.concurrent.TimeoutException\n                   java.util.concurrent.ExecutionException\n                   java.util.concurrent.CompletionException\n                   java.util.concurrent.Executor\n                   java.util.function.Function\n                   java.util.function.Supplier)))\n\n;; --- Global Constants\n\n#?(:cljs (def ^:dynamic *default-promise* js/Promise))\n\n;; --- Promise Impl\n\n(defn deferred\n  []\n  #?(:clj (CompletableFuture.)\n     :cljs\n     (let [state #js {}\n           obj (new *default-promise*\n                    (fn [resolve reject]\n                      (set! (.-resolve state) resolve)\n                      (set! (.-reject state) reject)))]\n       (specify! obj\n         pt/ICompletable\n         (-resolve! [_ v]\n           (.resolve state v))\n         (-reject! [_ v]\n           (.reject state v))))))\n\n#?(:cljs\n   (defn extend-promise!\n     [t]\n     (extend-type t\n       pt/IPromiseFactory\n       (-promise [p] p)\n\n       pt/IPromise\n       (-map\n         ([it f] (.then it #(f %)))\n         ([it f e] (.then it #(f %))))\n       (-bind\n         ([it f] (.then it #(f %)))\n         ([it f e] (.then it #(f %))))\n       (-handle\n         ([it f] (.then it #(f % nil) #(f nil %)))\n         ([it f e] (.then it #(f % nil) #(f nil %))))\n       (-finally\n         ([it f] (.then it #(f % nil) #(f nil %)) it)\n         ([it f executor] (.then it #(f % nil) #(f nil %)) it))\n       (-catch\n         ([it f] (.catch it #(f %)))))))\n\n#?(:cljs\n   (extend-promise! js/Promise))\n\n#?(:cljs\n   (extend-type default\n     pt/IPromise\n     (-map\n       ([it f] (pt/-map (pt/-promise it) f))\n       ([it f e] (pt/-map (pt/-promise it) f e)))\n     (-bind\n       ([it f] (pt/-bind (pt/-promise it) f))\n       ([it f e] (pt/-bind (pt/-promise it) f e)))\n     (-handle\n       ([it f] (pt/-handle (pt/-promise it) f))\n       ([it f e] (pt/-handle (pt/-promise it) f e)))\n     (-finally\n       ([it f] (pt/-finally (pt/-promise it) f))\n       ([it f e] (pt/-finally (pt/-promise it) f e)))\n     (-catch\n       ([it f] (pt/-catch (pt/-promise it) f)))))\n\n#?(:clj\n   (extend-protocol pt/IPromise\n     CompletionStage\n     (-map\n       ([it f]\n        (.thenApply ^CompletionStage it\n                    ^Function (pu/->FunctionWrapper f)))\n\n       ([it f executor]\n        (.thenApplyAsync ^CompletionStage it\n                         ^Function (pu/->FunctionWrapper f)\n                         ^Executor (exec/resolve-executor executor))))\n\n     (-bind\n       ([it f]\n        (.thenCompose ^CompletionStage it\n                      ^Function (pu/->FunctionWrapper f)))\n\n       ([it f executor]\n        (.thenComposeAsync ^CompletionStage it\n                           ^Function (pu/->FunctionWrapper f)\n                           ^Executor (exec/resolve-executor executor))))\n\n     (-handle\n       ([it f]\n        (.handle ^CompletionStage it\n                 ^BiFunction (pu/->BiFunctionWrapper f)))\n\n       ([it f executor]\n        (.handleAsync ^CompletionStage it\n                      ^BiFunction (pu/->BiFunctionWrapper f)\n                      ^Executor (exec/resolve-executor executor))))\n\n     (-finally\n       ([it f]\n        (.whenComplete ^CompletionStage it\n                       ^BiConsumer (pu/->BiConsumerWrapper f)))\n\n       ([it f executor]\n        (.whenCompleteAsync ^CompletionStage it\n                            ^BiConsumer (pu/->BiConsumerWrapper f)\n                            ^Executor (exec/resolve-executor executor))))\n\n     (-catch [it f]\n       (letfn [(handler [e]\n                 (if (instance? CompletionException e)\n                   (f (.getCause ^Exception e))\n                   (f e)))]\n         (.exceptionally ^CompletionStage it\n                         ^Function (pu/->FunctionWrapper handler))))\n\n     Object\n     (-map\n       ([it f] (pt/-map (pt/-promise it) f))\n       ([it f e] (pt/-map (pt/-promise it) f e)))\n     (-bind\n       ([it f] (pt/-bind (pt/-promise it) f))\n       ([it f e] (pt/-bind (pt/-promise it) f e)))\n     (-handle\n       ([it f] (pt/-handle (pt/-promise it) f))\n       ([it f e] (pt/-handle (pt/-promise it) f e)))\n     (-finally\n       ([it f] (pt/-finally (pt/-promise it) f))\n       ([it f e] (pt/-finally (pt/-promise it) f e)))\n     (-catch\n       ([it f] (pt/-catch (pt/-promise it) f)))\n\n     nil\n     (-map\n       ([it f] (pt/-map (pt/-promise it) f))\n       ([it f e] (pt/-map (pt/-promise it) f e)))\n     (-bind\n       ([it f] (pt/-bind (pt/-promise it) f))\n       ([it f e] (pt/-bind (pt/-promise it) f e)))\n     (-handle\n       ([it f] (pt/-handle (pt/-promise it) f))\n       ([it f e] (pt/-handle (pt/-promise it) f e)))\n     (-finally\n       ([it f] (pt/-finally (pt/-promise it) f))\n       ([it f e] (pt/-finally (pt/-promise it) f e)))\n     (-catch\n       ([it f] (pt/-catch (pt/-promise it) f)))))\n\n#?(:clj\n   (extend-type CompletableFuture\n     pt/ICancellable\n     (-cancel! [it]\n       (.cancel it true))\n     (-cancelled? [it]\n       (.isCancelled it))\n\n     pt/ICompletable\n     (-resolve! [f v] (.complete f v))\n     (-reject! [f v] (.completeExceptionally f v))\n\n     pt/IState\n     (-extract [it]\n       (try\n         (.getNow it nil)\n         (catch ExecutionException e\n           (.getCause e))\n         (catch CompletionException e\n           (.getCause e))))\n\n     (-resolved? [it]\n       (and (not (.isCompletedExceptionally it))\n            (not (.isCancelled it))\n            (.isDone it)))\n\n     (-rejected? [it]\n       (.isCompletedExceptionally it))\n\n     (-pending? [it]\n       (and (not (.isCompletedExceptionally it))\n            (not (.isCancelled it))\n            (not (.isDone it))))))\n\n;; --- Promise Factory Impl\n\n(defn resolved\n  [v]\n  #?(:cljs (.resolve *default-promise* v)\n     :clj (CompletableFuture/completedFuture v)))\n\n(defn rejected\n  [v]\n  #?(:cljs (.reject *default-promise* v)\n     :clj (let [p (CompletableFuture.)]\n            (.completeExceptionally p v)\n            p)))\n\n#?(:clj\n   (extend-protocol pt/IPromiseFactory\n     CompletionStage\n     (-promise [cs] cs)\n\n     Throwable\n     (-promise [e]\n       (rejected e))\n\n     Object\n     (-promise [v]\n       (resolved v))\n\n     nil\n     (-promise [v]\n       (resolved v)))\n\n   :cljs\n   (extend-protocol pt/IPromiseFactory\n     js/Error\n     (-promise [e]\n       (rejected e))\n\n     default\n     (-promise [v]\n       (resolved v))))\n\n;; --- Pretty printing\n\n(defn promise->str\n  [p]\n  \"#<Promise[~]>\")\n\n#?(:clj\n   (defmethod print-method java.util.concurrent.CompletionStage\n     [p ^java.io.Writer writer]\n     (let [status (cond\n                    (pt/-pending? p) \"pending\"\n                    (pt/-rejected? p) \"rejected\"\n                    :else \"resolved\")]\n       (.write writer ^String (format \"#object[java.util.concurrent.CompletableFuture 0x%h \\\"%s\\\"]\" (hash p) status)))))\n\n#?(:cljs\n   (extend-type js/Promise\n     IPrintWithWriter\n     (-pr-writer [p writer opts]\n       (-write writer (promise->str p)))))\n"]}