{
"version":3,
"file":"module$node_modules$$capacitor$filesystem$dist$plugin_cjs.js",
"lineCount":20,
"mappings":"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",
"sources":["node_modules/@capacitor/filesystem/dist/plugin.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$capacitor$filesystem$dist$plugin_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar core = require('@capacitor/core');\n\nexports.Directory = void 0;\n(function (Directory) {\n    /**\n     * The Documents directory\n     * On iOS it's the app's documents directory.\n     * Use this directory to store user-generated content.\n     * On Android it's the Public Documents folder, so it's accessible from other apps.\n     * It's not accesible on Android 10 unless the app enables legacy External Storage\n     * by adding `android:requestLegacyExternalStorage=\"true\"` in the `application` tag\n     * in the `AndroidManifest.xml`.\n     * It's not accesible on Android 11 or newer.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"Documents\"] = \"DOCUMENTS\";\n    /**\n     * The Data directory\n     * On iOS it will use the Documents directory\n     * On Android it's the directory holding application files.\n     * Files will be deleted when the application is uninstalled.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"Data\"] = \"DATA\";\n    /**\n     * The Cache directory\n     * Can be deleted in cases of low memory, so use this directory to write app-specific files\n     * that your app can re-create easily.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"Cache\"] = \"CACHE\";\n    /**\n     * The external directory\n     * On iOS it will use the Documents directory\n     * On Android it's the directory on the primary shared/external\n     * storage device where the application can place persistent files it owns.\n     * These files are internal to the applications, and not typically visible\n     * to the user as media.\n     * Files will be deleted when the application is uninstalled.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"External\"] = \"EXTERNAL\";\n    /**\n     * The external storage directory\n     * On iOS it will use the Documents directory\n     * On Android it's the primary shared/external storage directory.\n     * It's not accesible on Android 10 unless the app enables legacy External Storage\n     * by adding `android:requestLegacyExternalStorage=\"true\"` in the `application` tag\n     * in the `AndroidManifest.xml`.\n     * It's not accesible on Android 11 or newer.\n     *\n     * @since 1.0.0\n     */\n    Directory[\"ExternalStorage\"] = \"EXTERNAL_STORAGE\";\n})(exports.Directory || (exports.Directory = {}));\nexports.Encoding = void 0;\n(function (Encoding) {\n    /**\n     * Eight-bit UCS Transformation Format\n     *\n     * @since 1.0.0\n     */\n    Encoding[\"UTF8\"] = \"utf8\";\n    /**\n     * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the\n     * Unicode character set\n     * This encoding is only supported on Android.\n     *\n     * @since 1.0.0\n     */\n    Encoding[\"ASCII\"] = \"ascii\";\n    /**\n     * Sixteen-bit UCS Transformation Format, byte order identified by an\n     * optional byte-order mark\n     * This encoding is only supported on Android.\n     *\n     * @since 1.0.0\n     */\n    Encoding[\"UTF16\"] = \"utf16\";\n})(exports.Encoding || (exports.Encoding = {}));\n/**\n * @deprecated Use `Directory`.\n * @since 1.0.0\n */\nconst FilesystemDirectory = exports.Directory;\n/**\n * @deprecated Use `Encoding`.\n * @since 1.0.0\n */\nconst FilesystemEncoding = exports.Encoding;\n\nconst Filesystem = core.registerPlugin('Filesystem', {\n    web: () => Promise.resolve().then(function () { return web; }).then(m => new m.FilesystemWeb()),\n});\n\nfunction resolve(path) {\n    const posix = path.split('/').filter(item => item !== '.');\n    const newPosix = [];\n    posix.forEach(item => {\n        if (item === '..' &&\n            newPosix.length > 0 &&\n            newPosix[newPosix.length - 1] !== '..') {\n            newPosix.pop();\n        }\n        else {\n            newPosix.push(item);\n        }\n    });\n    return newPosix.join('/');\n}\nfunction isPathParent(parent, children) {\n    parent = resolve(parent);\n    children = resolve(children);\n    const pathsA = parent.split('/');\n    const pathsB = children.split('/');\n    return (parent !== children &&\n        pathsA.every((value, index) => value === pathsB[index]));\n}\nclass FilesystemWeb extends core.WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.DB_VERSION = 1;\n        this.DB_NAME = 'Disc';\n        this._writeCmds = ['add', 'put', 'delete'];\n    }\n    async initDb() {\n        if (this._db !== undefined) {\n            return this._db;\n        }\n        if (!('indexedDB' in window)) {\n            throw this.unavailable(\"This browser doesn't support IndexedDB\");\n        }\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n            request.onupgradeneeded = FilesystemWeb.doUpgrade;\n            request.onsuccess = () => {\n                this._db = request.result;\n                resolve(request.result);\n            };\n            request.onerror = () => reject(request.error);\n            request.onblocked = () => {\n                console.warn('db blocked');\n            };\n        });\n    }\n    static doUpgrade(event) {\n        const eventTarget = event.target;\n        const db = eventTarget.result;\n        switch (event.oldVersion) {\n            case 0:\n            case 1:\n            default: {\n                if (db.objectStoreNames.contains('FileStorage')) {\n                    db.deleteObjectStore('FileStorage');\n                }\n                const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n                store.createIndex('by_folder', 'folder');\n            }\n        }\n    }\n    async dbRequest(cmd, args) {\n        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return this.initDb().then((conn) => {\n            return new Promise((resolve, reject) => {\n                const tx = conn.transaction(['FileStorage'], readFlag);\n                const store = tx.objectStore('FileStorage');\n                const req = store[cmd](...args);\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        });\n    }\n    async dbIndexRequest(indexName, cmd, args) {\n        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return this.initDb().then((conn) => {\n            return new Promise((resolve, reject) => {\n                const tx = conn.transaction(['FileStorage'], readFlag);\n                const store = tx.objectStore('FileStorage');\n                const index = store.index(indexName);\n                const req = index[cmd](...args);\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        });\n    }\n    getPath(directory, uriPath) {\n        const cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n        let fsPath = '';\n        if (directory !== undefined)\n            fsPath += '/' + directory;\n        if (uriPath !== '')\n            fsPath += '/' + cleanedUriPath;\n        return fsPath;\n    }\n    async clear() {\n        const conn = await this.initDb();\n        const tx = conn.transaction(['FileStorage'], 'readwrite');\n        const store = tx.objectStore('FileStorage');\n        store.clear();\n    }\n    /**\n     * Read a file from disk\n     * @param options options for the file read\n     * @return a promise that resolves with the read file data result\n     */\n    async readFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        // const encoding = options.encoding;\n        const entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined)\n            throw Error('File does not exist.');\n        return { data: entry.content ? entry.content : '' };\n    }\n    /**\n     * Write a file to disk in the specified location on device\n     * @param options options for the file write\n     * @return a promise that resolves with the file write result\n     */\n    async writeFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        const data = options.data;\n        const doRecursive = options.recursive;\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (occupiedEntry && occupiedEntry.type === 'directory')\n            throw 'The supplied path is a directory.';\n        const encoding = options.encoding;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        if (parentEntry === undefined) {\n            const subDirIndex = parentPath.indexOf('/', 1);\n            if (subDirIndex !== -1) {\n                const parentArgPath = parentPath.substr(subDirIndex);\n                await this.mkdir({\n                    path: parentArgPath,\n                    directory: options.directory,\n                    recursive: doRecursive,\n                });\n            }\n        }\n        const now = Date.now();\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'file',\n            size: data.length,\n            ctime: now,\n            mtime: now,\n            content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data,\n        };\n        await this.dbRequest('put', [pathObj]);\n        return {\n            uri: pathObj.path,\n        };\n    }\n    /**\n     * Append to a file on disk in the specified location on device\n     * @param options options for the file append\n     * @return a promise that resolves with the file write result\n     */\n    async appendFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        let data = options.data;\n        // const encoding = options.encoding;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const now = Date.now();\n        let ctime = now;\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (occupiedEntry && occupiedEntry.type === 'directory')\n            throw 'The supplied path is a directory.';\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        if (parentEntry === undefined) {\n            const subDirIndex = parentPath.indexOf('/', 1);\n            if (subDirIndex !== -1) {\n                const parentArgPath = parentPath.substr(subDirIndex);\n                await this.mkdir({\n                    path: parentArgPath,\n                    directory: options.directory,\n                    recursive: true,\n                });\n            }\n        }\n        if (occupiedEntry !== undefined) {\n            data = occupiedEntry.content + data;\n            ctime = occupiedEntry.ctime;\n        }\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'file',\n            size: data.length,\n            ctime: ctime,\n            mtime: now,\n            content: data,\n        };\n        await this.dbRequest('put', [pathObj]);\n    }\n    /**\n     * Delete a file from disk\n     * @param options options for the file delete\n     * @return a promise that resolves with the deleted file data result\n     */\n    async deleteFile(options) {\n        const path = this.getPath(options.directory, options.path);\n        const entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined)\n            throw Error('File does not exist.');\n        const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n            IDBKeyRange.only(path),\n        ]);\n        if (entries.length !== 0)\n            throw Error('Folder is not empty.');\n        await this.dbRequest('delete', [path]);\n    }\n    /**\n     * Create a directory.\n     * @param options options for the mkdir\n     * @return a promise that resolves with the mkdir result\n     */\n    async mkdir(options) {\n        const path = this.getPath(options.directory, options.path);\n        const doRecursive = options.recursive;\n        const parentPath = path.substr(0, path.lastIndexOf('/'));\n        const depth = (path.match(/\\//g) || []).length;\n        const parentEntry = (await this.dbRequest('get', [parentPath]));\n        const occupiedEntry = (await this.dbRequest('get', [path]));\n        if (depth === 1)\n            throw Error('Cannot create Root directory');\n        if (occupiedEntry !== undefined)\n            throw Error('Current directory does already exist.');\n        if (!doRecursive && depth !== 2 && parentEntry === undefined)\n            throw Error('Parent directory must exist');\n        if (doRecursive && depth !== 2 && parentEntry === undefined) {\n            const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n            await this.mkdir({\n                path: parentArgPath,\n                directory: options.directory,\n                recursive: doRecursive,\n            });\n        }\n        const now = Date.now();\n        const pathObj = {\n            path: path,\n            folder: parentPath,\n            type: 'directory',\n            size: 0,\n            ctime: now,\n            mtime: now,\n        };\n        await this.dbRequest('put', [pathObj]);\n    }\n    /**\n     * Remove a directory\n     * @param options the options for the directory remove\n     */\n    async rmdir(options) {\n        const { path, directory, recursive } = options;\n        const fullPath = this.getPath(directory, path);\n        const entry = (await this.dbRequest('get', [fullPath]));\n        if (entry === undefined)\n            throw Error('Folder does not exist.');\n        if (entry.type !== 'directory')\n            throw Error('Requested path is not a directory');\n        const readDirResult = await this.readdir({ path, directory });\n        if (readDirResult.files.length !== 0 && !recursive)\n            throw Error('Folder is not empty');\n        for (const entry of readDirResult.files) {\n            const entryPath = `${path}/${entry}`;\n            const entryObj = await this.stat({ path: entryPath, directory });\n            if (entryObj.type === 'file') {\n                await this.deleteFile({ path: entryPath, directory });\n            }\n            else {\n                await this.rmdir({ path: entryPath, directory, recursive });\n            }\n        }\n        await this.dbRequest('delete', [fullPath]);\n    }\n    /**\n     * Return a list of files from the directory (not recursive)\n     * @param options the options for the readdir operation\n     * @return a promise that resolves with the readdir directory listing result\n     */\n    async readdir(options) {\n        const path = this.getPath(options.directory, options.path);\n        const entry = (await this.dbRequest('get', [path]));\n        if (options.path !== '' && entry === undefined)\n            throw Error('Folder does not exist.');\n        const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n        const names = entries.map(e => {\n            return e.substring(path.length + 1);\n        });\n        return { files: names };\n    }\n    /**\n     * Return full File URI for a path and directory\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    async getUri(options) {\n        const path = this.getPath(options.directory, options.path);\n        let entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined) {\n            entry = (await this.dbRequest('get', [path + '/']));\n        }\n        return {\n            uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path,\n        };\n    }\n    /**\n     * Return data about a file\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    async stat(options) {\n        const path = this.getPath(options.directory, options.path);\n        let entry = (await this.dbRequest('get', [path]));\n        if (entry === undefined) {\n            entry = (await this.dbRequest('get', [path + '/']));\n        }\n        if (entry === undefined)\n            throw Error('Entry does not exist.');\n        return {\n            type: entry.type,\n            size: entry.size,\n            ctime: entry.ctime,\n            mtime: entry.mtime,\n            uri: entry.path,\n        };\n    }\n    /**\n     * Rename a file or directory\n     * @param options the options for the rename operation\n     * @return a promise that resolves with the rename result\n     */\n    async rename(options) {\n        return this._copy(options, true);\n    }\n    /**\n     * Copy a file or directory\n     * @param options the options for the copy operation\n     * @return a promise that resolves with the copy result\n     */\n    async copy(options) {\n        return this._copy(options, false);\n    }\n    async requestPermissions() {\n        return { publicStorage: 'granted' };\n    }\n    async checkPermissions() {\n        return { publicStorage: 'granted' };\n    }\n    /**\n     * Function that can perform a copy or a rename\n     * @param options the options for the rename operation\n     * @param doRename whether to perform a rename or copy operation\n     * @return a promise that resolves with the result\n     */\n    async _copy(options, doRename = false) {\n        let { toDirectory } = options;\n        const { to, from, directory: fromDirectory } = options;\n        if (!to || !from) {\n            throw Error('Both to and from must be provided');\n        }\n        // If no \"to\" directory is provided, use the \"from\" directory\n        if (!toDirectory) {\n            toDirectory = fromDirectory;\n        }\n        const fromPath = this.getPath(fromDirectory, from);\n        const toPath = this.getPath(toDirectory, to);\n        // Test that the \"to\" and \"from\" locations are different\n        if (fromPath === toPath) {\n            return;\n        }\n        if (isPathParent(fromPath, toPath)) {\n            throw Error('To path cannot contain the from path');\n        }\n        // Check the state of the \"to\" location\n        let toObj;\n        try {\n            toObj = await this.stat({\n                path: to,\n                directory: toDirectory,\n            });\n        }\n        catch (e) {\n            // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n            const toPathComponents = to.split('/');\n            toPathComponents.pop();\n            const toPath = toPathComponents.join('/');\n            // Check the containing directory of the \"to\" location exists\n            if (toPathComponents.length > 0) {\n                const toParentDirectory = await this.stat({\n                    path: toPath,\n                    directory: toDirectory,\n                });\n                if (toParentDirectory.type !== 'directory') {\n                    throw new Error('Parent directory of the to path is a file');\n                }\n            }\n        }\n        // Cannot overwrite a directory\n        if (toObj && toObj.type === 'directory') {\n            throw new Error('Cannot overwrite a directory with a file');\n        }\n        // Ensure the \"from\" object exists\n        const fromObj = await this.stat({\n            path: from,\n            directory: fromDirectory,\n        });\n        // Set the mtime/ctime of the supplied path\n        const updateTime = async (path, ctime, mtime) => {\n            const fullPath = this.getPath(toDirectory, path);\n            const entry = (await this.dbRequest('get', [fullPath]));\n            entry.ctime = ctime;\n            entry.mtime = mtime;\n            await this.dbRequest('put', [entry]);\n        };\n        const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n        switch (fromObj.type) {\n            // The \"from\" object is a file\n            case 'file': {\n                // Read the file\n                const file = await this.readFile({\n                    path: from,\n                    directory: fromDirectory,\n                });\n                // Optionally remove the file\n                if (doRename) {\n                    await this.deleteFile({\n                        path: from,\n                        directory: fromDirectory,\n                    });\n                }\n                // Write the file to the new location\n                await this.writeFile({\n                    path: to,\n                    directory: toDirectory,\n                    data: file.data,\n                });\n                // Copy the mtime/ctime of a renamed file\n                if (doRename) {\n                    await updateTime(to, ctime, fromObj.mtime);\n                }\n                // Resolve promise\n                return;\n            }\n            case 'directory': {\n                if (toObj) {\n                    throw Error('Cannot move a directory over an existing object');\n                }\n                try {\n                    // Create the to directory\n                    await this.mkdir({\n                        path: to,\n                        directory: toDirectory,\n                        recursive: false,\n                    });\n                    // Copy the mtime/ctime of a renamed directory\n                    if (doRename) {\n                        await updateTime(to, ctime, fromObj.mtime);\n                    }\n                }\n                catch (e) {\n                    // ignore\n                }\n                // Iterate over the contents of the from location\n                const contents = (await this.readdir({\n                    path: from,\n                    directory: fromDirectory,\n                })).files;\n                for (const filename of contents) {\n                    // Move item from the from directory to the to directory\n                    await this._copy({\n                        from: `${from}/${filename}`,\n                        to: `${to}/${filename}`,\n                        directory: fromDirectory,\n                        toDirectory,\n                    }, doRename);\n                }\n                // Optionally remove the original from directory\n                if (doRename) {\n                    await this.rmdir({\n                        path: from,\n                        directory: fromDirectory,\n                    });\n                }\n            }\n        }\n    }\n}\nFilesystemWeb._debug = true;\n\nvar web = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    FilesystemWeb: FilesystemWeb\n});\n\nexports.Filesystem = Filesystem;\nexports.FilesystemDirectory = FilesystemDirectory;\nexports.FilesystemEncoding = FilesystemEncoding;\n//# sourceMappingURL=plugin.cjs.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","resolve","path","newPosix","split","filter","posix","item","forEach","length","pop","push","join","isPathParent","parent","children","pathsA","pathsB","every","value","index","Object","defineProperty","core","Directory","Encoding","FilesystemDirectory","FilesystemEncoding","Filesystem","registerPlugin","web","Promise","then","m","FilesystemWeb","WebPlugin","constructor","arguments","DB_VERSION","DB_NAME","_writeCmds","initDb","undefined","_db","window","unavailable","reject","request","indexedDB","open","onupgradeneeded","doUpgrade","onsuccess","request.onsuccess","result","onerror","request.onerror","error","onblocked","request.onblocked","console","warn","event","db","target","objectStoreNames","contains","deleteObjectStore","createObjectStore","store","keyPath","createIndex","dbRequest","cmd","args","readFlag","indexOf","conn","req","transaction","tx","objectStore","req.onsuccess","req.onerror","dbIndexRequest","indexName","getPath","directory","uriPath","cleanedUriPath","replace","fsPath","clear","readFile","options","entry","Error","data","content","writeFile","doRecursive","recursive","occupiedEntry","type","encoding","parentPath","substr","lastIndexOf","parentEntry","subDirIndex","parentArgPath","mkdir","now","Date","pathObj","folder","size","ctime","mtime","uri","appendFile","deleteFile","entries","IDBKeyRange","only","depth","match","rmdir","fullPath","readDirResult","readdir","files","entryPath","entryObj","stat","map","names","e","substring","getUri","rename","_copy","copy","requestPermissions","publicStorage","checkPermissions","doRename","toDirectory","to","from","fromDirectory","fromPath","toPath","toObj","toPathComponents","toParentDirectory","fromObj","updateTime","file","contents","filename","_debug","freeze","__proto__"]
}
