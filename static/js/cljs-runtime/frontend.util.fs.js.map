{"version":3,"sources":["frontend/util/fs.cljs"],"mappings":";;AAQA,uCAAA,vCAAMA,sFACHC,IAAIC;AADP,AAEE,GAAM,OAASA;AAAf,AACE,IAAAC,mBACC,eAAA,WAAAC,1BAACC;AAAD,AAAO,OAACC,kCAAoBJ,KAAK,kDAAA,gDAAAE,rDAAKH;GAAtC,mFAAA,IAAA,WAAA,SAAA,eAAA;AADD,AAAA,oBAAAE;AAAAA;;AAAA,IAAAA,uBAGC,eAAA,WAAAI,1BAACF;AAAD,AAAO,OAACG,+BAAiBN,KAAK,CAAA,gDAAAK,kBAAA;GAA9B,mFAAA,IAAA,WAAA,SAAA,eAAA;AAHD,AAAA,oBAAAJ;AAAAA;;AAAA,IAAAA,uBAKC,qCAAA,rCAACM,gCAAkBP;AALpB,AAAA,GAAAC;AAAAA;;AAAA,IAAAA,uBAOC,iBAAMO,UAAQ,AAACC,uCAAcV,IAAIC;AAAjC,AACE,IAAAC,uBAAI,kBAAA,lBAACS,8BAAoBF;AAAzB,AAAA,oBAAAP;AAAAA;;AACI,yBAAA,lBAACS,6BAAoBF;;;AAT5B,AAAA,oBAAAP;AAAAA;;AAUC,IAAMD,WAAK,AAACW,0BAAkBX;AAA9B,AACE,SACC,GAAK,AAACY,4BAAc,AAACC,sCAAab,kBAClC,AAACc,cACA,eAAA,WAAAC,1BAACZ;AAAD,AAAO,gDAAAY,zCAACR,gCAAkBP;GAA1B,mFAAA,MAAA,YAAA,OAAA,MAAA,OAAA;;;;;;AAfP","names":["frontend.util.fs/ignored-path?","dir","path","or__4253__auto__","p1__97977#","cljs.core/some","clojure.string/starts-with?","p1__97978#","clojure.string/includes?","clojure.string/ends-with?","relpath","js/module$node_modules$path$path.relative","cljs.core/re-find","clojure.string/lower-case","clojure.string/blank?","js/module$node_modules$path$path.extname","cljs.core/not","p1__97979#"],"sourcesContent":["(ns frontend.util.fs\n  (:require [clojure.string :as string]\n            [\"path\" :as path]))\n\n;; TODO: move all file path related util functions to here\n\n;; keep same as ignored-path? in src/electron/electron/utils.cljs\n;; TODO: merge them\n(defn ignored-path?\n  [dir path]\n  (when (string? path)\n    (or\n     (some #(string/starts-with? path (str dir \"/\" %))\n           [\".\" \".recycle\" \"assets\" \"node_modules\" \"logseq/bak\"])\n     (some #(string/includes? path (str \"/\" % \"/\"))\n           [\".\" \".recycle\" \"assets\" \"node_modules\" \"logseq/bak\"])\n     (string/ends-with? path \".DS_Store\")\n     ;; hidden directory or file\n     (let [relpath (path/relative dir path)]\n       (or (re-find #\"/\\.[^.]+\" relpath)\n           (re-find #\"^\\.[^.]+\" relpath)))\n     (let [path (string/lower-case path)]\n       (and\n        (not (string/blank? (path/extname path)))\n        (not\n         (some #(string/ends-with? path %)\n               [\".md\" \".markdown\" \".org\" \".js\" \".edn\" \".css\"])))))))"]}