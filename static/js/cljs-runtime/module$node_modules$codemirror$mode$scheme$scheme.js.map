{
"version":3,
"file":"module$node_modules$codemirror$mode$scheme$scheme.js",
"lineCount":11,
"mappings":"AAAAA,cAAA,CAAA,iDAAA,CAAsE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAQ7G,SAAQ,CAACC,GAAD,CAAM,CACS,QAAtB,EAAI,MAAOD,QAAX,EAAmD,QAAnD,EAAkC,MAAOD,OAAzC,CACEE,GAAA,CAAIH,OAAA,CAAQ,+CAAR,CAAJ,CADF,CAE0B,UAArB,EAAI,MAAOI,OAAX,EAAmCA,MAAOC,CAAAA,GAA1C,CACHD,MAAA,CAAO,CAAC,sBAAD,CAAP,CAAiCD,GAAjC,CADG,CAGHA,GAAA,CAAIG,UAAJ,CANW,CAAd,CAAD,CAOG,QAAQ,CAACA,UAAD,CAAa,CAGxBA,UAAWC,CAAAA,UAAX,CAAsB,QAAtB,CAAgC,QAAS,EAAG,CAKxCC,QAASA,aAAY,CAACC,GAAD,CAAM,CAAA,IACnBC,IAAM,EAAIC,IAAAA,CAAQF,GAAIG,CAAAA,KAAJ,CAAU,GAAV,CACtB,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,GAAMG,CAAAA,MAA1B,CAAkC,EAAED,CAApC,CAAuCH,GAAA,CAAIC,GAAA,CAAME,CAAN,CAAJ,CAAA,CAAgB,CAAA,CACvD,OAAOH,IAHgB,CAS3BK,QAASA,WAAU,CAACC,MAAD;AAASC,IAAT,CAAeC,IAAf,CAAqB,CACpC,IAAKF,CAAAA,MAAL,CAAcA,MACd,KAAKC,CAAAA,IAAL,CAAYA,IACZ,KAAKC,CAAAA,IAAL,CAAYA,IAHwB,CAmBxCC,QAASA,eAAe,CAACC,MAAD,CAAS,CAC7B,MAAOA,OAAOC,CAAAA,KAAP,CAAaC,aAAb,CADsB,CAIjCC,QAASA,cAAc,CAACH,MAAD,CAAS,CAC5B,MAAOA,OAAOC,CAAAA,KAAP,CAAaG,YAAb,CADqB,CAIhCC,QAASA,gBAAgB,CAACL,MAAD,CAASM,MAAT,CAAiB,CACvB,CAAA,CAAf,GAAIA,MAAJ,EACIN,MAAOO,CAAAA,MAAP,CAAc,CAAd,CAEJ,OAAOP,OAAOC,CAAAA,KAAP,CAAaO,cAAb,CAJ+B,CAO1CC,QAASA,YAAY,CAACT,MAAD,CAAS,CAC1B,MAAOA,OAAOC,CAAAA,KAAP,CAAaS,UAAb,CADmB,CArC9B,IAAIC,SAAWvB,YAAA,CAAa,4tEAAb,CAAf;AACIwB,WAAaxB,YAAA,CAAa,+BAAb,CADjB,CAiBIc,cAAgB,IAAIW,MAAJ,CAAW,iMAAX,CAjBpB,CAkBIT,aAAe,IAAIS,MAAJ,CAAW,6MAAX,CAlBnB;AAmBIH,WAAa,IAAIG,MAAJ,CAAW,qOAAX,CAnBjB,CAoBIL,eAAiB,IAAIK,MAAJ,CAAW,8gBAAX,CAqBrB;MAAO,CACHC,WAAYA,QAAS,EAAG,CACpB,MAAO,CACHC,YAAa,IADV,CAEHC,YAAa,CAFV,CAGHC,KAAM,CAAA,CAHH,CAIHC,aAAc,CAAA,CAJX,CAKHC,WAAY,CAAA,CALT,CADa,CADrB,CAWHC,MAAOA,QAAS,CAACpB,MAAD,CAASqB,KAAT,CAAgB,CACH,IAAzB,EAAIA,KAAMN,CAAAA,WAAV,EAAiCf,MAAOsB,CAAAA,GAAP,EAAjC,GAEID,KAAML,CAAAA,WAFV,CAEwBhB,MAAOgB,CAAAA,WAAP,EAFxB,CAMA,IAAIhB,MAAOuB,CAAAA,QAAP,EAAJ,CACI,MAAO,KAEX,KAAIC,WAAa,IAEjB,QAAOH,KAAMJ,CAAAA,IAAb,EACI,KAAK,QAAL,CAAA,IACQQ,IACJ,KADUC,UACV,CADoB,CAAA,CACpB,CAAiC,IAAjC,GAAQD,IAAR,CAAezB,MAAOyB,CAAAA,IAAP,EAAf,EAAA,CAAuC,CACnC,GAAY,GAAZ,EAAIA,IAAJ,EAAoB,CAACC,UAArB,CAA8B,CAE1BL,KAAMJ,CAAAA,IAAN,CAAa,CAAA,CACb,MAH0B,CAK9BS,UAAA,CAAU,CAACA,UAAX,EAA8B,IAA9B,EAAsBD,IANa,CAQvCD,UAAA,CArFuCG,QAsFvC,MACJ,MAAK,SAAL,CAEI,IADUC,UACV,CADqB,CAAA,CACrB,CAAiC,IAAjC;CAAQH,IAAR,CAAezB,MAAOyB,CAAAA,IAAP,EAAf,EAAA,CAAuC,CACnC,GAAY,GAAZ,EAAIA,IAAJ,EAAmBG,UAAnB,CAA6B,CAEzBP,KAAMJ,CAAAA,IAAN,CAAa,CAAA,CACb,MAHyB,CAK7BW,UAAA,CAAoB,GAApB,EAAYH,IANuB,CAQvCD,UAAA,CAjGmBK,SAkGnB,MACJ,MAAK,gBAAL,CAEI,GADAR,KAAMJ,CAAAA,IACH,CADU,CAAA,CACV,CAAiB,GAAjB,EAAAjB,MAAO8B,CAAAA,IAAP,EAAA,EAAyC,GAAzC,EAAwB9B,MAAO8B,CAAAA,IAAP,EAA3B,CAEIT,KAAMH,CAAAA,YAAN,CAAqB,CAFzB,KAGK,CAEDlB,MAAO+B,CAAAA,QAAP,CAAgB,eAAhB,CACAP,WAAA,CA3GeK,SA4Gf,MAJC,CAMT,QAGI,GAFIG,IAEA,CAFKhC,MAAOyB,CAAAA,IAAP,EAEL,CAAM,GAAN,EAAAO,IAAJ,CAEIR,UAAA,CADAH,KAAMJ,CAAAA,IACN,CADa,QADjB,KAIO,IAAU,GAAV,EAAIe,IAAJ,CACkB,GAArB,EAAIhC,MAAO8B,CAAAA,IAAP,EAAJ,EAA6C,GAA7C,EAA4B9B,MAAO8B,CAAAA,IAAP,EAA5B,CACmC,QADnC,EACQ,MAAOT,MAAMF,CAAAA,UADrB,GAEQE,KAAMF,CAAAA,UAFd,CAE2B,CAF3B,EAMInB,MAAO+B,CAAAA,QAAP,CAAgB,4BAAhB,CAFA;AAAAP,UAAA,CAzHbS,MAoHY,KAUA,IAAU,GAAV,EAAID,IAAJ,CACH,GAAIhC,MAAOkC,CAAAA,GAAP,CAAW,GAAX,CAAJ,CAEIV,UAAA,CADAH,KAAMJ,CAAAA,IACN,CADa,SADjB,KAGO,IAAIjB,MAAOkC,CAAAA,GAAP,CAAW,OAAX,CAAJ,CACHV,UAAA,CAnIbS,MAkIgB,KAEA,IAAIjC,MAAOkC,CAAAA,GAAP,CAAW,GAAX,CAAJ,CACHb,KAAMJ,CAAAA,IACN,CADa,gBACb,CAAAO,UAAA,CAvIWK,SAqIR,KAGA,CACCM,IAAAA,CAAU,IADX,KACiBC,aAAe,CAAA,CADhC,CACuCC,SAAW,CAAA,CACjDrC,OAAOkC,CAAAA,GAAP,CAAW,OAAX,CAAJ,CACIE,YADJ,CACmB,CAAA,CADnB,CAGIpC,MAAOO,CAAAA,MAAP,CAAc,CAAd,CAEAP,OAAOC,CAAAA,KAAP,CAAa,MAAb,CAAJ,CACIkC,IADJ,CACcpC,cADd,CAEWC,MAAOC,CAAAA,KAAP,CAAa,MAAb,CAAJ,CACHkC,IADG,CACOhC,aADP,CAEIH,MAAOC,CAAAA,KAAP,CAAa,MAAb,CAAJ,CACHkC,IADG,CACO1B,WADP,CAEIT,MAAOC,CAAAA,KAAP,CAAa,MAAb,CAAJ,CACHkC,IADG,CACO9B,eADP,CAEIL,MAAOC,CAAAA,KAAP,CAAa,WAAb,CAA0B,CAAA,CAA1B,CAAJ,EACHoC,QACA;AADW,CAAA,CACX,CAAAF,IAAA,CAAU9B,eAFP,EAIK+B,YAJL,EAKHpC,MAAOkC,CAAAA,GAAP,CAAW,GAAX,CAEW,KAAf,EAAIC,IAAJ,GACQE,QAIJ,EAJgB,CAACD,YAIjB,EAFIpC,MAAOC,CAAAA,KAAP,CAAa,SAAb,CAEJ,CAAIkC,IAAA,CAAQnC,MAAR,CAAJ,GACIwB,UADJ,CAlKAc,QAkKA,CALJ,CAtBG,CATJ,IAwCA,IAAI,WAAYC,CAAAA,IAAZ,CAAiBP,IAAjB,CAAJ,EAA4B3B,eAAA,CAAgBL,MAAhB,CAAwB,CAAA,CAAxB,CAA5B,CACHwB,UAAA,CAvKQc,QAsKL,KAEA,IAAU,GAAV,EAAIN,IAAJ,CACHhC,MAAOwC,CAAAA,SAAP,EACA,CAAAhB,UAAA,CA3KeK,SAyKZ,KAGA,IAAU,GAAV,EAAIG,IAAJ,EAAuB,GAAvB,EAAiBA,IAAjB,CAA4B,CAC7BS,UAAAA,CAAU,EAQZ,KARoBC,YAQpB,CARiC1C,MAAO2C,CAAAA,MAAP,EAQjC,CAAmD,IAAnD,GAAQC,QAAR,CAAiB5C,MAAOkC,CAAAA,GAAP,CAAW,gBAAX,CAAjB,EAAA,CACIO,UAAA,EAAWG,QAGM,EAArB,CAAIH,UAAQ/C,CAAAA,MAAZ,EAA0BkB,UAAWiC,CAAAA,oBAAX,CAAgCJ,UAAhC,CAA1B;AAEcpB,KAvKxBN,CAAAA,WAqKU,CArKI,IAAIpB,UAAJ,CAuKiB+C,YAvKjB,CAlBDI,CAkBC,CAuKgDd,IAvKhD,CAuKUX,KAvKyBN,CAAAA,WAAnC,CAqKJ,EAKIf,MAAOuB,CAAAA,QAAP,EACA,CAAIvB,MAAO+C,CAAAA,GAAP,EAAJ,EAAqC,GAArC,EAAoB/C,MAAO8B,CAAAA,IAAP,EAApB,CAGcT,KA9K5BN,CAAAA,WA2Kc,CA3KA,IAAIpB,UAAJ,CA8KqB+C,YA9KrB,CA8KkC,CA9KlC,CA8KqCV,IA9KrC,CA8KcX,KA9KqBN,CAAAA,WAAnC,CA2KA,EAKqB,UAhLzC,CAgLyC2B,YAhLzC,CAgLsD1C,MAAOgD,CAAAA,OAAP,EAAiBtD,CAAAA,MAhLvE,CAgLkC2B,KAhL5BN,CAAAA,WAAN,CAAoB,IAAIpB,UAAJ,CAAeC,UAAf,CAgL2DoC,IAhL3D,CAgLcX,KAhLqBN,CAAAA,WAAnC,CA2KA,CANJ,CAcAf,OAAOO,CAAAA,MAAP,CAAcP,MAAOgD,CAAAA,OAAP,EAAiBtD,CAAAA,MAA/B,CAAwC,CAAxC,CAEgC,SAAhC,EAAG,MAAO2B,MAAMH,CAAAA,YAAhB,EAA0CG,KAAMH,CAAAA,YAAN,EACZ,SAA9B,EAAG,MAAOG,MAAMF,CAAAA,UAAhB,EAAwCE,KAAMF,CAAAA,UAAN,EAExCK,WAAA,CA3M4ByB,SA2KG,CAA5B,IAiCU,GAAV,EAAIjB,IAAJ;AAAuB,GAAvB,EAAiBA,IAAjB,EACHR,UACA,CA9M4ByB,SA8M5B,CAAyB,IAAzB,EAAI5B,KAAMN,CAAAA,WAAV,EAAiCM,KAAMN,CAAAA,WAAYlB,CAAAA,IAAnD,GAAkE,GAAN,EAAAmC,IAAA,CAAY,GAAZ,CAAkB,GAA9E,IACaX,KAxLvBN,CAAAA,WAgMc,CARSM,KAxLHN,CAAAA,WAAYjB,CAAAA,IAgMlB,CANgC,QAMhC,EANG,MAAOuB,MAAMH,CAAAA,YAMhB,EAL+B,CAK/B,EALO,EAAEG,KAAMH,CAAAA,YAKf,GAJQM,UACA,CArNGK,SAqNH,CAAAR,KAAMH,CAAAA,YAAN,CAAqB,CAAA,CAG7B,EAA8B,QAA9B,EAAG,MAAOG,MAAMF,CAAAA,UAAhB,EAC6B,CAD7B,EACO,EAAEE,KAAMF,CAAAA,UADf,GAEQK,UACA,CA1NrBS,MA0NqB,CAAAZ,KAAMF,CAAAA,UAAN,CAAmB,CAAA,CAH3B,CATJ,CAFG,GAmBHnB,MAAO+B,CAAAA,QAAP,CAAgB,4BAAhB,CAGI,CAAAP,UAAA,CADAb,QAAJ,EAAgBA,QAASkC,CAAAA,oBAAT,CAA8B7C,MAAOgD,CAAAA,OAAP,EAA9B,CAAhB,CAlONE,SAkOM,CAEoB,UAvBjB,CAnIf,CA6JA,MAAqC,QAA9B;AAAC,MAAO7B,MAAMH,CAAAA,YAAd,CAvOoBW,SAuOpB,CAAiF,QAA5B,EAAC,MAAOR,MAAMF,CAAAA,UAAd,CAtOzDc,MAsOyD,CAA+CT,UAzK/E,CAX7B,CAuLH5B,OAAQA,QAAS,CAACyB,KAAD,CAAQ,CACrB,MAAyB,KAAzB,EAAIA,KAAMN,CAAAA,WAAV,CAAsCM,KAAML,CAAAA,WAA5C,CACOK,KAAMN,CAAAA,WAAYnB,CAAAA,MAFJ,CAvLtB,CA4LHuD,cAAe,CAACC,MAAO,UAAR,CA5LZ,CA6LHC,YAAa,IA7LV,CApDiC,CAA5C,CAqPAnE,WAAWoE,CAAAA,UAAX,CAAsB,eAAtB,CAAuC,QAAvC,CAxPwB,CAPxB,CAR8G;",
"sources":["node_modules/codemirror/mode/scheme/scheme.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$codemirror$mode$scheme$scheme\"] = function(global,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var keywords = makeKeywords(\"\u03bb case-lambda call/cc class define-class exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda\");\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\n    function isBinaryNumber (stream) {\n        return stream.match(binaryMatcher);\n    }\n\n    function isOctalNumber (stream) {\n        return stream.match(octalMatcher);\n    }\n\n    function isDecimalNumber (stream, backup) {\n        if (backup === true) {\n            stream.backUp(1);\n        }\n        return stream.match(decimalMatcher);\n    }\n\n    function isHexNumber (stream) {\n        return stream.match(hexMatcher);\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false,\n                sExprComment: false,\n                sExprQuote: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in scheme-string mode\n                    break;\n                case \"comment\": // comment parsing mode\n                    var next, maybeEnd = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"#\" && maybeEnd) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        maybeEnd = (next == \"|\");\n                    }\n                    returnType = COMMENT;\n                    break;\n                case \"s-expr-comment\": // s-expr commenting mode\n                    state.mode = false;\n                    if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n                        // actually start scheme s-expr commenting mode\n                        state.sExprComment = 0;\n                    }else{\n                        // if not we just comment the entire of the next token\n                        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n                        returnType = COMMENT;\n                        break;\n                    }\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n\n                    } else if (ch == \"'\") {\n                        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\n                            if (typeof state.sExprQuote != \"number\") {\n                                state.sExprQuote = 0;\n                            } // else already in a quoted expression\n                            returnType = ATOM;\n                        } else {\n                            stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                            returnType = ATOM;\n                        }\n                    } else if (ch == '#') {\n                        if (stream.eat(\"|\")) {                    // Multi-line comment\n                            state.mode = \"comment\"; // toggle to comment mode\n                            returnType = COMMENT;\n                        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n                            returnType = ATOM;\n                        } else if (stream.eat(';')) {                // S-Expr comment\n                            state.mode = \"s-expr-comment\";\n                            returnType = COMMENT;\n                        } else {\n                            var numTest = null, hasExactness = false, hasRadix = true;\n                            if (stream.eat(/[ei]/i)) {\n                                hasExactness = true;\n                            } else {\n                                stream.backUp(1);       // must be radix specifier\n                            }\n                            if (stream.match(/^#b/i)) {\n                                numTest = isBinaryNumber;\n                            } else if (stream.match(/^#o/i)) {\n                                numTest = isOctalNumber;\n                            } else if (stream.match(/^#x/i)) {\n                                numTest = isHexNumber;\n                            } else if (stream.match(/^#d/i)) {\n                                numTest = isDecimalNumber;\n                            } else if (stream.match(/^[-+0-9.]/, false)) {\n                                hasRadix = false;\n                                numTest = isDecimalNumber;\n                            // re-consume the intial # if all matches failed\n                            } else if (!hasExactness) {\n                                stream.eat('#');\n                            }\n                            if (numTest != null) {\n                                if (hasRadix && !hasExactness) {\n                                    // consume optional exactness after radix\n                                    stream.match(/^#[ei]/i);\n                                }\n                                if (numTest(stream))\n                                    returnType = NUMBER;\n                            }\n                        }\n                    } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n                        returnType = NUMBER;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (ch == \"(\" || ch == \"[\") {\n                      var keyWord = ''; var indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation 1 space after\n                                pushStack(state, indentTemp + 1, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n                        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                            popStack(state);\n\n                            if(typeof state.sExprComment == \"number\"){\n                                if(--state.sExprComment == 0){\n                                    returnType = COMMENT; // final closing bracket\n                                    state.sExprComment = false; // turn off s-expr commenting mode\n                                }\n                            }\n                            if(typeof state.sExprQuote == \"number\"){\n                                if(--state.sExprQuote == 0){\n                                    returnType = ATOM; // final closing bracket\n                                    state.sExprQuote = false; // turn off s-expr quote mode\n                                }\n                            }\n                        }\n                    } else {\n                        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else returnType = \"variable\";\n                    }\n            }\n            return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","mod","define","amd","CodeMirror","defineMode","makeKeywords","str","obj","words","split","i","length","stateStack","indent","type","prev","isBinaryNumber","stream","match","binaryMatcher","isOctalNumber","octalMatcher","isDecimalNumber","backup","backUp","decimalMatcher","isHexNumber","hexMatcher","keywords","indentKeys","RegExp","startState","indentStack","indentation","mode","sExprComment","sExprQuote","token","state","sol","eatSpace","returnType","next","escaped","STRING","maybeEnd","COMMENT","peek","eatWhile","ch","ATOM","eat","numTest","hasExactness","hasRadix","NUMBER","test","skipToEnd","keyWord","indentTemp","column","letter","propertyIsEnumerable","INDENT_WORD_SKIP","eol","current","BRACKET","BUILTIN","closeBrackets","pairs","lineComment","defineMIME"]
}
