shadow$provide.module$node_modules$chrono_node$dist$locales$de$parsers$DECasualDateParser=function(global,require,module,exports){var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);Object.defineProperty(o,k2,{enumerable:!0,get:function(){return m[k]}})}:function(o,m,k,k2){void 0===k2&&(k2=k);o[k2]=m[k]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,"default",{enumerable:!0,value:v})}:function(o,
v){o["default"]=v});global=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)"default"!==k&&Object.prototype.hasOwnProperty.call(mod,k)&&__createBinding(result,mod,k);__setModuleDefault(result,mod);return result};module=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});const dayjs_1=module(require("module$node_modules$dayjs$dayjs_min")),
AbstractParserWithWordBoundary_1=require("module$node_modules$chrono_node$dist$common$parsers$AbstractParserWithWordBoundary"),dayjs_2=require("module$node_modules$chrono_node$dist$utils$dayjs"),DECasualTimeParser_1=module(require("module$node_modules$chrono_node$dist$locales$de$parsers$DECasualTimeParser")),references=global(require("module$node_modules$chrono_node$dist$common$casualReferences")),PATTERN=RegExp("(jetzt|heute|morgen|übermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?\x3d\\W|$)",
"i");class DECasualDateParser extends AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking{innerPattern(context){return PATTERN}innerExtract(context,match){let targetDate=dayjs_1.default(context.refDate);const dateKeyword=(match[1]||"").toLowerCase();match=(match[2]||"").toLowerCase();let component=context.createParsingComponents();switch(dateKeyword){case "jetzt":component=references.now(context.refDate);break;case "heute":component=references.today(context.refDate);break;case "morgen":dayjs_2.assignTheNextDay(component,
targetDate);break;case "übermorgen":case "uebermorgen":targetDate=targetDate.add(1,"day");dayjs_2.assignTheNextDay(component,targetDate);break;case "gestern":targetDate=targetDate.add(-1,"day");dayjs_2.assignSimilarDate(component,targetDate);dayjs_2.implySimilarTime(component,targetDate);break;case "vorgestern":targetDate=targetDate.add(-2,"day");dayjs_2.assignSimilarDate(component,targetDate);dayjs_2.implySimilarTime(component,targetDate);break;default:dateKeyword.match(/letzte\s*nacht/)&&(6<targetDate.hour()&&
(targetDate=targetDate.add(-1,"day")),dayjs_2.assignSimilarDate(component,targetDate),component.imply("hour",0))}match&&(component=DECasualTimeParser_1.default.extractTimeComponents(component,match));return component}}exports.default=DECasualDateParser}
//# sourceMappingURL=module$node_modules$chrono_node$dist$locales$de$parsers$DECasualDateParser.js.map
