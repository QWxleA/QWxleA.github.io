shadow$provide.module$node_modules$lie$lib$browser=function(global,require,module,exports){function INTERNAL(){}function Promise(resolver){if("function"!==typeof resolver)throw new TypeError("resolver must be a function");this.state=PENDING;this.queue=[];this.outcome=void 0;resolver!==INTERNAL&&safelyResolveThenable(this,resolver)}function QueueItem(promise,onFulfilled,onRejected){this.promise=promise;"function"===typeof onFulfilled&&(this.onFulfilled=onFulfilled,this.callFulfilled=this.otherCallFulfilled);
"function"===typeof onRejected&&(this.onRejected=onRejected,this.callRejected=this.otherCallRejected)}function unwrap(promise,func,value){immediate(function(){try{var returnValue=func(value)}catch(e){return handlers.reject(promise,e)}returnValue===promise?handlers.reject(promise,new TypeError("Cannot resolve promise with itself")):handlers.resolve(promise,returnValue)})}function getThen(obj){var then=obj&&obj.then;if(obj&&("object"===typeof obj||"function"===typeof obj)&&"function"===typeof then)return function(){then.apply(obj,
arguments)}}function safelyResolveThenable(self,thenable){function onError(value){called||(called=!0,handlers.reject(self,value))}function onSuccess(value){called||(called=!0,handlers.resolve(self,value))}var called=!1,result=tryCatch(function(){thenable(onSuccess,onError)});"error"===result.status&&onError(result.value)}function tryCatch(func,value){var out={};try{out.value=func(value),out.status="success"}catch(e){out.status="error",out.value=e}return out}var immediate=require("module$node_modules$immediate$lib$browser"),
handlers={},REJECTED=["REJECTED"],FULFILLED=["FULFILLED"],PENDING=["PENDING"];module.exports=Promise;Promise.prototype["finally"]=function(callback){if("function"!==typeof callback)return this;var p=this.constructor;return this.then(function(value){return p.resolve(callback()).then(function(){return value})},function(reason){return p.resolve(callback()).then(function(){throw reason;})})};Promise.prototype["catch"]=function(onRejected){return this.then(null,onRejected)};Promise.prototype.then=function(onFulfilled,
onRejected){if("function"!==typeof onFulfilled&&this.state===FULFILLED||"function"!==typeof onRejected&&this.state===REJECTED)return this;var promise=new this.constructor(INTERNAL);this.state!==PENDING?unwrap(promise,this.state===FULFILLED?onFulfilled:onRejected,this.outcome):this.queue.push(new QueueItem(promise,onFulfilled,onRejected));return promise};QueueItem.prototype.callFulfilled=function(value){handlers.resolve(this.promise,value)};QueueItem.prototype.otherCallFulfilled=function(value){unwrap(this.promise,
this.onFulfilled,value)};QueueItem.prototype.callRejected=function(value){handlers.reject(this.promise,value)};QueueItem.prototype.otherCallRejected=function(value){unwrap(this.promise,this.onRejected,value)};handlers.resolve=function(self,value){var result=tryCatch(getThen,value);if("error"===result.status)return handlers.reject(self,result.value);if(result=result.value)safelyResolveThenable(self,result);else{self.state=FULFILLED;self.outcome=value;result=-1;for(var len=self.queue.length;++result<
len;)self.queue[result].callFulfilled(value)}return self};handlers.reject=function(self,error){self.state=REJECTED;self.outcome=error;for(var i=-1,len=self.queue.length;++i<len;)self.queue[i].callRejected(error);return self};Promise.resolve=function(value){return value instanceof this?value:handlers.resolve(new this(INTERNAL),value)};Promise.reject=function(reason){var promise=new this(INTERNAL);return handlers.reject(promise,reason)};Promise.all=function(iterable){function allResolver(value,i){self.resolve(value).then(function(outValue){values[i]=
outValue;++resolved!==len||called||(called=!0,handlers.resolve(promise,values))},function(error){called||(called=!0,handlers.reject(promise,error))})}var self=this;if("[object Array]"!==Object.prototype.toString.call(iterable))return this.reject(new TypeError("must be an array"));var len=iterable.length,called=!1;if(!len)return this.resolve([]);for(var values=Array(len),resolved=0,i$jscomp$0=-1,promise=new this(INTERNAL);++i$jscomp$0<len;)allResolver(iterable[i$jscomp$0],i$jscomp$0);return promise};
Promise.race=function(iterable){function resolver(value){self.resolve(value).then(function(response){called||(called=!0,handlers.resolve(promise,response))},function(error){called||(called=!0,handlers.reject(promise,error))})}var self=this;if("[object Array]"!==Object.prototype.toString.call(iterable))return this.reject(new TypeError("must be an array"));var len=iterable.length,called=!1;if(!len)return this.resolve([]);for(var i=-1,promise=new this(INTERNAL);++i<len;)resolver(iterable[i]);return promise}}
//# sourceMappingURL=module$node_modules$lie$lib$browser.js.map
