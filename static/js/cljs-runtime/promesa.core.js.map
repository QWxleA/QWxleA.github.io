{"version":3,"sources":["promesa/core.cljc"],"mappings":"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","names":["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__65287","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-map","cljs.core/identity","G__65308","promesa.core/create","f","d","e65317","G__65320","p1__65295#","G__65321","p1__65296#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e65362","G__65363","p1__65298#","G__65364","p1__65300#","promesa.core/promise?","promesa.impl/*default-promise*","promesa.core/deferred?","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","promesa.core/wrap","G__65382","promesa.core/then","promesa.protocols/-bind","cljs.core.comp","G__65426","promesa.core/then'","G__65450","promesa.core/bind","promesa.core.then","G__65501","promesa.core/map","G__65533","promesa.core/mapcat","G__65544","promesa.core/chain","args-arr__4885__auto__","len__4864__auto__","i__4865__auto__","argseq__4886__auto__","cljs.core/IndexedSeq","seq65541","G__65542","cljs.core/first","cljs.core/next","G__65543","self__4851__auto__","fs","p1__65538#","p2__65539#","cljs.core.reduce","cljs.core/cons","G__65556","promesa.core/chain'","seq65552","G__65554","G__65555","promesa.core.then_SINGLEQUOTE_","G__65565","promesa.core/handle","promesa.protocols/-handle","G__65569","promesa.core/finally","promesa.protocols/-finally","G__65576","promesa.core/catch","promesa.protocols/-catch","pred-or-type","accept?","p1__65573#","cljs.core/ifn?","G__65585","promesa.core/error","promesa.core.catch$","type","promesa.core/err","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/race","cljs.core.map","G__65595","promesa.core/any","promesa.core.any","default","state","cljs.core.atom","cljs.core/count","promesa.core.create","resolve","reject","seq__65600","cljs.core/seq","chunk__65601","count__65602","i__65603","temp__5720__auto__","cljs.core/chunked-seq?","c__4679__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","promesa.core.promise","cljs.core/deref","cljs.core.swap_BANG_","cljs.core.assoc","cljs.core.update","cljs.core/dec","cljs.core/conj","map__65632","cljs.core/--destructure-map","cljs.core.get","map__65636","resolved","counter","rejections","cljs.core/not","cljs.core._EQ_","G__65635","G__65637","cljs.core.ex_info","G__65642","promesa.core/run!","coll","promesa.core.run_BANG_","promesa.exec/current-thread-executor","p1__65638#","p2__65639#","_","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__65647","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core.conj","e65648","cljs.core.apply","promesa.core/TimeoutException","message","it","goog/inherits","G__65651","promesa.core/timeout","t","promesa.core.timeout","promesa.exec/default-scheduler","scheduler","timeout","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","G__65653","promesa.core/delay","promesa.core.delay","js/promesa","js/promesa.core","js/promesa.core.INTERNAL_LOOP_FN_NAME","promesa.core/INTERNAL_LOOP_FN_NAME","cljs.core.gensym"],"sourcesContent":[";; Copyright (c) 2015-2019 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur])\n  (:require [promesa.protocols :as pt]\n            [clojure.core :as c]\n            [promesa.exec :as exec]\n            [promesa.impl :as impl])\n            ;; [promesa.impl.scheduler :as ps])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import java.util.concurrent.CompletableFuture\n              java.util.concurrent.CompletionStage\n              java.util.concurrent.TimeoutException)))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v] (pt/-promise v))\n  ([v executor]\n   (pt/-map v identity executor)))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Exception :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n(defn deferred?\n  \"Return true if `v` is a promise instance (alias to `promise?`.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn wrap\n  [v]\n  (if (promise? v)\n    v\n    (pt/-promise v)))\n\n(defn then\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.\"\n  ([p f]\n   (pt/-bind p (comp wrap f)))\n  ([p f executor]\n   (pt/-bind p (comp wrap f) executor)))\n\n(defn then'\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.\"\n  ([p f] (pt/-map p f))\n  ([p f executor] (pt/-map p f executor)))\n\n(defn bind\n  \"Backward compatibility alias to `then`.\"\n  ([p f] (then p f))\n  ([p f e] (then p f e)))\n\n(defn map\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.\"\n  ([f p] (pt/-map p f))\n  ([executor f p] (pt/-map p f executor)))\n\n(defn mapcat\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.\"\n  ([f p] (pt/-bind p f))\n  ([executor f p] (pt/-bind p f executor)))\n\n(defn chain\n  \"Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce #(then %1 %2) p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce pt/-map p (cons f fs))))\n\n(defn handle\n  \"Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.\"\n  ([p f] (pt/-handle p f))\n  ([p f executor] (pt/-handle p f executor)))\n\n(defn finally\n  \"Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.\"\n  ([p f] (pt/-finally p f))\n  ([p f executor] (pt/-finally p f executor)))\n\n(defn catch\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-catch p f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-catch p (fn [e]\n                    (if (accept? e)\n                      (f e)\n                      (impl/rejected e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (-> (.all impl/*default-promise* (into-array promises))\n               (then' vec))\n     :clj (c/let [promises (clojure.core/map pt/-promise promises)]\n            (then' (->> (into-array CompletableFuture promises)\n                        (CompletableFuture/allOf))\n                   (fn [_]\n                     (mapv pt/-extract promises))))))\n\n(defn race\n  [promises]\n  #?(:cljs (.race impl/*default-promise* (into-array (cljs.core/map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (->> (clojure.core/map pt/-promise promises)\n                                        (into-array CompletableFuture)))))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [state (atom {:resolved false\n                      :counter (count promises)\n                      :rejections []})]\n     (create\n      (fn [resolve reject]\n        (doseq [p promises]\n          (-> (promise p)\n              (then (fn [v]\n                      (when-not (:resolved @state)\n                        (swap! state (fn [state]\n                                       (-> state\n                                           (assoc :resolved true)\n                                           (update :counter dec))))\n                        (resolve v))))\n              (catch (fn [e]\n                       (swap! state (fn [state]\n                                      (-> state\n                                          (update  :counter dec)\n                                          (update :rejections conj e))))\n                       (c/let [{:keys [resolved counter rejections]} @state]\n                         (when (and (not resolved) (= counter 0))\n                           (if (= default ::default)\n                             (reject (ex-info \"No promises resolved\"\n                                              {:rejections rejections}))\n                             (resolve default)))))))))))))\n\n(defn run!\n  \"A promise aware run! function.\"\n  ([f coll] (run! f coll exec/current-thread-executor))\n  ([f coll executor] (reduce #(then %1 (fn [_] (f %2))) (promise nil executor) coll)))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError\"\n  ([p t] (timeout p t ::default exec/default-scheduler))\n  ([p t v] (timeout p t v exec/default-scheduler))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)]\n     (exec/schedule! scheduler t #(if (= v ::default)\n                                    (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                    (resolve! timeout v)))\n     (race [p timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached.\"\n  ([t] (delay t nil exec/default-scheduler))\n  ([t v] (delay t v exec/default-scheduler))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n#?(:clj\n   (defmacro do!\n     \"Execute potentially side effectful code and return a promise\n     resolved to the last expression. Always awaiting the result of each\n     expression.\"\n     [& exprs]\n     `(p/bind nil (fn [_#]\n                    ~(condp = (count exprs)\n                       0 `(pt/-promise nil)\n                       1 `(pt/-promise ~(first exprs))\n                       (reduce (fn [acc e]\n                                 `(bind ~e (fn [_#] ~acc)))\n                               `(pt/-promise ~(last exprs))\n                               (reverse (butlast exprs))))))))\n\n#?(:clj\n   (defmacro let\n     \"A `let` alternative that always returns promise and waits for\n     all the promises on the bindings.\"\n     [bindings & body]\n     `(p/bind nil (fn [_#]\n                    ~(->> (reverse (partition 2 bindings))\n                          (reduce (fn [acc [l r]]\n                                    `(bind ~r (fn [~l] ~acc)))\n                                  `(pt/-promise (do ~@body))))))))\n\n#?(:clj (def #^{:macro true :doc \"A backward compatibility alias for `let`.\"}\n          alet #'let))\n\n\n#?(:clj\n   (defmacro plet\n     \"A parallel let; executes all the bindings in parallel and\n     when all bindings are resolved, executes the body.\"\n     [bindings & body]\n     `(p/bind nil (fn [_#]\n                    ~(c/let [bindings (partition 2 bindings)]\n                       `(all ~(mapv second bindings)\n                             (fn [[~@(mapv first bindings)]]\n                               ~@body)))))))\n\n#?(:clj\n   (defmacro future\n     \"Analogous to `clojure.core/future` that returns a promise instance\n     instead of the `Future`. Usefull for execute synchronous code in a\n     separate thread (also works in cljs).\"\n     [& body]\n     `(-> (exec/submit! (fn []\n                          (c/let [f# (fn [] ~@body)]\n                            (pt/-promise (f#)))))\n          (pt/-bind identity))))\n\n\n(defonce ^:private INTERNAL_LOOP_FN_NAME\n  (gensym 'internal-loop-fn-name))\n\n(defmacro loop\n  \"Analogous to `clojure.core/loop`.\"\n  [bindings & body]\n  (c/let [bindings (partition 2 2 bindings)\n          names (mapv first bindings)\n          fvals (mapv second bindings)\n          syms (mapv gensym names)]\n    `(do!\n      (letfn [(~INTERNAL_LOOP_FN_NAME [~@syms]\n               (-> (p/all [~@syms])\n                   (p/then (fn [[~@names]] (do! ~@body)))))]\n        (~INTERNAL_LOOP_FN_NAME ~@fvals)))))\n\n(defmacro recur\n  [& args]\n  `(~INTERNAL_LOOP_FN_NAME ~@args))\n\n"]}