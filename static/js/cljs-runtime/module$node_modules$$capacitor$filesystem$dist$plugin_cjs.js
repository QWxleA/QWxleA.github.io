shadow$provide.module$node_modules$$capacitor$filesystem$dist$plugin_cjs=function(global,require,module,exports){function resolve$jscomp$0(path){const newPosix=[];path.split("/").filter(item=>"."!==item).forEach(item=>{".."===item&&0<newPosix.length&&".."!==newPosix[newPosix.length-1]?newPosix.pop():newPosix.push(item)});return newPosix.join("/")}function isPathParent(parent,children){parent=resolve$jscomp$0(parent);children=resolve$jscomp$0(children);const pathsA=parent.split("/"),pathsB=children.split("/");
return parent!==children&&pathsA.every((value,index)=>value===pathsB[index])}Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$$capacitor$core$dist$index_cjs");exports.Directory=void 0;(function(Directory){Directory.Documents="DOCUMENTS";Directory.Data="DATA";Directory.Cache="CACHE";Directory.External="EXTERNAL";Directory.ExternalStorage="EXTERNAL_STORAGE"})(exports.Directory||(exports.Directory={}));exports.Encoding=void 0;(function(Encoding){Encoding.UTF8=
"utf8";Encoding.ASCII="ascii";Encoding.UTF16="utf16"})(exports.Encoding||(exports.Encoding={}));require=exports.Directory;module=exports.Encoding;const Filesystem=global.registerPlugin("Filesystem",{web:()=>Promise.resolve().then(function(){return web}).then(m=>new m.FilesystemWeb)});class FilesystemWeb extends global.WebPlugin{constructor(){super(...arguments);this.DB_VERSION=1;this.DB_NAME="Disc";this._writeCmds=["add","put","delete"]}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in
window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((resolve,reject)=>{const request=indexedDB.open(this.DB_NAME,this.DB_VERSION);request.onupgradeneeded=FilesystemWeb.doUpgrade;request.onsuccess=()=>{this._db=request.result;resolve(request.result)};request.onerror=()=>reject(request.error);request.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(event){event=event.target.result;event.objectStoreNames.contains("FileStorage")&&event.deleteObjectStore("FileStorage");
event.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}async dbRequest(cmd,args){const readFlag=-1!==this._writeCmds.indexOf(cmd)?"readwrite":"readonly";return this.initDb().then(conn=>new Promise((resolve,reject)=>{const req=conn.transaction(["FileStorage"],readFlag).objectStore("FileStorage")[cmd](...args);req.onsuccess=()=>resolve(req.result);req.onerror=()=>reject(req.error)}))}async dbIndexRequest(indexName,cmd,args){const readFlag=-1!==this._writeCmds.indexOf(cmd)?
"readwrite":"readonly";return this.initDb().then(conn=>new Promise((resolve,reject)=>{const req=conn.transaction(["FileStorage"],readFlag).objectStore("FileStorage").index(indexName)[cmd](...args);req.onsuccess=()=>resolve(req.result);req.onerror=()=>reject(req.error)}))}getPath(directory,uriPath){const cleanedUriPath=void 0!==uriPath?uriPath.replace(/^[/]+|[/]+$/g,""):"";let fsPath="";void 0!==directory&&(fsPath+="/"+directory);""!==uriPath&&(fsPath+="/"+cleanedUriPath);return fsPath}async clear(){(await this.initDb()).transaction(["FileStorage"],
"readwrite").objectStore("FileStorage").clear()}async readFile(options){options=this.getPath(options.directory,options.path);options=await this.dbRequest("get",[options]);if(void 0===options)throw Error("File does not exist.");return{data:options.content?options.content:""}}async writeFile(options){var path=this.getPath(options.directory,options.path);const data=options.data,doRecursive=options.recursive;var occupiedEntry=await this.dbRequest("get",[path]);if(occupiedEntry&&"directory"===occupiedEntry.type)throw"The supplied path is a directory.";
occupiedEntry=options.encoding;const parentPath=path.substr(0,path.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[parentPath])){var subDirIndex=parentPath.indexOf("/",1);-1!==subDirIndex&&(subDirIndex=parentPath.substr(subDirIndex),await this.mkdir({path:subDirIndex,directory:options.directory,recursive:doRecursive}))}options=Date.now();path={path,folder:parentPath,type:"file",size:data.length,ctime:options,mtime:options,content:!occupiedEntry&&0<=data.indexOf(",")?data.split(",")[1]:data};
await this.dbRequest("put",[path]);return{uri:path.path}}async appendFile(options){const path=this.getPath(options.directory,options.path);let data=options.data;const parentPath=path.substr(0,path.lastIndexOf("/")),now=Date.now();let ctime=now;const occupiedEntry=await this.dbRequest("get",[path]);if(occupiedEntry&&"directory"===occupiedEntry.type)throw"The supplied path is a directory.";if(void 0===await this.dbRequest("get",[parentPath])){var subDirIndex=parentPath.indexOf("/",1);-1!==subDirIndex&&
(subDirIndex=parentPath.substr(subDirIndex),await this.mkdir({path:subDirIndex,directory:options.directory,recursive:!0}))}void 0!==occupiedEntry&&(data=occupiedEntry.content+data,ctime=occupiedEntry.ctime);await this.dbRequest("put",[{path,folder:parentPath,type:"file",size:data.length,ctime,mtime:now,content:data}])}async deleteFile(options){options=this.getPath(options.directory,options.path);if(void 0===await this.dbRequest("get",[options]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder",
"getAllKeys",[IDBKeyRange.only(options)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[options])}async mkdir(options){const path=this.getPath(options.directory,options.path),doRecursive=options.recursive,parentPath=path.substr(0,path.lastIndexOf("/"));var depth=(path.match(/\//g)||[]).length;const parentEntry=await this.dbRequest("get",[parentPath]),occupiedEntry=await this.dbRequest("get",[path]);if(1===depth)throw Error("Cannot create Root directory");if(void 0!==occupiedEntry)throw Error("Current directory does already exist.");
if(!doRecursive&&2!==depth&&void 0===parentEntry)throw Error("Parent directory must exist");doRecursive&&2!==depth&&void 0===parentEntry&&(depth=parentPath.substr(parentPath.indexOf("/",1)),await this.mkdir({path:depth,directory:options.directory,recursive:doRecursive}));options=Date.now();await this.dbRequest("put",[{path,folder:parentPath,type:"directory",size:0,ctime:options,mtime:options}])}async rmdir(options){const {path,directory,recursive}=options;options=this.getPath(directory,path);var entry$jscomp$0=
await this.dbRequest("get",[options]);if(void 0===entry$jscomp$0)throw Error("Folder does not exist.");if("directory"!==entry$jscomp$0.type)throw Error("Requested path is not a directory");entry$jscomp$0=await this.readdir({path,directory});if(0!==entry$jscomp$0.files.length&&!recursive)throw Error("Folder is not empty");for(const entry of entry$jscomp$0.files)entry$jscomp$0=`${path}/${entry}`,"file"===(await this.stat({path:entry$jscomp$0,directory})).type?await this.deleteFile({path:entry$jscomp$0,
directory}):await this.rmdir({path:entry$jscomp$0,directory,recursive});await this.dbRequest("delete",[options])}async readdir(options){const path=this.getPath(options.directory,options.path),entry=await this.dbRequest("get",[path]);if(""!==options.path&&void 0===entry)throw Error("Folder does not exist.");return{files:(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(path)])).map(e=>e.substring(path.length+1))}}async getUri(options){options=this.getPath(options.directory,options.path);
let entry=await this.dbRequest("get",[options]);void 0===entry&&(entry=await this.dbRequest("get",[options+"/"]));return{uri:(null===entry||void 0===entry?void 0:entry.path)||options}}async stat(options){options=this.getPath(options.directory,options.path);let entry=await this.dbRequest("get",[options]);void 0===entry&&(entry=await this.dbRequest("get",[options+"/"]));if(void 0===entry)throw Error("Entry does not exist.");return{type:entry.type,size:entry.size,ctime:entry.ctime,mtime:entry.mtime,
uri:entry.path}}async rename(options){return this._copy(options,!0)}async copy(options){return this._copy(options,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(options,doRename=!1){let {toDirectory}=options;const {to,from,directory:fromDirectory}=options;if(!to||!from)throw Error("Both to and from must be provided");toDirectory||=fromDirectory;options=this.getPath(fromDirectory,from);var toPath=this.getPath(toDirectory,
to);if(options!==toPath){if(isPathParent(options,toPath))throw Error("To path cannot contain the from path");try{var toObj=await this.stat({path:to,directory:toDirectory})}catch(e){if(options=to.split("/"),options.pop(),toPath=options.join("/"),0<options.length&&"directory"!==(await this.stat({path:toPath,directory:toDirectory})).type)throw Error("Parent directory of the to path is a file");}if(toObj&&"directory"===toObj.type)throw Error("Cannot overwrite a directory with a file");options=await this.stat({path:from,
directory:fromDirectory});toPath=async(path,ctime,mtime)=>{path=this.getPath(toDirectory,path);path=await this.dbRequest("get",[path]);path.ctime=ctime;path.mtime=mtime;await this.dbRequest("put",[path])};var ctime$jscomp$0=options.ctime?options.ctime:Date.now();switch(options.type){case "file":var file=await this.readFile({path:from,directory:fromDirectory});doRename&&await this.deleteFile({path:from,directory:fromDirectory});await this.writeFile({path:to,directory:toDirectory,data:file.data});doRename&&
await toPath(to,ctime$jscomp$0,options.mtime);break;case "directory":if(toObj)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:to,directory:toDirectory,recursive:!1}),doRename&&await toPath(to,ctime$jscomp$0,options.mtime)}catch(e){}toObj=(await this.readdir({path:from,directory:fromDirectory})).files;for(file of toObj)await this._copy({from:`${from}/${file}`,to:`${to}/${file}`,directory:fromDirectory,toDirectory},doRename);doRename&&await this.rmdir({path:from,
directory:fromDirectory})}}}}FilesystemWeb._debug=!0;var web=Object.freeze({__proto__:null,FilesystemWeb});exports.Filesystem=Filesystem;exports.FilesystemDirectory=require;exports.FilesystemEncoding=module}
//# sourceMappingURL=module$node_modules$$capacitor$filesystem$dist$plugin_cjs.js.map
