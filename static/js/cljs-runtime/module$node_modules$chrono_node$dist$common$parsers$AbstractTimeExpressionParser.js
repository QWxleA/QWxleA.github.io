shadow$provide.module$node_modules$chrono_node$dist$common$parsers$AbstractTimeExpressionParser=function(global,require,module,exports){global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.AbstractTimeExpressionParser=void 0;const index_1=require("module$node_modules$chrono_node$dist$index"),dayjs_1=global(require("module$node_modules$dayjs$dayjs_min"));class AbstractTimeExpressionParser{constructor(strictMode=
!1){this.cachedFollowingTimePatten=this.cachedFollowingSuffix=this.cachedFollowingPhase=this.cachedPrimaryTimePattern=this.cachedPrimarySuffix=this.cachedPrimaryPrefix=null;this.strictMode=strictMode}primarySuffix(){return"(?\x3d\\W|$)"}followingSuffix(){return"(?\x3d\\W|$)"}pattern(context){return this.getPrimaryTimePatternThroughCache()}extract(context,match){const refDate=dayjs_1.default(context.refDate),result=context.createParsingResult(match.index+match[1].length,match[0].substring(match[1].length));
result.start.imply("day",refDate.date());result.start.imply("month",refDate.month()+1);result.start.imply("year",refDate.year());result.start=this.extractPrimaryTimeComponents(context,match);if(!result.start)return match.index+=match[0].length,null;match=context.text.substring(match.index+match[0].length);match=this.getFollowingTimePatternThroughCache().exec(match);if(!match||match[0].match(/^\s*([+-])\s*\d{3,4}$/))return this.checkAndReturnWithoutFollowingPattern(result);result.end=this.extractFollowingTimeComponents(context,
match,result);result.end&&result.end&&(result.text+=match[0]);return result}extractPrimaryTimeComponents(context,match,strict){context=context.createParsingComponents();let minute=0,meridiem=null;strict=parseInt(match[2]);if(null!=match[3]){if(1==match[3].length&&!match[6])return null;minute=parseInt(match[3])}else if(100<strict){if(this.strictMode)return null;minute=strict%100;strict=Math.floor(strict/100)}if(60<=minute||24<strict)return null;12<strict&&(meridiem=index_1.Meridiem.PM);if(null!=match[6]){if(12<
strict)return null;const ampm=match[6][0].toLowerCase();"a"==ampm&&(meridiem=index_1.Meridiem.AM,12==strict&&(strict=0));"p"==ampm&&(meridiem=index_1.Meridiem.PM,12!=strict&&(strict+=12))}context.assign("hour",strict);context.assign("minute",minute);null!==meridiem?context.assign("meridiem",meridiem):12>strict?context.imply("meridiem",index_1.Meridiem.AM):context.imply("meridiem",index_1.Meridiem.PM);if(null!=match[5]){strict=parseInt(match[5].substring(0,3));if(1E3<=strict)return null;context.assign("millisecond",
strict)}if(null!=match[4]){match=parseInt(match[4]);if(60<=match)return null;context.assign("second",match)}return context}extractFollowingTimeComponents(context,match,result){context=context.createParsingComponents();if(null!=match[5]){var millisecond=parseInt(match[5].substring(0,3));if(1E3<=millisecond)return null;context.assign("millisecond",millisecond)}if(null!=match[4]){millisecond=parseInt(match[4]);if(60<=millisecond)return null;context.assign("second",millisecond)}millisecond=parseInt(match[2]);
let minute=0,meridiem=-1;null!=match[3]?minute=parseInt(match[3]):100<millisecond&&(minute=millisecond%100,millisecond=Math.floor(millisecond/100));if(60<=minute||24<millisecond)return null;12<=millisecond&&(meridiem=index_1.Meridiem.PM);if(null!=match[6]){if(12<millisecond)return null;match=match[6][0].toLowerCase();"a"==match&&(meridiem=index_1.Meridiem.AM,12==millisecond&&(millisecond=0,context.isCertain("day")||context.imply("day",context.get("day")+1)));"p"==match&&(meridiem=index_1.Meridiem.PM,
12!=millisecond&&(millisecond+=12));result.start.isCertain("meridiem")||(meridiem==index_1.Meridiem.AM?(result.start.imply("meridiem",index_1.Meridiem.AM),12==result.start.get("hour")&&result.start.assign("hour",0)):(result.start.imply("meridiem",index_1.Meridiem.PM),12!=result.start.get("hour")&&result.start.assign("hour",result.start.get("hour")+12)))}context.assign("hour",millisecond);context.assign("minute",minute);0<=meridiem?context.assign("meridiem",meridiem):result.start.isCertain("meridiem")&&
12<result.start.get("hour")?result.start.get("hour")-12>millisecond?context.imply("meridiem",index_1.Meridiem.AM):12>=millisecond&&(context.assign("hour",millisecond+12),context.assign("meridiem",index_1.Meridiem.PM)):12<millisecond?context.imply("meridiem",index_1.Meridiem.PM):12>=millisecond&&context.imply("meridiem",index_1.Meridiem.AM);context.date().getTime()<result.start.date().getTime()&&context.imply("day",context.get("day")+1);return context}checkAndReturnWithoutFollowingPattern(result){if(result.text.match(/^\d$/))return null;
var endingWithNumbers=result.text.match(/[^\d:.](\d[\d.]+)$/);return endingWithNumbers&&(endingWithNumbers=endingWithNumbers[1],this.strictMode||endingWithNumbers.includes(".")&&!endingWithNumbers.match(/\d(\.\d{2})+$/)||24<parseInt(endingWithNumbers))?null:result}getPrimaryTimePatternThroughCache(){const primaryPrefix=this.primaryPrefix(),primarySuffix=this.primarySuffix();if(this.cachedPrimaryPrefix===primaryPrefix&&this.cachedPrimarySuffix===primarySuffix)return this.cachedPrimaryTimePattern;this.cachedPrimaryTimePattern=
new RegExp("(^|\\s|T)"+`${primaryPrefix}`+"(\\d{1,4})(?:(?:\\.|\\:|\\：)(\\d{1,2})(?:(?:\\:|\\：)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?"+`${primarySuffix}`,"i");this.cachedPrimaryPrefix=primaryPrefix;this.cachedPrimarySuffix=primarySuffix;return this.cachedPrimaryTimePattern}getFollowingTimePatternThroughCache(){const followingPhase=this.followingPhase(),followingSuffix=this.followingSuffix();if(this.cachedFollowingPhase===followingPhase&&this.cachedFollowingSuffix===followingSuffix)return this.cachedFollowingTimePatten;
this.cachedFollowingTimePatten=new RegExp(`^(${followingPhase})`+"(\\d{1,4})(?:(?:\\.|\\:|\\：)(\\d{1,2})(?:(?:\\.|\\:|\\：)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?"+`${followingSuffix}`,"i");this.cachedFollowingPhase=followingPhase;this.cachedFollowingSuffix=followingSuffix;return this.cachedFollowingTimePatten}}exports.AbstractTimeExpressionParser=AbstractTimeExpressionParser}
//# sourceMappingURL=module$node_modules$chrono_node$dist$common$parsers$AbstractTimeExpressionParser.js.map
