{
"version":3,
"file":"module$node_modules$jszip$lib$reader$DataReader.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,+CAAA,CAAoE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAI5GC,QAASA,WAAU,CAACC,IAAD,CAAO,CACtB,IAAKA,CAAAA,IAAL,CAAYA,IACZ,KAAKC,CAAAA,MAAL,CAAcD,IAAKC,CAAAA,MAEnB,KAAKC,CAAAA,IAAL,CADA,IAAKC,CAAAA,KACL,CADa,CAHS,CAF1B,IAAIC,MAAQR,OAAA,CAAQ,qCAAR,CAQZG,WAAWM,CAAAA,SAAX,CAAuB,CAMnBC,YAAaA,QAAQ,CAACC,MAAD,CAAS,CAC1B,IAAKC,CAAAA,UAAL,CAAgB,IAAKL,CAAAA,KAArB,CAA6BI,MAA7B,CAD0B,CANX,CAcnBC,WAAYA,QAAQ,CAACC,QAAD,CAAW,CAC3B,GAAI,IAAKR,CAAAA,MAAT,CAAkB,IAAKC,CAAAA,IAAvB,CAA8BO,QAA9B,EAAqD,CAArD,CAA0CA,QAA1C,CACI,KAAUC,MAAJ,CAAU,wCAAV,CAAkD,IAAKT,CAAAA,MAAvD,CAAgE,qBAAhE,CAAsFQ,QAAtF;AAAkG,oBAAlG,CAAN,CAFuB,CAdZ,CAwBnBE,SAAUA,QAAQ,CAACF,QAAD,CAAW,CACzB,IAAKD,CAAAA,UAAL,CAAgBC,QAAhB,CACA,KAAKN,CAAAA,KAAL,CAAaM,QAFY,CAxBV,CAiCnBG,KAAMA,QAAQ,CAACC,CAAD,CAAI,CACd,IAAKF,CAAAA,QAAL,CAAc,IAAKR,CAAAA,KAAnB,CAA2BU,CAA3B,CADc,CAjCC,CAyCnBC,OAAQA,QAAQ,CAACC,CAAD,CAAI,EAzCD,CAiDnBC,QAASA,QAAQ,CAACC,IAAD,CAAO,CAAA,IAChBC,OAAS,CADO,CAEhBH,CACJ,KAAKT,CAAAA,WAAL,CAAiBW,IAAjB,CACA,KAAKF,CAAL,CAAS,IAAKZ,CAAAA,KAAd,CAAsBc,IAAtB,CAA6B,CAA7B,CAAgCF,CAAhC,EAAqC,IAAKZ,CAAAA,KAA1C,CAAiDY,CAAA,EAAjD,CACIG,MAAA,EAAUA,MAAV,EAAoB,CAApB,EAAyB,IAAKJ,CAAAA,MAAL,CAAYC,CAAZ,CAE7B,KAAKZ,CAAAA,KAAL,EAAcc,IACd,OAAOC,OARa,CAjDL,CAgEnBC,WAAYA,QAAQ,CAACF,IAAD,CAAO,CACvB,MAAOb,MAAMgB,CAAAA,WAAN,CAAkB,QAAlB,CAA4B,IAAKC,CAAAA,QAAL,CAAcJ,IAAd,CAA5B,CADgB,CAhER,CAwEnBI,SAAUA,QAAQ,CAACJ,IAAD,CAAO,EAxEN,CAgFnBK,qBAAsBA,QAAQ,CAACC,GAAD,CAAM,EAhFjB,CAwFnBC,sBAAuBA,QAAQ,CAACD,GAAD,CAAM,EAxFlB;AA+FnBE,SAAUA,QAAQ,EAAG,CACjB,IAAIC,QAAU,IAAKV,CAAAA,OAAL,CAAa,CAAb,CACd,OAAO,KAAIW,IAAJ,CAASA,IAAKC,CAAAA,GAAL,EACdF,OADc,EACH,EADG,CACG,GADH,EACW,IADX,EAEdA,OAFc,EAEH,EAFG,CAEG,EAFH,EAEW,CAFX,CAGfA,OAHe,EAGJ,EAHI,CAGE,EAHF,CAIfA,OAJe,EAIJ,EAJI,CAIE,EAJF,CAKfA,OALe,EAKJ,CALI,CAKC,EALD,EAMfA,OANe,CAML,EANK,GAMI,CANJ,CAAT,CAFU,CA/FF,CA0GvB7B,OAAOC,CAAAA,OAAP,CAAiBC,UApH2F;",
"sources":["node_modules/jszip/lib/reader/DataReader.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$jszip$lib$reader$DataReader\"] = function(global,require,module,exports) {\n'use strict';\nvar utils = require('../utils');\n\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurrence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurrence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */\n    readAndCheckSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n\n};"],
"names":["shadow$provide","global","require","module","exports","DataReader","data","length","zero","index","utils","prototype","checkOffset","offset","checkIndex","newIndex","Error","setIndex","skip","n","byteAt","i","readInt","size","result","readString","transformTo","readData","lastIndexOfSignature","sig","readAndCheckSignature","readDate","dostime","Date","UTC"]
}
