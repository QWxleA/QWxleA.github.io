[{"categories":["tutorial"],"contents":"A small query that lists all the changes, made during the last 24 hours.\nWith some pointers from @lauren#0001 and @Miro#1174 and a bit of help from google, I found: logseq/query_react.cljs , which pointed to three additional helpers:\n :right-now-ms which is this moment in milliseconds from 1970 :start-of-today-ms which points to this morning 0:00 :end-of-today-ms which points to tonight 24:00  They can be used like this:\n#+BEGIN_QUERY {:title [:h2 \u0026#34;My 24h changes\u0026#34;] :query [:find (pull ?b [*]) :in $ ?end :where [?b :block/updated-at ?v] [(- ?end 86400000 ) ?period] [(\u0026gt;= ?v ?period)] [(\u0026lt; ?v ?end)] ] ; :inputs [:start-of-today-ms] ; :inputs [:right-now-ms] :inputs [:end-of-today-ms] } #+END_QUERY You have to choose one of the three inputs, 86400000 is 24 hours in milliseconds (60 x 60 x 24 x 1000), a week would be 604800000 milliseconds.\n :right-now-ms will give you a 24 hours period from this moment, not very useful, imho :start-of-today-ms which you can use for yesterday\u0026rsquo;s changes :end-of-today-ms, which would be more useful for today\u0026rsquo;s changes  ","date":"Sep 12","permalink":"https://QWxleA.github.io/notes/logseq-24-hr-pages-tutorial/","tags":["logseq"],"title":"logseq 24 hr pages tutorial"},{"categories":null,"contents":"Playing around with queries can be detrimental to the health of your graph as you may create blocks and pages just for testing purposes. Use a dedicated playground graph for this!  Second point, if you copy/paste queries, go over the code again, Logseq sometimes adds extra line-breaks / characters in strange places. Personally, I write my (longer) queries in vscode, and then, remove all tab-characters, and then copy the query to Logseq \nIn the following 9 examples we will walk through variou queries for Logseq. The tutorials are intended for beginners getting started with advanced queries in Logseq.\n   Example 1, find a tag  OK, let\u0026rsquo;s start. The simplest query is probably: {{query [[MyTag]]}}\nTo create this, shortcut /q, and then add [[MyTag]]. This will look for the tag #MyTag (everywhere).\nThe same query, but now written as an advanced query, would be:\n1 2 3 4 5 6 7 8 9  #+BEGIN_QUERY {:title \u0026#34;Find tag: MyTag\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/ref-pages ?p] [?p :block/name \u0026#34;MyTag\u0026#34;] ] } #+END_QUERY      Let\u0026#39;s go over this line by line    Lines 2 and 8, these indicate the start and end of a code block. Add an advanced query with \u0026lt;q, and select query (fun fact: this notation comes from Emacs org-mode) \n  Lines 2 and 7, a query starts and end with curly brackets\n  Line 2 `:title \u0026ldquo;\u0026rdquo; \u0026lt;- a simple title field\n  Line 3 This is where the actual query starts, note the square bracket [, opening here, and closing on line 7 So we want to find stuff, and the blocks we want to find we store in ?b. This ?b is just a variable, you could replace ?b with ?block if it would make your code more readable. Just use the same variable everywhere üòÑ \n  Line 4 :where starts the search parameters\n  Line 5 block/ref-pages is the reference where tags are stored\n  Line 6 block/name is not the name of the page, but off the reference from line 5. We store the name of the tags in ?p (again this could be anything, you can rename it to ?tagIamLookingFor)\n  Writing this shorter might be a bit simpler to understand:\n[?b :block/ref-pages [:block/name \u0026#34;MyTag\u0026#34;]] This is exactly the same thing, as lines 5 and 6\nThat\u0026rsquo;s all, from now on we\u0026rsquo;ll iterate on this, adding complexity\n   Example 2, find a tag that is also a TODO  1 2 3 4 5 6 7 8 9  #+BEGIN_QUERY {:title \u0026#34;Find: MyTag\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker \u0026#34;TODO\u0026#34;] [?p :block/name \u0026#34;MyTag\u0026#34;] [?b :block/ref-pages ?p]] } #+END_QUERY     New is line 5, :block-markeris where todo keywords are stored (for the curious: logseq/db_schema, line 57 or so)\n  Our search has to satisfy both line 5, a marker containing TODO, and 6 and 7, which belong together\n     Example 3, multiple markers / TODO states  1 2 3 4 5 6 7 8 9 10 11  #+BEGIN_QUERY {:title \u0026#34;Find: TODO or DOING MyTag\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker ?marker] [(contains? #{\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?p :block/name \u0026#34;MyTag\u0026#34;] [?b :block/ref-pages ?p]] } #+END_QUERY   Notice lines 5 and 6, that replace the single line 5 fom the previous example. We\u0026rsquo;re looking for a marker, called ?marker, and ?marker should contain either TODO or DOING\nThis same method you can use to look for multiple tags:\n1 2 3 4 5 6 7 8 9 10 11 12 13  #+BEGIN_QUERY {:title \u0026#34;Find: MyTag and fghij\u0026#34; :query [:find (pull ?b [*]) :where  [?b :block/marker ?marker] [(contains? #{\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?b :block/ref-pages ?p] [?p :block/name ?tag] [(contains? #{\u0026#34;MyTag\u0026#34; \u0026#34;fghij\u0026#34;} ?tag)]] } #+END_QUERY   Notice the closing ] on line 11, it\u0026rsquo;s easy to forget these, especially as you slowly add more complexity to your searches     Example 4, search for parts of tag  Some people have complicated tag configurations, like: Topic/boats, Topic/airplanes, Topic/automobiles, to look for all those Topics at the same time, we can use (we, though, stick with our alphabet examples):\n1 2 3 4 5 6 7 8  #+BEGIN_QUERY {:query [:find (pull ?b [*]) :where [?b :block/ref-pages ?p] [?p :block/name ?tag] [(clojure.string/starts-with? ?tag \u0026#34;ab\u0026#34;)]] } #+END_QUERY   The key is off course on line 6, where we use clojure.string/starts-with?, the variable we work with is ?tag, and we filter on Topic/\nFor further study, these are the clojure builtins we can use in our queries: datascript/query.cljc at fork ¬∑ logseq/datascript\nNotice also that this query does not have a title, it doesn\u0026rsquo;t have to\n   Example 5, searching for page properties  Properties are key-value pairs that allow you to annotate a block or page:\n1 2 3 4 5 6 7 8  #+BEGIN_QUERY {:title \u0026#34;My examples\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/properties ?p] [(get ?p :type) ?t] [(= \u0026#34;example\u0026#34; ?t)]]} #+END_QUERY   There can be multiple block/properties to one block, so we have to get the one we want, in this case type. This can be any word added as a property to a page\n   Example 6, project tasks  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #+BEGIN_QUERY {:title \u0026#34;My examples TODOs\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker ?marker] [(contains? #{\u0026#34;NOW\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?b :block/page ?p] [?p :block/properties ?a] [(get ?a :type) ?t] [(= \u0026#34;example\u0026#34; ?t)] ] :result-transform (fn [result] (sort-by (fn [h] (get h :block/priority \u0026#34;Z\u0026#34;)) result)) :collapsed? false} #+END_QUERY   This query combines the TODO states from example 3, and page properties from example 5\nNew are lines 13-15, this snippet will sort TODOs on priority\n   Example 7, search Journal pages for tagged TODOs  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #+BEGIN_QUERY {:title \u0026#34;Tagged journal pages\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker ?marker] [(contains? #{\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?b :block/page ?p] [?p :block/journal? true]  [?b :block/ref-pages ?r] [?r :block/name \u0026#34;MyTag\u0026#34;] ] :result-transform (fn [result] (sort-by (fn [h] (get h :block/priority \u0026#34;Z\u0026#34;)) result)) } #+END_QUERY   New are the lines 8 and 9, where we ask if the page is a journal\n   Example 8, exclude from a query  1 2 3 4 5 6 7 8 9  #+BEGIN_QUERY {:title \u0026#34;üìº Watch list - videos\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/refs [:block/name \u0026#34;video\u0026#34;]] (not [?b :block/marker ?marker] [(contains? #{\u0026#34;DONE\u0026#34;} ?marker)]) ] } #+END_QUERY     Line 5 searches for the #video tag (it\u0026rsquo;s two lines in one, see QQ)\n  Line 6 and 7 look for the DONE marker, but now excludes it, by wrapping it in (not \u0026lt;query\u0026gt;). It has to be all on one line!\n     Example 9, comparing dates  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #+BEGIN_QUERY {:title \u0026#34;‚ö†Ô∏è OVERDUE\u0026#34; :query [:find (pull ?block [*]) :in $ ?start ?today :where [?block :block/marker ?marker]  (or [?block :block/scheduled ?d] [?block :block/deadline ?d])  [(\u0026gt;= ?d ?start)] [(\u0026lt; ?d ?today)]  [(contains? #{\u0026#34;NOW\u0026#34; \u0026#34;LATER\u0026#34; \u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34; \u0026#34;WAITING\u0026#34;} ?marker)]] :inputs [:180d :today] :result-transform (fn [result] (sort-by (fn [d] (get d :block/deadline) ) result )) :collapsed? false} #+END_QUERY   This is a very useful one. Let\u0026rsquo;s see what it does:\n  Line 6 gets ?marker, it can (line 15) contain NOW, LATER, TODO, etc\n  Line 8 or, means either of these shuold be true, it should either be a deadline or scheduled\n  Or is related to not from example 8, there is still a cousin called and, but that one is not used often. And is usually implied, all rules should match by default.\n  Lines 12 and 13 are new, you have to read them in the following order:\n  Line 16 offers two values, :180d and :today\n  Next is line 4, where those values are assigned to ?start and ?today (again, variables, starting with ? can be called anything, it could have been ?john and ?ringo)\n  Finally they are used on lines 12 and 13 where we compare the values of block/scheduled (line 9) to ?start and block/deadline (line 10) to ?today\n  And as a bonus, lines 17 to 19, we sort on deadlines\n     Further queries   resonance lists howto  ","date":"Sep 12","permalink":"https://QWxleA.github.io/notes/logseq-advanced-queries-tutorial/","tags":["logseq"],"title":"logseq advanced queries tutorial"},{"categories":null,"contents":"A thoroughly weird window-manager for Linux, written in haskell. The configuration is (completely functional) haskell script.\n   Links    home | xmonad - the tiling window manager that rocks\n  xmonad - Wikipedia\n  ","date":"Sep 12","permalink":"https://QWxleA.github.io/notes/xmonad/","tags":["xmonad","wm"],"title":"xmonad"},{"categories":null,"contents":"From a question on the Logseq forum: Creating a Resonance Calendar from queries\nA resonance calendar is taken from a video created by Ali Abdaal How I use Notion as a Resonance Calendar - YouTube. It\u0026rsquo;s a list of interesting (resonating) resources, added to your notes. Resources can be one of:\n Movies Podcasts Articles  How to implement this in logseq?\n   Step 1 ‚Äî gather a list of items  1 2 3 4 5 6 7 8 9 10  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 1\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] ]} #+END_QUERY   This is a fairly straight forward query:\n line 6: take the page properties of ?page (set in line 3) and store them in ?props line 7: of all the different properties, take :type and store it in ?type line 8: check if ?type is one of: movie, article or book Done!  Important: book != [[book]]. Don\u0026rsquo;t use [[book]] in type.\n   Step 2 ‚Äî remove some stuff we don\u0026#39;t want to see  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 2\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] (not [(get ?props :rating) ?rating] [(= \u0026#34;[[1/10]]\u0026#34; ?rating)] ) ]} #+END_QUERY   New are the line 9 to 12\n  line 9: a not statement, everything that matches this query will be excluded from the result\n  line 10: again, a page property\n  line 11: but this time we search for :rating and we match it with 1/10\n  line 12: close the not statement\n  Result: same list, but without the ones rated 1/10\n     Step 2b ‚Äî Only the bad stuff  For fun you can invert the search, only show the ones rated 1/10:\n1 2 3 4 5 6 7 8 9 10 11 12  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 2b ‚Äî all bad!\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] [(get ?props :rating) ?rating] [(= \u0026#34;[[1/10]]\u0026#34; ?rating)] ]} #+END_QUERY   This query is simpler then the previous one, and is implied, by default all lines should be true. Logseq is a very positive program üòÑ.\n   Step 3 ‚Äî remove more bad ratings  It\u0026rsquo;s not just 1/10 that\u0026rsquo;s bad, so is 2/10, but adding that is not as simple as you would want:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 3\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] (not [?page :page/properties ?props] [(get ?props :rating) ?rating] [(contains? #{ #{\u0026#34;1/10\u0026#34;} #{\u0026#34;2/10\u0026#34;} } ?rating)] ) ]} #+END_QUERY   Notice line 12 the contains? statement is quite complicated. This is because 1/10 and 2/10 are really [[1/10]] and [[2/10]]. They\u0026rsquo;re not just text, they are searchable items. This is different from type in Resonance List 1, line 8.\n   Step 4 ‚Äî remove by tag  But what if you would like to have a tag that shows how terrible the book or movie was?\nSimple, add tags:: [[terrible]] (or just terrible, if you never want to list them, just change it accordingly in the listing below)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 4 - final version\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props]  [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)]  [?page :page/name ?name]  (not [(missing? $ ?page :page/name)]) (not [?page :block/tags [:block/name \u0026#34;terrible\u0026#34;]])  (not [?page :page/properties ?props] [(get ?props :rating) ?rating] [(contains? #{ #{\u0026#34;1/10\u0026#34;} #{\u0026#34;2/10\u0026#34;} } ?rating)] ) ]} #+END_QUERY   New are the lines 13 and 14, we exclude [[terrible]] from our list.\nIf you want to add more tags, then look at Resonance List 3 how to do that.\n   Conclusion  Logseq\u0026rsquo;s search functionality is not as easy as one would wish for, but it is adaquate, and can be made to search for the data you\u0026rsquo;re interested in.\n","date":"Sep 06","permalink":"https://QWxleA.github.io/notes/resonance-lists-howto/","tags":["logseq"],"title":"resonance lists howto"},{"categories":["linux"],"contents":"ElementaryOS is a gorgeous Linux distribution, and ever since they released Odin, I\u0026rsquo;ve been dying to try it. After installing it in a VM, and seeing the last bugs get ironed out, I finally caved, and installed it. It\u0026rsquo;s fabulous!\nIf you\u0026rsquo;ve been listening to rumors, there have been some complaints about the lack of software, and some of the defaults, but imho, with elementary OS 6 Updates for August, 2021 those complaints should be layed to rest. It\u0026rsquo;s very easy to add Flathub, and that, combined with the underlying Ubuntu packages, almost anything you can think of can be installed.\nBut, it\u0026rsquo;s not all rainbows and unicorns. It\u0026rsquo;s impossible (as fas as I know), to install ElementaryOS on Btrfs. And I wanted to use it at least for my /home. The following is how you can set that up (disclaimer, this can seriously mess up your install. If you don\u0026rsquo;t know what any of this means, don\u0026rsquo;t do it!):\n   What we\u0026#39;re aiming for  The end-product is this:\n1 2 3 4 5 6 7 8 9 10 11  $ sudo lsblk -f /dev/sda  NAME FSTYPE LABEL UUID FSAVAIL FSUSE% MOUNTPOINT sda ‚îú‚îÄsda1 vfat 336E-86E5 251.7M 4% /boot/efi ‚îú‚îÄsda2 ext4 0b3ad1d4-bbc5-42c5-a44b-4574a7c18fa4 316.5M 23% /boot ‚îî‚îÄsda3 crypto_LUKS 6264e4ed-d493-44b9-966b-a5eaf887a3ab ‚îî‚îÄcryptdata LVM2_member Uhf4VJ-VO1z-a5FI-ppNz-zzVB-2RFZ-C6Rpm0 ‚îú‚îÄdata-root ext4 13c02579-526b-4652-a792-b41286ac3a81 14.6G 44% / ‚îú‚îÄdata-swap swap b9c6201c-2f90-4b49-a3d9-91232264568c [SWAP] ‚îî‚îÄdata-home btrfs 15669fa8-d62d-4925-a826-6153e65aaa6a 236.8G 46% /home   Figure 1.\nIf, on a regular Elementary install, you would run the sudo lsblk -f /dev/sda command, you would see about the same thing, just with different UUIDs, and missing data-home.\n   Adding a Btrfs /home  If you look at Figure 1, line 8, you see Elementary uses LVM. LVM has several (preinstalled) tools that making changes to your drive layout simple:\nVgdisplay prints information about the complete Volume Group, among it\u0026rsquo;s output, the name data in my case.\nLvdisplay prints information about the logical volumes defined inside to VG, this one is usefull to see if resizing data-root and creating data-home worked.\nNow the tools we will use (do all this from the Elementary installer, or some other live-image, most, if not all these commands need sudo):\n Unlock the encryped volume: cryptsetup luksOpen /dev/sda3 encrypted_system Is it all there? lvdisplay Make sure you\u0026rsquo;re drive is clean: e2fsck - f /dev/data/root Optional: resize2fs /dev/data/root 30G The key command: lvreduce - L 30G - r /dev/data/root. Not using -r (or first doing 4) will make the system unbootable. Ext4 doesn\u0026rsquo;t like finding it\u0026rsquo;s space suddenly reduced! Next, we can create a new logical volume in the free space: lvcreate - l 100%FREE -n home data. -n indicates the name, data is the Volume Group create filesystem: mkfs.btrfs /dev/data/home Copy the UUID (if you forget, you can use lsblk, as in figure 1) Mount data-root: mount /dev/data/root /mnt Add your new drive to fstab: vi /mnt/etc/fstab  1 2 3 4 5 6  # \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; PARTUUID=842cba63-fc3f-49ba-b03e-a215549fc81e /boot/efi vfat umask=0077 0 0 UUID=0b3ad1d4-bbc5-42c5-a44b-4574a7c18fa4 /boot ext4 noatime,errors=remount-ro 0 0 UUID=13c02579-526b-4652-a792-b41286ac3a81 / ext4 noatime,errors=remount-ro 0 0 /dev/mapper/data-swap none swap defaults 0 0 UUID=15669fa8-d62d-4925-a826-6153e65aaa6a /home btrfs noatime,ssd,space_cache,commit=120,compress=zstd,discard=async,x-systemd-timeout=0 0 0   Figure 2. If you have used the system already, rename your old /home, so you can copy the data to the new drive \nThat\u0026rsquo;s it, now your /home can use snapshots, compression and all the other goodies from a modern FS.\n","date":"Sep 03","permalink":"https://QWxleA.github.io/notes/using-btrfs-for-home-on-elementaryos/","tags":["elementaryos","btrfs"],"title":"Using Btrfs for Home on ElementaryOS"},{"categories":null,"contents":"       Title here Date here  Summary here   ","date":"Jan 01","permalink":"https://QWxleA.github.io/search/","tags":null,"title":"Search"},{"categories":null,"contents":"See Home page\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n          ","date":"Jan 01","permalink":"https://QWxleA.github.io/about/","tags":null,"title":"‚Åâ About \u0026 ‚úâ"},{"categories":["tutorial"],"contents":"A small query that lists all the changes, made during the last 24 hours.\nWith some pointers from @lauren#0001 and @Miro#1174 and a bit of help from google, I found: logseq/query_react.cljs , which pointed to three additional helpers:\n :right-now-ms which is this moment in milliseconds from 1970 :start-of-today-ms which points to this morning 0:00 :end-of-today-ms which points to tonight 24:00  They can be used like this:\n#+BEGIN_QUERY {:title [:h2 \u0026#34;My 24h changes\u0026#34;] :query [:find (pull ?b [*]) :in $ ?end :where [?b :block/updated-at ?v] [(- ?end 86400000 ) ?period] [(\u0026gt;= ?v ?period)] [(\u0026lt; ?v ?end)] ] ; :inputs [:start-of-today-ms] ; :inputs [:right-now-ms] :inputs [:end-of-today-ms] } #+END_QUERY You have to choose one of the three inputs, 86400000 is 24 hours in milliseconds (60 x 60 x 24 x 1000), a week would be 604800000 milliseconds.\n :right-now-ms will give you a 24 hours period from this moment, not very useful, imho :start-of-today-ms which you can use for yesterday\u0026rsquo;s changes :end-of-today-ms, which would be more useful for today\u0026rsquo;s changes  ","date":"Sep 12","permalink":"https://QWxleA.github.io/notes/logseq-24-hr-pages-tutorial/","tags":["logseq"],"title":"logseq 24 hr pages tutorial"},{"categories":null,"contents":"Playing around with queries can be detrimental to the health of your graph as you may create blocks and pages just for testing purposes. Use a dedicated playground graph for this!  Second point, if you copy/paste queries, go over the code again, Logseq sometimes adds extra line-breaks / characters in strange places. Personally, I write my (longer) queries in vscode, and then, remove all tab-characters, and then copy the query to Logseq \nIn the following 9 examples we will walk through variou queries for Logseq. The tutorials are intended for beginners getting started with advanced queries in Logseq.\n   Example 1, find a tag  OK, let\u0026rsquo;s start. The simplest query is probably: {{query [[MyTag]]}}\nTo create this, shortcut /q, and then add [[MyTag]]. This will look for the tag #MyTag (everywhere).\nThe same query, but now written as an advanced query, would be:\n1 2 3 4 5 6 7 8 9  #+BEGIN_QUERY {:title \u0026#34;Find tag: MyTag\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/ref-pages ?p] [?p :block/name \u0026#34;MyTag\u0026#34;] ] } #+END_QUERY      Let\u0026#39;s go over this line by line    Lines 2 and 8, these indicate the start and end of a code block. Add an advanced query with \u0026lt;q, and select query (fun fact: this notation comes from Emacs org-mode) \n  Lines 2 and 7, a query starts and end with curly brackets\n  Line 2 `:title \u0026ldquo;\u0026rdquo; \u0026lt;- a simple title field\n  Line 3 This is where the actual query starts, note the square bracket [, opening here, and closing on line 7 So we want to find stuff, and the blocks we want to find we store in ?b. This ?b is just a variable, you could replace ?b with ?block if it would make your code more readable. Just use the same variable everywhere üòÑ \n  Line 4 :where starts the search parameters\n  Line 5 block/ref-pages is the reference where tags are stored\n  Line 6 block/name is not the name of the page, but off the reference from line 5. We store the name of the tags in ?p (again this could be anything, you can rename it to ?tagIamLookingFor)\n  Writing this shorter might be a bit simpler to understand:\n[?b :block/ref-pages [:block/name \u0026#34;MyTag\u0026#34;]] This is exactly the same thing, as lines 5 and 6\nThat\u0026rsquo;s all, from now on we\u0026rsquo;ll iterate on this, adding complexity\n   Example 2, find a tag that is also a TODO  1 2 3 4 5 6 7 8 9  #+BEGIN_QUERY {:title \u0026#34;Find: MyTag\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker \u0026#34;TODO\u0026#34;] [?p :block/name \u0026#34;MyTag\u0026#34;] [?b :block/ref-pages ?p]] } #+END_QUERY     New is line 5, :block-markeris where todo keywords are stored (for the curious: logseq/db_schema, line 57 or so)\n  Our search has to satisfy both line 5, a marker containing TODO, and 6 and 7, which belong together\n     Example 3, multiple markers / TODO states  1 2 3 4 5 6 7 8 9 10 11  #+BEGIN_QUERY {:title \u0026#34;Find: TODO or DOING MyTag\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker ?marker] [(contains? #{\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?p :block/name \u0026#34;MyTag\u0026#34;] [?b :block/ref-pages ?p]] } #+END_QUERY   Notice lines 5 and 6, that replace the single line 5 fom the previous example. We\u0026rsquo;re looking for a marker, called ?marker, and ?marker should contain either TODO or DOING\nThis same method you can use to look for multiple tags:\n1 2 3 4 5 6 7 8 9 10 11 12 13  #+BEGIN_QUERY {:title \u0026#34;Find: MyTag and fghij\u0026#34; :query [:find (pull ?b [*]) :where  [?b :block/marker ?marker] [(contains? #{\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?b :block/ref-pages ?p] [?p :block/name ?tag] [(contains? #{\u0026#34;MyTag\u0026#34; \u0026#34;fghij\u0026#34;} ?tag)]] } #+END_QUERY   Notice the closing ] on line 11, it\u0026rsquo;s easy to forget these, especially as you slowly add more complexity to your searches     Example 4, search for parts of tag  Some people have complicated tag configurations, like: Topic/boats, Topic/airplanes, Topic/automobiles, to look for all those Topics at the same time, we can use (we, though, stick with our alphabet examples):\n1 2 3 4 5 6 7 8  #+BEGIN_QUERY {:query [:find (pull ?b [*]) :where [?b :block/ref-pages ?p] [?p :block/name ?tag] [(clojure.string/starts-with? ?tag \u0026#34;ab\u0026#34;)]] } #+END_QUERY   The key is off course on line 6, where we use clojure.string/starts-with?, the variable we work with is ?tag, and we filter on Topic/\nFor further study, these are the clojure builtins we can use in our queries: datascript/query.cljc at fork ¬∑ logseq/datascript\nNotice also that this query does not have a title, it doesn\u0026rsquo;t have to\n   Example 5, searching for page properties  Properties are key-value pairs that allow you to annotate a block or page:\n1 2 3 4 5 6 7 8  #+BEGIN_QUERY {:title \u0026#34;My examples\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/properties ?p] [(get ?p :type) ?t] [(= \u0026#34;example\u0026#34; ?t)]]} #+END_QUERY   There can be multiple block/properties to one block, so we have to get the one we want, in this case type. This can be any word added as a property to a page\n   Example 6, project tasks  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #+BEGIN_QUERY {:title \u0026#34;My examples TODOs\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker ?marker] [(contains? #{\u0026#34;NOW\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?b :block/page ?p] [?p :block/properties ?a] [(get ?a :type) ?t] [(= \u0026#34;example\u0026#34; ?t)] ] :result-transform (fn [result] (sort-by (fn [h] (get h :block/priority \u0026#34;Z\u0026#34;)) result)) :collapsed? false} #+END_QUERY   This query combines the TODO states from example 3, and page properties from example 5\nNew are lines 13-15, this snippet will sort TODOs on priority\n   Example 7, search Journal pages for tagged TODOs  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #+BEGIN_QUERY {:title \u0026#34;Tagged journal pages\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/marker ?marker] [(contains? #{\u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  [?b :block/page ?p] [?p :block/journal? true]  [?b :block/ref-pages ?r] [?r :block/name \u0026#34;MyTag\u0026#34;] ] :result-transform (fn [result] (sort-by (fn [h] (get h :block/priority \u0026#34;Z\u0026#34;)) result)) } #+END_QUERY   New are the lines 8 and 9, where we ask if the page is a journal\n   Example 8, exclude from a query  1 2 3 4 5 6 7 8 9  #+BEGIN_QUERY {:title \u0026#34;üìº Watch list - videos\u0026#34; :query [:find (pull ?b [*]) :where [?b :block/refs [:block/name \u0026#34;video\u0026#34;]] (not [?b :block/marker ?marker] [(contains? #{\u0026#34;DONE\u0026#34;} ?marker)]) ] } #+END_QUERY     Line 5 searches for the #video tag (it\u0026rsquo;s two lines in one, see QQ)\n  Line 6 and 7 look for the DONE marker, but now excludes it, by wrapping it in (not \u0026lt;query\u0026gt;). It has to be all on one line!\n     Example 9, comparing dates  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #+BEGIN_QUERY {:title \u0026#34;‚ö†Ô∏è OVERDUE\u0026#34; :query [:find (pull ?block [*]) :in $ ?start ?today :where [?block :block/marker ?marker]  (or [?block :block/scheduled ?d] [?block :block/deadline ?d])  [(\u0026gt;= ?d ?start)] [(\u0026lt; ?d ?today)]  [(contains? #{\u0026#34;NOW\u0026#34; \u0026#34;LATER\u0026#34; \u0026#34;TODO\u0026#34; \u0026#34;DOING\u0026#34; \u0026#34;WAITING\u0026#34;} ?marker)]] :inputs [:180d :today] :result-transform (fn [result] (sort-by (fn [d] (get d :block/deadline) ) result )) :collapsed? false} #+END_QUERY   This is a very useful one. Let\u0026rsquo;s see what it does:\n  Line 6 gets ?marker, it can (line 15) contain NOW, LATER, TODO, etc\n  Line 8 or, means either of these shuold be true, it should either be a deadline or scheduled\n  Or is related to not from example 8, there is still a cousin called and, but that one is not used often. And is usually implied, all rules should match by default.\n  Lines 12 and 13 are new, you have to read them in the following order:\n  Line 16 offers two values, :180d and :today\n  Next is line 4, where those values are assigned to ?start and ?today (again, variables, starting with ? can be called anything, it could have been ?john and ?ringo)\n  Finally they are used on lines 12 and 13 where we compare the values of block/scheduled (line 9) to ?start and block/deadline (line 10) to ?today\n  And as a bonus, lines 17 to 19, we sort on deadlines\n     Further queries   resonance lists howto  ","date":"Sep 12","permalink":"https://QWxleA.github.io/notes/logseq-advanced-queries-tutorial/","tags":["logseq"],"title":"logseq advanced queries tutorial"},{"categories":null,"contents":"A thoroughly weird window-manager for Linux, written in haskell. The configuration is (completely functional) haskell script.\n   Links    home | xmonad - the tiling window manager that rocks\n  xmonad - Wikipedia\n  ","date":"Sep 12","permalink":"https://QWxleA.github.io/notes/xmonad/","tags":["xmonad","wm"],"title":"xmonad"},{"categories":null,"contents":"From a question on the Logseq forum: Creating a Resonance Calendar from queries\nA resonance calendar is taken from a video created by Ali Abdaal How I use Notion as a Resonance Calendar - YouTube. It\u0026rsquo;s a list of interesting (resonating) resources, added to your notes. Resources can be one of:\n Movies Podcasts Articles  How to implement this in logseq?\n   Step 1 ‚Äî gather a list of items  1 2 3 4 5 6 7 8 9 10  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 1\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] ]} #+END_QUERY   This is a fairly straight forward query:\n line 6: take the page properties of ?page (set in line 3) and store them in ?props line 7: of all the different properties, take :type and store it in ?type line 8: check if ?type is one of: movie, article or book Done!  Important: book != [[book]]. Don\u0026rsquo;t use [[book]] in type.\n   Step 2 ‚Äî remove some stuff we don\u0026#39;t want to see  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 2\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] (not [(get ?props :rating) ?rating] [(= \u0026#34;[[1/10]]\u0026#34; ?rating)] ) ]} #+END_QUERY   New are the line 9 to 12\n  line 9: a not statement, everything that matches this query will be excluded from the result\n  line 10: again, a page property\n  line 11: but this time we search for :rating and we match it with 1/10\n  line 12: close the not statement\n  Result: same list, but without the ones rated 1/10\n     Step 2b ‚Äî Only the bad stuff  For fun you can invert the search, only show the ones rated 1/10:\n1 2 3 4 5 6 7 8 9 10 11 12  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 2b ‚Äî all bad!\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] [(get ?props :rating) ?rating] [(= \u0026#34;[[1/10]]\u0026#34; ?rating)] ]} #+END_QUERY   This query is simpler then the previous one, and is implied, by default all lines should be true. Logseq is a very positive program üòÑ.\n   Step 3 ‚Äî remove more bad ratings  It\u0026rsquo;s not just 1/10 that\u0026rsquo;s bad, so is 2/10, but adding that is not as simple as you would want:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 3\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props] [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)] (not [?page :page/properties ?props] [(get ?props :rating) ?rating] [(contains? #{ #{\u0026#34;1/10\u0026#34;} #{\u0026#34;2/10\u0026#34;} } ?rating)] ) ]} #+END_QUERY   Notice line 12 the contains? statement is quite complicated. This is because 1/10 and 2/10 are really [[1/10]] and [[2/10]]. They\u0026rsquo;re not just text, they are searchable items. This is different from type in Resonance List 1, line 8.\n   Step 4 ‚Äî remove by tag  But what if you would like to have a tag that shows how terrible the book or movie was?\nSimple, add tags:: [[terrible]] (or just terrible, if you never want to list them, just change it accordingly in the listing below)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #+BEGIN_QUERY {:title [:h2 \u0026#34;Resonance list 4 - final version\u0026#34;] :query [ :find (pull ?page [*]) :where [?page :page/properties ?props]  [(get ?props :type) ?type] [(contains? #{\u0026#34;movie\u0026#34; \u0026#34;article\u0026#34; \u0026#34;book\u0026#34;} ?type)]  [?page :page/name ?name]  (not [(missing? $ ?page :page/name)]) (not [?page :block/tags [:block/name \u0026#34;terrible\u0026#34;]])  (not [?page :page/properties ?props] [(get ?props :rating) ?rating] [(contains? #{ #{\u0026#34;1/10\u0026#34;} #{\u0026#34;2/10\u0026#34;} } ?rating)] ) ]} #+END_QUERY   New are the lines 13 and 14, we exclude [[terrible]] from our list.\nIf you want to add more tags, then look at Resonance List 3 how to do that.\n   Conclusion  Logseq\u0026rsquo;s search functionality is not as easy as one would wish for, but it is adaquate, and can be made to search for the data you\u0026rsquo;re interested in.\n","date":"Sep 06","permalink":"https://QWxleA.github.io/notes/resonance-lists-howto/","tags":["logseq"],"title":"resonance lists howto"},{"categories":["linux"],"contents":"ElementaryOS is a gorgeous Linux distribution, and ever since they released Odin, I\u0026rsquo;ve been dying to try it. After installing it in a VM, and seeing the last bugs get ironed out, I finally caved, and installed it. It\u0026rsquo;s fabulous!\nIf you\u0026rsquo;ve been listening to rumors, there have been some complaints about the lack of software, and some of the defaults, but imho, with elementary OS 6 Updates for August, 2021 those complaints should be layed to rest. It\u0026rsquo;s very easy to add Flathub, and that, combined with the underlying Ubuntu packages, almost anything you can think of can be installed.\nBut, it\u0026rsquo;s not all rainbows and unicorns. It\u0026rsquo;s impossible (as fas as I know), to install ElementaryOS on Btrfs. And I wanted to use it at least for my /home. The following is how you can set that up (disclaimer, this can seriously mess up your install. If you don\u0026rsquo;t know what any of this means, don\u0026rsquo;t do it!):\n   What we\u0026#39;re aiming for  The end-product is this:\n1 2 3 4 5 6 7 8 9 10 11  $ sudo lsblk -f /dev/sda  NAME FSTYPE LABEL UUID FSAVAIL FSUSE% MOUNTPOINT sda ‚îú‚îÄsda1 vfat 336E-86E5 251.7M 4% /boot/efi ‚îú‚îÄsda2 ext4 0b3ad1d4-bbc5-42c5-a44b-4574a7c18fa4 316.5M 23% /boot ‚îî‚îÄsda3 crypto_LUKS 6264e4ed-d493-44b9-966b-a5eaf887a3ab ‚îî‚îÄcryptdata LVM2_member Uhf4VJ-VO1z-a5FI-ppNz-zzVB-2RFZ-C6Rpm0 ‚îú‚îÄdata-root ext4 13c02579-526b-4652-a792-b41286ac3a81 14.6G 44% / ‚îú‚îÄdata-swap swap b9c6201c-2f90-4b49-a3d9-91232264568c [SWAP] ‚îî‚îÄdata-home btrfs 15669fa8-d62d-4925-a826-6153e65aaa6a 236.8G 46% /home   Figure 1.\nIf, on a regular Elementary install, you would run the sudo lsblk -f /dev/sda command, you would see about the same thing, just with different UUIDs, and missing data-home.\n   Adding a Btrfs /home  If you look at Figure 1, line 8, you see Elementary uses LVM. LVM has several (preinstalled) tools that making changes to your drive layout simple:\nVgdisplay prints information about the complete Volume Group, among it\u0026rsquo;s output, the name data in my case.\nLvdisplay prints information about the logical volumes defined inside to VG, this one is usefull to see if resizing data-root and creating data-home worked.\nNow the tools we will use (do all this from the Elementary installer, or some other live-image, most, if not all these commands need sudo):\n Unlock the encryped volume: cryptsetup luksOpen /dev/sda3 encrypted_system Is it all there? lvdisplay Make sure you\u0026rsquo;re drive is clean: e2fsck - f /dev/data/root Optional: resize2fs /dev/data/root 30G The key command: lvreduce - L 30G - r /dev/data/root. Not using -r (or first doing 4) will make the system unbootable. Ext4 doesn\u0026rsquo;t like finding it\u0026rsquo;s space suddenly reduced! Next, we can create a new logical volume in the free space: lvcreate - l 100%FREE -n home data. -n indicates the name, data is the Volume Group create filesystem: mkfs.btrfs /dev/data/home Copy the UUID (if you forget, you can use lsblk, as in figure 1) Mount data-root: mount /dev/data/root /mnt Add your new drive to fstab: vi /mnt/etc/fstab  1 2 3 4 5 6  # \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; PARTUUID=842cba63-fc3f-49ba-b03e-a215549fc81e /boot/efi vfat umask=0077 0 0 UUID=0b3ad1d4-bbc5-42c5-a44b-4574a7c18fa4 /boot ext4 noatime,errors=remount-ro 0 0 UUID=13c02579-526b-4652-a792-b41286ac3a81 / ext4 noatime,errors=remount-ro 0 0 /dev/mapper/data-swap none swap defaults 0 0 UUID=15669fa8-d62d-4925-a826-6153e65aaa6a /home btrfs noatime,ssd,space_cache,commit=120,compress=zstd,discard=async,x-systemd-timeout=0 0 0   Figure 2. If you have used the system already, rename your old /home, so you can copy the data to the new drive \nThat\u0026rsquo;s it, now your /home can use snapshots, compression and all the other goodies from a modern FS.\n","date":"Sep 03","permalink":"https://QWxleA.github.io/notes/using-btrfs-for-home-on-elementaryos/","tags":["elementaryos","btrfs"],"title":"Using Btrfs for Home on ElementaryOS"},{"categories":null,"contents":"       Title here Date here  Summary here   ","date":"Jan 01","permalink":"https://QWxleA.github.io/search/","tags":null,"title":"Search"},{"categories":null,"contents":"See Home page\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n          ","date":"Jan 01","permalink":"https://QWxleA.github.io/about/","tags":null,"title":"‚Åâ About \u0026 ‚úâ"}]