[{"categories":"development","contents":"We, as people, are social animals. We live together, we work together, we relax together, but what about learning together? In these days of global pandemics and, be honest, living inside our digital tools we have slowly gone back to being not-very-social. Digital gardens are one way to overcome this modern ill: Learning and building/creating in such a way that it is easy for others to see and/or comment on what you do and learn.\nAt the same time, being too busy with the technical part will detract from doing any  learning , so it should be simple to go from your system where you keep your notes/keep track of what you learn, to a website. With the help of a plugin it is easy to export all your public pages. Combine this with a hugo theme that knows about back-links and other logseq specific tricks, you can now start building your own .\n   Preparing your pages    Logseq has a special setting for pages that are ready for export, in the header of your page should be set: public:: true (notice the double colon!). It can also be set from the dropdown menu.\n  Next, just export all the pages for hugo with the plugin.\n  hugo gets upset if pages are referenced that do not actually exist, so be careful that all the links referenced in a page are also exported.       Preparing Hugo   Hugo is a general purpose blogging software, not specifically for[digital gardens]( digital garden) or even logseq. So for it to be usefula as a garden we need to add some functionality. For starters, backlinks:  {{ $re := $.File.BaseFileName }} {{ $backlinks := slice }} {{ range where .Site.RegularPages \u0026#34;Type\u0026#34; \u0026#34;page\u0026#34; }}  {{ if and (findRE $re .RawContent) (not (eq $re .File.BaseFileName)) }}  {{ $backlinks = $backlinks | append . }}  {{ end }} {{ end }}  {{ if gt (len $backlinks) 0 }}  \u0026lt;aside\u0026gt;  \u0026lt;h3\u0026gt;Backlinks\u0026lt;/h3\u0026gt;  \u0026lt;div class=\u0026#34;backlinks\u0026#34;\u0026gt;  \u0026lt;ul\u0026gt;  {{ range $backlinks }}  \u0026lt;li class=\u0026#34;capitalize\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;  {{ end }}  \u0026lt;/ul\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/aside\u0026gt; {{ else }}  \u0026lt;aside\u0026gt;  \u0026lt;h4\u0026gt;No notes link to this note\u0026lt;/h4\u0026gt;  \u0026lt;/aside\u0026gt; {{ end }}  \u0026lt;aside class=\u0026#34;related\u0026#34;\u0026gt;  {{ $related := .Site.RegularPages.Related . | complement $backlinks | first 3 -}}  {{ with $related -}}  \u0026lt;h3\u0026gt;slightly related\u0026lt;/h3\u0026gt;  \u0026lt;ul\u0026gt;  {{ range . -}}  \u0026lt;li class=\u0026#34;capitalize\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;  {{ end -}}  \u0026lt;/ul\u0026gt;  {{ end -}} \u0026lt;/aside\u0026gt;  This snippet will go over all pages, and find out if any of them link to this one.  That\u0026rsquo;s as far as I\u0026rsquo;ve gotten so far. Not sure what else is needed. More to come\u0026hellip;\n","date":"Apr 17","permalink":"https://QWxleA.github.io/page/building-a-digital-garden-with-logseq-and-hugo/","tags":["hugo","logseq"],"title":"building a digital garden with Logseq and Hugo"},{"categories":"development","contents":"Note: This place is currently a placeholder, hugo gets upset if links are missing.\n   References   Go-to links for Datalog: Learn Datalog Today! Datomic Queries and Rules | Datomic  ","date":"Apr 17","permalink":"https://QWxleA.github.io/page/datalog/","tags":["logseq"],"title":"datalog"},{"categories":"pkm","contents":"Note: This place is currently a placeholder, hugo gets upset if links are missing.\n   References    Building a digital garden\n  A Brief History \u0026amp; Ethos of the Digital Garden\n  Also: MaggieAppleton/digital-gardeners: Resources, links, projects, and ideas for gardeners tending their digital notes on the public interwebs\n  And: (2) Maggie Appleton ðŸ§­ on Twitter: \u0026ldquo;Nerding hard on digital gardens, personal wikis, and experimental knowledge systems with @_jonesian today. We have an epic collection going, check these out\u0026hellip; 1. @tomcritchlow\u0026rsquo;s Wikifolders: https://t.co/QnXw0vzbMG https://t.co/9ri6g9hD93\u0026rdquo; / Twitter\n  ","date":"Apr 17","permalink":"https://QWxleA.github.io/page/digital-garden/","tags":["hugo"],"title":"digital garden"},{"categories":"development","contents":"The plan is to collect useful snippets and code-examples to help creating and maintaining a pkm in Hugo (and posibly Logseq).\n   Automating import  To import pages from logseq:\n#!/usr/bin/env bash  BLOG=$HOME/Documents/QWxleA.github.io NOTES=$BLOG/content/notes ASSETS=\u0026#34;$BLOG/content/notes/assets\u0026#34; HUGOASSETS=$BLOG/static/assets  STARTPAGE=\u0026#34;$NOTES/Start here.md\u0026#34;  ZIP=$HOME/Downloads/publicExport.zip  explode() {  # rm $NOTES/*.md   unzip -o -d $NOTES $ZIP  if [ -d \u0026#34;$ASSETS\u0026#34; ]; then  for a in $ASSETS/*; do  mv \u0026#34;$a\u0026#34; $HUGOASSETS  done  rmdir \u0026#34;$ASSETS\u0026#34;  fi  # FIXME  if [ -f \u0026#34;$STARTPAGE\u0026#34; ]; then  mv \u0026#34;$STARTPAGE\u0026#34; \u0026#34;$BLOG/content/_index.md\u0026#34;  #FIXME relative path?  gsed -i \u0026#34;s@relref \\\u0026#34;@relref \\\u0026#34;\\/notes\\/@g\u0026#34; \u0026#34;$BLOG/content/_index.md\u0026#34;  fi }  usage() { echo \u0026#34;Usage: $0[-s \u0026lt;45|90\u0026gt;] [-p \u0026lt;string\u0026gt;]\u0026#34; 1\u0026gt;\u0026amp;2; exit 1; }  while getopts \u0026#34;lx\u0026#34; o; do  case \u0026#34;${o}\u0026#34; in  l)  unzip -v $ZIP  exit  ;;  x)  explode  exit  ;;  *)  usage  ;;  esac done shift $((OPTIND-1))  usage    Makefile to simplify working with Hugo  Makefiles are simple, just type make\nSHELL := /bin/bash .POSIX: .PHONY: push update watch all: help  help: ## Show this help \t@egrep -h \u0026#39;\\s##\\s\u0026#39; $(MAKEFILE_LIST) | sort | awk \u0026#39;BEGIN {FS = \u0026#34;:.*?## \u0026#34;}; {printf \u0026#34;\\033[36m%-20s\\033[0m %s\\n\u0026#34;, $$1, $$2}\u0026#39;  push: ## Push pages to github / upstream \tgit push origin master  update: ## Add new items / prepare to push upstream \thugo \tgit add .  watch: ## Run the local development server \thugo --buildDrafts --watch server --disableFastRender --ignoreCache  import: ## Import latest Logseq pages \t./scripts/export-blog -x ","date":"Apr 17","permalink":"https://QWxleA.github.io/page/hugo/","tags":["webdev"],"title":"hugo"},{"categories":"development","contents":"Logseq plugins are developed in Javascript and that is the reason I have been reading more on how to use it well. Here you will find mostly notes related to plugin development.\n","date":"Apr 17","permalink":"https://QWxleA.github.io/page/javascript/","tags":["webdev","logseq"],"title":"javascript"},{"categories":"pkm","contents":"Note: This place is currently a placeholder, hugo gets upset if links are missing. In the future this page will be a collection of useful links to learn how to more effectively use Logseq.\nRelated: javascript for plugins, datalog for queries.\n  \n","date":"Apr 17","permalink":"https://QWxleA.github.io/page/logseq/","tags":["workflow","logseq"],"title":"logseq"},{"categories":"pkm","contents":" Personal knowledge management (PKM) is a process of collecting information that a person uses to gather, classify, store, search, retrieve and share knowledge in their  daily activities  (Grundspenkis 2007) and the way in which these processes support work activities (Wright 2005). It is a response to the idea that knowledge workers need to be responsible for their own  growth and learning  (Smedley 2009). It is a  bottom-up approach  to knowledge management (KM) (Pollard 2008).\n Note: This place is currently a placeholder, hugo gets upset if links are missing.\n","date":"Apr 17","permalink":"https://QWxleA.github.io/page/pkm/","tags":["workflow"],"title":"pkm"},{"categories":"development","contents":"Note: This place is currently a placeholder, hugo gets upset if links are missing.\nQueries are build in a language called datalog, the presentation is done using Hiccup. Mixed in is Clojure, of which I know none.\n   Debugging    Usually I add one of these to view raw data from a query before I add custom hiccup view\n  :view (fn [result] (for [r result] [:pre (pr-str r)]))\n  :view (fn [result] (pr-str result))\n     Properties   #+BEGIN_QUERY {  :query [:find (pull ?b [{:block/page  [:block/name :block/journal-day]} :block/properties])  :where  [?b :block/properties ?bprops]  [(get ?bprops :distanse \u0026#34;nil\u0026#34;) ?bs]  [(not= ?bs \u0026#34;nil\u0026#34;)]] :result-transform (fn [result]  (sort-by (fn [s]  (get-in s [:block/page :block/journal-day])) (fn [a b] (compare b a)) result)) :view (fn [rows] [:table  [:thead  [:tr  [:th \u0026#34;Dato\u0026#34;]  [:th \u0026#34;Distanse\u0026#34;]  [:th \u0026#34;Ã˜kt\u0026#34;] ] ]  [:tbody (for [r rows] [:tr  [:td (get-in r [:block/page :block/name])]  [:td (get-in r [:block/properties :distanse])]  [:td (get-in r [:block/properties :Ã¸kt])] ])  ]] ) } #+END_QUERY    Image links   #+BEGIN_QUERY {:title [:h4 \u0026#34;Image gallery\u0026#34;] :query  [:find (pull ?b [*])  :in $ ?pattern ?current-page  :where  [?b :block/content ?c]  [?p :block/name ?current-page]  [?b :block/page ?p]  [(re-pattern ?pattern) ?q]  [(re-find ?q ?c)]]  :inputs [\u0026#34;^!.*https://www.dropbox.com/s/\u0026#34; :current-page] :result-transform (fn [result]  (sort-by (fn [h]  (get h :db/id)) result)) :view (fn [result]  (when (seq result)  [:div {:class \u0026#34;flex flex-row flex-wrap py-2\u0026#34;}  (for [{:block/keys [uuid content]} result]  [:span {:width \u0026#34;4rem\u0026#34; :key uuid :class \u0026#34;flex flex-col items-center mr-2 mb-2\u0026#34;}  [:a {:href (str \u0026#34;#/page/\u0026#34; uuid)} [:img {:style {:width \u0026#34;4rem\u0026#34;} :src (re-find (re-pattern \u0026#34;https://.*?(?=(?:\\\\))|$)\u0026#34;) (str content))}]]  ]  )])) } #+END_QUERY    Find all unlinked pages   link:: Discord date:: 2021-04-16   #+BEGIN_QUERY \t{:title \u0026#34;Orphan pages\u0026#34; \t:query [:find ?name \t:where \t[?p :page/name ?name] \t(not \t[?b :block/ref-pages ?p1] \t[?b :block/page ?p2] \t(or [?p1 :page/name ?name] \t[?p2 :page/name ?name]))] \t:view (fn [result] \t[:div.flex.flex-col \t(for [page result] \t[:a {:href (str \u0026#34;#/page/\u0026#34; page)} (clojure.string/capitalize page)])]) \t:collapsed? true} \t#+END_QUERY    Query to show a random page   link:: Discord date:: 2021-07-21  \t#+BEGIN_QUERY \t{:title \u0026#34;Give me a random page!!!\u0026#34; \t:query [:find ?name \t:where \t[?b :block/name ?name]] \t:result-transform (fn [result] \t[(rand-nth result)]) \t:view (fn [result] \t[:div.flex.flex-col \t(for [page result] \t[:a {:href (str \u0026#34;/#/page/\u0026#34; page)} (clojure.string/capitalize page)])]) \t:collapsed? true} \t#+END_QUERY    Query to create a table with page and todo count   link:: Discord date:: 2021-12-17   #+BEGIN_QUERY \t{:title \u0026#34;TODO by page\u0026#34; \t:query [:find (pull ?b [:block/marker :block/parent {:block/page \t[:db/id :block/name]}]) \t:where \t[?b :block/marker ?marker] \t[(= \u0026#34;TODO\u0026#34; ?marker)] \t] \t:result-transform (fn [result] \t(map (fn key value {:page (get key :block/name) :count (count value)}) (group-by :block/page result)) \t) \t:view (fn [rows] [:table \t[:thead \t[:tr \t[:th \u0026#34;Page\u0026#34;] \t[:th \u0026#34;Count\u0026#34;] ] ] \t[:tbody \t(for [r rows] [:tr \t[:td [:a {:href (str \u0026#34;#/page/\u0026#34; (get r :page))} (get r :page)] ] \t[:td (get r :count)] ]) \t]] \t) \t} \t#+END_QUERY    Grouping   #+BEGIN_QUERY {:title \u0026#34;TODO by page\u0026#34;  :query [:find (pull ?b [:block/scheduled :block/marker :block/parent {:block/page  [:db/id :block/name]}])  :where  [?b :block/scheduled _]  [?b :block/marker ?marker]  [(= \u0026#34;TODO\u0026#34; ?marker)]  ] :result-transform (fn [result]  (map (fn key value {:page key :count (count value)}) (group-by :block/scheduled result))  ) :view (fn [rows] [:table  [:thead  [:tr  [:th \u0026#34;Page\u0026#34;]  [:th \u0026#34;Count\u0026#34;] ] ]  [:tbody (for [r rows] [:tr  [:td (get r :page)]  [:td (get r :count)] ])  ]] ) } #+END_QUERY    View  #+BEGIN_QUERY {:title [:h2 \u0026#34;Programming languages list\u0026#34;]  :query [:find (pull ?b [*])  :where  [?b :block/properties ?p]  [(get ?p \u0026#34;type\u0026#34;) ?t]  [(= \u0026#34;programming_lang\u0026#34; ?t)]]  :view (fn [result]  (when (seq result)  (let [blocks (flatten result)]  [:div.table-wrapper  [:table.table-auto  [:thead  [:tr  [:th {:width \u0026#34;20%\u0026#34;} \u0026#34;Name\u0026#34;]  [:th {:width \u0026#34;20%\u0026#34;} \u0026#34;Creator\u0026#34;]  [:th {:width \u0026#34;60%\u0026#34;} \u0026#34;Description\u0026#34;]]]  [:tbody  (for [{:block/keys [title properties]} blocks]  [:tr  [:td (second (:url (second (first title))))]  [:td (get properties \u0026#34;creator\u0026#34;)]  [:td (get properties \u0026#34;description\u0026#34;)]])]]])))  } #+END_QUERY    Group by   #+BEGIN_QUERY {:title \u0026#34;Group by\u0026#34;  :query [:find (pull ?h [*])  :in $  :where  [?h :block/marker ?marker]  [(contains? #{\u0026#34;NOW\u0026#34; \u0026#34;DOING\u0026#34;} ?marker)]  ] :result-transform (fn [result]  (group-by :block/scheduled result)) :view (fn [result] (for [r result] [:div  [:div.text-xl (str \u0026#34;Scheduled: \u0026#34; (key r))]  (for [b (val r)]  [:div.ml-4 (get b :block/content)]  )  ] ))  } #+END_QUERY ","date":"Apr 17","permalink":"https://QWxleA.github.io/page/query-views/","tags":["datalog","clojure","hiccup"],"title":"query views"},{"categories":"macos","contents":"My mom complained about an English only TV series on Disney+. What\u0026rsquo;s a helpful son to do?\nAs it happens, streaming to a Chromecast is not hard, but sending subtitles to it seems to be all but impossible. So, hardcoded subs it is (Just like the nineties, how retro!).\n   Step by step    This was the easiest way to get some subtitled videos on TV:\n  Take an English only video file, from somewhere on the internet (exercise left to the reader.)\n  Find subtitles, cannot find anything in Dutch, find in English, easy to do.\n  Translate with Google translate (surprisingly good, Ulysses this tv-series is not, but still, happily surprised).\n  The timings are often wrong. SubShifter - Online SRT Subtitle Resync Tool is a good tool. I just use VLC to find when people start to talk and sync with this. The couple of times I\u0026rsquo;ve done this it was just to find a correct start.\n  Next the key to the whole conundrum: HandBrake: Open Source Video Transcoder. This app has been around for years, but is still actively developed and relatively easy to use.\n  A good alternative is Subler, it is way faster, but cannot hardcode subs, so for this Handbrake is the obvious choice.\n     Handbrake   To setup Handbrake for encoding on an M1, you need to use the correct settings (the app is universal): Configuration: Video \u0026gt; H.265 (VideoToolbox) \u0026amp; Chromecast 1080p        \n+ These settings cut the encoding time in half (still _not_ instantaneous). Next, add everything to the queue and get something to eat.     Playback â€” attempt 1    The easiest way to send a video file to a Chromecast is using the Chrome Browser:\n  Serve files: python3 -m http.server 8080+\n  Open in Google Chrome+\n  â«¶ \u0026gt; Cast \u0026gt; TV (Chromecast), done+\n Worked well, but no way I get my mom to run a local webserver.       Playback â€” attempt 2   VLC is a decent player, and it\u0026rsquo;s old, so people are bound to have used it: Use VLC to stream, open file Then Playback \u0026gt; Renderer \u0026gt; TV (Chromecast)  ","date":"Apr 08","permalink":"https://QWxleA.github.io/page/streaming-to-a-chromecast/","tags":["video"],"title":"Streaming to a chromecast"},{"categories":null,"contents":"A domain-specific language (DSL) is a computer language specialized to a particular application domain â€” Wikipedia\n","date":"Mar 23","permalink":"https://QWxleA.github.io/page/domain-specific-language/","tags":null,"title":"domain-specific language"},{"categories":null,"contents":"Hiccup is a domain-specific language for generating HTML, used mostly in Clojure community.\nFor every day use you need very little knowledge of Hiccup, and fortunately (most of it) is surprisingly simple.\n   Let\u0026amp;rsquo;s Hiccup   The most obvious thing you can use Hiccup for is to style the titles of Advanced Queries:  #+BEGIN_QUERY {:title [:h3 \u0026#34;This is hiccup!\u0026#34;]  :query [:find (pull ?b [*])  :where  [task ?b #{\u0026#34;LATER\u0026#34;}]  ] } #+END_QUERY + Line 2 is written in Hiccup: `[:h3 \u0026quot;This is hiccup!\u0026quot;]`, this will be converted to: `\u0026lt;h3\u0026gt;This is hiccup!\u0026lt;/h3\u0026gt;`    h3, as used in Hiccup, is the same has an H3 in HTML, and you can also use other HTML tags, for example: \u0026lt;p\u0026gt; or \u0026lt;b\u0026gt;, which in Hiccup would be: [:p \u0026quot;this is an HTML p tag\u0026quot;] or [:b \u0026quot;This is an HTML b (bold) tag\u0026quot;].\n  For simple titles, that\u0026rsquo;s (almost) all you need. If you would like to add some css divs or classes to the mix, read on:\n     Basic Hiccup Syntax   What is actually happening when you write your title? Hiccup turns Clojure data structures like this:  [:h3 \u0026#34;This is hiccup!\u0026#34;]  Into strings of HTML like this:  \u0026lt;h3\u0026gt;This is hiccup!\u0026lt;/h3\u0026gt;  Technically speaking, the Clojure data structure is a vector ([ .... ], just like Advanced Queries uses for searches, that takes one of the following two forms:  [tag \u0026amp; body] [tag attributes \u0026amp; body]   The first item in the vector is the tag name. It is mandatory, and should be a keyword (:h3), a string (\u0026quot;This is hiccup!\u0026quot;) or a symbol (?b from queries).\n  The second item may optionally be a map of attributes.\n  All subsequent items in the vector are treated as the element body. This can include strings or nested tag vectors, for example:\n  [:p \u0026#34;Hello \u0026#34; [:em \u0026#34;World!\u0026#34;]]  This definition might sound a bit obvious, or unimportant, but later you\u0026rsquo;ll see how you can use the same syntax to create more complicated HTML structures, like lists (\u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;...) or tables (\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;...).     Making it look nice with CSS   There are two ways to add ids and classes to your html elements. The first is the most straight forward, and easy to read, but a bit long:  [:h3 {:id \u0026#34;mysearch\u0026#34; :class \u0026#34;underlined superpink\u0026#34;} \u0026#34;This is better looking Hiccup!\u0026#34;]  Hiccup also provides a convenient shorter way of writing:  [:h3#mysearch.underlined.superpink \u0026#34;This is better looking Hiccup!\u0026#34;]   As in CSS, the word after the \u0026ldquo;#\u0026rdquo; denotes the element\u0026rsquo;s ID, and the word after each \u0026ldquo;.\u0026rdquo; denotes the element\u0026rsquo;s classes.\n  There may be multiple classes, but there can only be one ID. Additionally, the ID must always come first, so div#foo.bar would work, but div.foo#bar would not.\n  You can add an ID on its own, or a class on its own:\n  [:div#post \u0026#34;...\u0026#34;] [:div.comment \u0026#34;...\u0026#34;]  The most amazing thing is, you can actually do this straight inside Logseq:  [:h2 {:style {:color \u0026#34;red\u0026#34;}} \u0026#34;h2 title\u0026#34;] [:p \u0026#34;Hello \u0026#34; [:em \u0026#34;World!\u0026#34;]] + [:h2 {:style {:color \u0026quot;red\u0026quot;}} \u0026quot;h2 title\u0026quot;]  [:p \u0026ldquo;Hello \u0026quot; [:em \u0026ldquo;World!\u0026rdquo;]]\n   Using Hiccup for :views   Advanced Queries support custom-build views for search results. These views are a combination of (a small sub-set of) Clojure and Hiccup. It\u0026rsquo;s not the easiest combination, but without a doubt you can build amazing things with it.  #+BEGIN_QUERY {:title [:b \u0026#34;All pages with a \u0026#34; [:em \u0026#34;programming\u0026#34;] \u0026#34; tag\u0026#34;]  :query [:find ?name  :in $ ?tag  :where  [?t :block/name ?tag]  [?p :block/tags ?t]  [?p :block/name ?name]]  :inputs [\u0026#34;programming\u0026#34;]  :view (fn [result] \t[:div.flex.flex-col \t(for [page result] \t[:a {:href (str \u0026#34;#/page/\u0026#34; page)} (clojure.string/capitalize page)]  )  ]  )} #+END_QUERY   Let\u0026rsquo;s examine one of the Advanced Queries, we are only interested in lines 11 to 15. It is an excellent example how search results, clojure and hiccup can represent search results:\n  These lines will create the following:\n  \u0026lt;div class=\u0026#34;flex flex-col\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#/page/advanced queries\u0026#34;\u0026gt;Advanced queries\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#/page/hiccup\u0026#34;\u0026gt;Hiccup\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;   Line 11 (query): creates the div with the two classes flex and flex-col, that div closes in line 15 (4 in the html)\n  Line12: is interesting clojure, it loops over result, and every single value is stored in page\n  Line 13: is the most complex Hiccup line so far:\n [:a {:href (str \u0026quot;#/page/\u0026quot; page)} (clojure.string/capitalize page)]    which translates to:\n \u0026lt;a href=\u0026quot;#/page/hiccup\u0026quot;\u0026gt;Hiccup\u0026lt;/a\u0026gt;    And if you look carefully, they look very much alike:\n  The whole thing is wrapped in an \u0026lt;a\u0026gt; -\u0026gt; [:a .... ]\n  Then you have the address href=\u0026quot;#/page/hiccup\u0026quot; -\u0026gt; (str \u0026quot;#/page/\u0026quot; page), which is Clojure for: str returns a string, in our case it concatenates (glues together) \u0026quot;#/page/\u0026quot; and the value of page.\n  Last you have the visible part of the link Hiccup -\u0026gt; (clojure.string/capitalize page), which is not hard to guess, it capitalizes the value of page.\n  Note: if you ever use this code, and page is a journal-page (which is a bunch of numbers), the whole thing will fail, so don\u0026rsquo;t capitalize numbers, they don\u0026rsquo;t like that.\n    And this is what it looks like:\n query-table:: false #+BEGIN_QUERY {:title [:b \u0026ldquo;All pages with a \u0026quot; [:em \u0026ldquo;programming\u0026rdquo;] \u0026quot; tag\u0026rdquo;] :query [:find ?name :in $ ?tag :where [?t :block/name ?tag] [?p :block/tags ?t] [?p :block/name ?name]] :inputs [\u0026ldquo;programming\u0026rdquo;] :view (fn [result] [:div.flex.flex-col (for [page result] [:a {:href (str \u0026ldquo;#/page/\u0026rdquo; page)} (clojure.string/capitalize page)] ) ] )} #+END_QUERY       Table views, hiccup is just like good-looking html   query-table:: false  #+BEGIN_QUERY {:title [:h3 \u0026#34;Programming languages used in Logseq\u0026#34;]  :query [:find (pull ?p [*])  :where  [page-tags ?p #{\u0026#34;programming\u0026#34;}]  ] :view (fn [rows] [:table  [:thead  [:tr  [:th \u0026#34;Page\u0026#34;]  [:th \u0026#34;Language\u0026#34;]  [:th \u0026#34;Difficulty\u0026#34;] ] ]  [:tbody (for [r rows] [:tr  [:td [:a {:href (str \u0026#34;#/page/\u0026#34; (get r :block/name))} (clojure.string/capitalize (get r :block/name))]]  [:td (get-in r [:block/properties :language])]  [:td (get-in r [:block/properties :difficulty])] ])  ]] ) :query-table false } #+END_QUERY + The result: + #+BEGIN_QUERY  {:title [:h3 \u0026ldquo;Programming languages used in Logseq\u0026rdquo;] :query [:find (pull ?p [*]) :where [page-tags ?p #{\u0026ldquo;programming\u0026rdquo;}] ] :view (fn [rows] [:table [:thead [:tr [:th \u0026ldquo;Page\u0026rdquo;] [:th \u0026ldquo;Language\u0026rdquo;] [:th \u0026ldquo;Difficulty\u0026rdquo;] ] ] [:tbody (for [r rows] [:tr [:td [:a {:href (str \u0026ldquo;#/page/\u0026rdquo; (get r :block/name))} (clojure.string/capitalize (get r :block/name))]] [:td (get-in r [:block/properties :language])] [:td (get-in r [:block/properties :difficulty])] ]) ]] ) :query-table false } #+END_QUERY\n   Additional resources    Hiccup Tips\n  Tutorial on Medium\n  rkn.io - Clojure Cookbook: Templating with Hiccup\n  ","date":"Mar 23","permalink":"https://QWxleA.github.io/page/hiccup/","tags":["hiccup"],"title":"Hiccup"},{"categories":"hugo","contents":"   Hugo testpage    This is a testpage, this is the kind of page you would store in Logseq, to be exported to Hugo\n  This is just a second paragraph.\n     This should be another headline    With some text\n  And some more\n     Headline 3    Lorem lipsum\n  Lipsum lorum\n       Headline 4    Lorem lipsum\n  Lipsum lorum\n         Markdown thingies    This is bold text is bold\n  Cursif text is obviously not bold\n  No idea what to  do with highlighted text \n     Links    Links and Cross References | Hugo\n  External links Front Matter | Hugo should just carry over\n  But internal links to [[logseq] should be translated as [logseq](https://QWxleA.github.io/page/logseq/)\n       Code blocks    Code blocks are the most complicated part:\n [this is a simple code block]        [?b :block/name ?name]    More testing  Let\u0026rsquo;s look at an image:\n  But not on the main level\n But in a sub-block      \nThis is a quote  This is a note  This is a tip  This is important  Caution here  This is pinned  This is a warning  This is an example  ","date":"Mar 17","permalink":"https://QWxleA.github.io/page/hugo-testpage/","tags":["testing"],"title":"Hugo - testpage"},{"categories":null,"contents":"Placeholder for an Advanced queries tutorial\n","date":"Feb 06","permalink":"https://QWxleA.github.io/page/advanced-queries/","tags":null,"title":"Advanced Queries"}]