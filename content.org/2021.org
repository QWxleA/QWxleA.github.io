#+hugo_base_dir: /home/plovs/Projects/QWxleA.github.io
#+category: blog

* Ideas
** TODO Tags -- organizing your files multi-dimensional           :productivity:
   :PROPERTIES:
   :EXPORT_FILE_NAME: tags-organizing-your-files-multi-dimensional
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: t
   :END:

   - [[https://www.tagspaces.org/products/community/][TagSpaces Community Edition]]
** TODO Linux productivity                                        :productivity:
   :PROPERTIES:
   :EXPORT_FILE_NAME: linux-productivity
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: t
   :END:

   https://blog.hubstaff.com/11-linux-productivity-tools/
https://www.linux.com/tutorials/top-5-linux-distributions-productivity/
https://r/

https://www.ubuntupit.com/best-linux-software-our-editorial-list-of-essential-linux-apps/

I always just use mpv "mpv av://v4l2:/dev/video0 "
** TODO Movies & TV                                                     :movies:
   :PROPERTIES:
   :EXPORT_FILE_NAME: movies-and-tv
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: t
   :END:

   Movies and TV Series

   - 5th element
   - face/off
   - young frankenstein

   - https://letterboxd.com/nikitavoloboev/
   - https://trakt.tv/users/nikitavoloboev/history
   - https://trakt.tv/users/nikitavoloboev/watchlist?sort=rank,asc
** TODO Android Apps -- 2021                                           :android:
   :PROPERTIES:
   :EXPORT_FILE_NAME: android-apps-2021
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: t
   :END:

   | Category                      | Applications                                |
   |-------------------------------+---------------------------------------------|
   | Ad Blocker                    | Blokada                                     |
   | App Store                     | F-Droid                                     |
   | Audio conferencing            | Plumble                                     |
   | Contacts and AddressBook sync | DAVDroid                                    |
   | Exercise                      | Feeel                                       |
   | File Synchronization          | Syncthing                                   |
   | Habit forming                 | Habits                                      |
   | Keyboard                      | AnySoftKeyboard with Colemak  layout        |
   | Messaging                     | Riot                                        |
   | Maps                          | OsmAnd~                                     |
   | Online Radio                  | RadioDroid                                  |
   | Password Manager              | KeePassDroid                                |
   | Podcasts                      | AntennaPod                                  |
   | Proprietary app store         | Yalp Store                                  |
   | Reminders                     | Tasks                                       |
   | RSS                           | Tiny Tiny RSS                               |
   | Social Media                  | Tusky and Dandelion                         |
   | Web Browsers                  | Firefox Klar and DuckDuckGo Privacy Browser |
   | YouTube Music and SoundCloud  | NewPipe Beta                                |


*** links

  - https://njoseph.me/mediawiki/Privacy_Stack

*** TODO on tech

    Install *mosh* on phone / tablet and tp220

    - [Mosh : Keith Winstein](https://launchpad.net/~keithw/+archive/ubuntu/mosh)
    - [Mosh Tool - An Alternative Option for SSH and How to Use It](http://linoxide.com/how-tos/mosh-alternative-ssh/)
** TODO Emacs -- tools for fun and glory                                 :emacs:
   :PROPERTIES:
   :EXPORT_FILE_NAME: emacs-tools-for-fun-and-glory
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: t
   :END:

   - [[http://www.draketo.de/light/english/emacs/babcore][Emacs Customizations everyone should have]]
   - [[https://www.reddit.com/r/emacs/comments/898xgg/what_minor_modes_do_you_always_use][What minor modes do you always use?]]
   - [[https://www.reddit.com/r/i3wm/commencementts/8a5psj/excluding_web_browsers_what_are_your_most_used][Excluding web browsers, what are your most used non-terminal programs in i3?]]
   - [[https://www.reddit.com/r/emacs/comments/8ajdbq/so_many_packages_cant_stop_myself][So many packages, can't stop myself!]]
   - [[http://irreal.org/blog/?p=7011][Ten Tools for Academics]]
   - [[http://www.mostlymaths.net/2016/09/more-emacs-configuration-tweaks.html][Rub√©n Berenguel: More emacs configuration tweaks (multiple-cursor on click, minimap, code folding, ensime eval overlays]]
** TODO Bling-bling (js)                                              :js:retro:

 :PROPERTIES:

 :EXPORT_FILE_NAME: bling-bling--js

 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
 :EXPORT_HUGO_AUTO_SET_LASTMOD: t
 :END:

  Here is some code to emulate the beloved <blink> tag. You can even load jQuery off of Google.

  #+begin_src js
    <span id="blink-me">the only blinking moment is now</span>
    <script>
      window.setInterval(function() {
        $('#blink-me').css('visibility',
            $('#blink-me').css('visibility') == 'hidden' ? 'visible' : 'hidden')
      }, 400);
    </script>
  #+end_src

  Don't you know that the only blinking moment is now, grasshopper?

  https://developers.google.com/speed/libraries/devguide#jquery

** TODO Zines -- retro-new                                               :retro:

 :PROPERTIES:

 :EXPORT_FILE_NAME: zines-retro-new

 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
 :EXPORT_HUGO_AUTO_SET_LASTMOD: t
 :END:

 Why zines?

Remember first time I saw a zine, or maybe more precise, this is the first time I remember.

Link

Beginning of the nineties, magazines all over, unlike today. I really don't know anybody who still reads magazines. Which is sad in a way, because a magazine does have some posts over blogposts, curation, and cooperation.

Zines share the pluses of magazines.

Used to read many magazines, don't remember virtually any of them. Zine, yes.

Rop Kongrijp, xs4all.

Sorry lol I'm history of zones, shoes history of specific sub-cyltures.

Dead cow book

## Cyberpunk

Zines are very cyberpunk. Not capitalistic, nobody gets paid, underground, freedom to write, show what we want.

Why is this good? Polar opposite of a zone is Facebook. Lowest common denominator. With excesses fat beyond what is good for society at large.

No limits at all? No limits are good, limits in art,
Limits in words, shoes values of group, eg no hate-speech (which is a lot more complicated, then what you would think).

Examples of art.

Examples of writing
SF, poetry

Examples of culture0

Greetings from the underground

Dostoyevsky

Russian underground art.

Modern underground art

Push boundaries, not many boundaries left, Reverting old boundaries.

Technical boundaries

Copyright AI created

Write about css art. Ask for an image

Zines are good for you. They're the vegetables of writing. Read, write and create. Tilde gives us a playground and a canvas, Irc gives a community.

Dostoyevsky / dictionary quote

** TODO What makes a good app?                                         :opinion:

 :PROPERTIES:

 :EXPORT_FILE_NAME: what-makes-a-good-app

 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
 :EXPORT_HUGO_AUTO_SET_LASTMOD: t
 :END:

 What makes a good app

    no ads
    open source / free software
    usability
    does what I need
    stability
    does what I want

** TODO How to read

 :PROPERTIES:

 :EXPORT_FILE_NAME: how-to-read

 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
 :EXPORT_HUGO_AUTO_SET_LASTMOD: t
 :END:

 How to read

Rain on roof, reading the hobbit. In one go.

Completely absorbed. Would be talking about my latest favorite book.

Now easier to watch something, spend time on the net.

Back to basics, how to read.

    how to read fiction

    how to read non-fiction

    how to take notes

    How do you analyze a novel?

    How to Read Closely: Making Sense Out of Novels - Cornell College

    Note-Taking for Reading | SkillsYouNeed

Analyzing fiction

Cliffs note
Analyzing non-fiction

https://www.cornellcollege.edu/academic-support-and-advising/academic-support/study-tips/reading-textbooks.shtml
Taking notes

Outlines & mind maps
Got it!
Our websites and dashboards use cookies. By continuing, you agree to their use. Learn more, including how to control cookies.

** TODO Dresden - reading order

 :PROPERTIES:

 :EXPORT_FILE_NAME: dresden-reading-order

 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
 :EXPORT_HUGO_AUTO_SET_LASTMOD: t
 :END:

 This is for those who might be new to the series and were wondering the order in which to read them. While the main plot in each book is begun and wrapped up in each novel, there is also a continuing plot from one book to the next. New books tend to refer to past events so in order to avoid confusion it might be best to read them in the the order published.

Source: Dresden Files | Jim Butcher

    Prequel - Welcome to the Jungle (Graphic Novel)

    x Book 1 - Storm Front

    x Book 2 - Fool Moon

    x Book 3 - Grave Peril

    x Book 4 - Summer Knight

    x Book 5 - Death Masks

    Book 6 - Blood Rites 8/3

    Book 7 - Dead Beat 13/3

    "Something Borrowed" - Short story in My Big Fat Supernatural Wedding

    x Book 8 - Proven Guilty

    x Book 9 - White Night

    "It's My Birthday Too" - Short story in Many Bloody Returns

    "Heorot" - short story in My Big Fat Supernatural Honeymoon

    x Book 10 - Small Favor 10/04 Novella - Backup (not sure where this falls as I haven't read it but it was published between 10 and 11 & is a story from Thomas's POV)

    x Book 11 - Turn Coat 13/04

    x Book 12 - Changes

    Book 12a - Side Jobs - a collection of short stories - see Message 34 of this post for more detail

    x Book 13 - Ghost Story - in stores 26 July 2011

    Book 14 - Cold Days - released TBD, most likely some time in 2012

    Book 15 Skin Game 03/05/18

    Book 16 Peace Talks

    Big foot on campus 23-04-2018

    Curses 23-04-2018

- Even hand 23-04-2018 John Marcone story
Got it!
Our websites and dashboards use cookies. By continuing, you agree to their use. Learn more, including how to control cookies.

** TODO The eigthies -- secretly great                                   :music:
   :PROPERTIES:
   :EXPORT_FILE_NAME: the-eigthies-secretly-great
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: t
   :END:

   - [100 Best Songs Of The 1980s - NME](http://www.nme.com/list/100-best-songs-of-the-1980s-1161)
   - [Sounds of the Eighties (BBC - Discs 1 and 2) (download torrent) Ted Cruzing](https://cruzing.xyz/torrent/6762065/Sounds_of_the_Eighties___(BBC_-_Discs_1_and_2))
   - [Best Songs Of The 80s - YouTube](https://m.youtube.com/watch?v=FKd2G9CYKmE)


* Posts
** DONE hugo and ngrok, for fun and profit                   :hugo:ngrok:webdev:
   CLOSED: [2021-01-17 Sun 13:25]
   :PROPERTIES:
   :EXPORT_FILE_NAME: hugo-and-ngrok-for-fun-and-profit
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: nil
   :END:

   #+CAPTION: Tunnel ([[https://commons.wikimedia.org/wiki/File:Williamson_Tunnels_-_The_Banqueting_Hall.jpg][wikipedia]])
    #+NAME:   fig:tunnnel-ngrok
    [[/images/640px-Williamson_Tunnels_-_The_Banqueting_Hall.png]]

   [[https://gohugo.io/documentation/][Hugo]] is able to quickly update a site, and makes improving and bug-fixing very simple. Showing your work-in-progress online is not as simple, and probably not what you want, anyway. Comes in [[https://ngrok.com/][ngrok]].

   > ngrok allows you to expose a web server running on your local machine to the internet. Just tell ngrok what port your web server is listening on.

   Installation is simple, just download from [[https://ngrok.com/download][here]], and put it in your path.

   Forwarding a local hugo session is as simple as:

   #+begin_src shell
     ngrok http 1313
   #+end_src

   To automate it:

    #+begin_src shell
      #!/usr/bin/env bash
      # var for session name (to avoid repeated occurences)
      SN="hugostuff"
      PROJ="$(pwd)"

      tmux new-session -s "$SN" -n "$PROJ" -d

      tmux new-window -t "$SN:1" 'hugo -D -w server --disableFastRender'
      tmux new-window -t "$SN:2" 'ngrok http 1313'

      # Select window #1 and attach to the session
      tmux select-window -t "$SN:2"
      tmux -2 attach-session -t "$SN"
   #+end_src


   And ... that did not work well at all. On my machine it worked perfectly, but outside, where localhost did not work, my test-project missed all js-, css- and img-files. The solution is not hard, this is what I found in the theme:

   #+begin_src html
     <a class="navbar-brand" href="{{ "/" | relLangURL }}"><img class="logo" src="{{ "img/logo.jpeg" | absURL }}" alt="{{ .Site.Title }}"></a>
   #+end_src

   If you use =absURL=, you end up with **localhost** in the complete url, but if you use =relURL=, you get a relative link:

   #+caption: [[https://gohugo.io/functions/absurl/][Hugo documentation]]
   #+begin_src html
     {{ "mystyle.css" | absURL }} ‚Üí "https://example.com/hugo/mystyle.css"
     {{ "mystyle.css" | relURL }} ‚Üí "/hugo/mystyle.css"
   #+end_src

   Source: [[https://gohugo.io/functions/absurl/][Hugo documentation]]

   So, the problem was solved doing a quick find-replace: =s/absURL/relURL/g=

   #+begin_src html
     <a class="navbar-brand" href="{{ "/" | relLangURL }}"><img class="logo" src="{{ "img/logo.jpeg" | relURL }}" alt="{{ .Site.Title }}"></a>
   #+end_src

   Finally! Profit!

** DONE Putting my site on a diet
   CLOSED: [2021-01-18 Mon 18:05]
   :PROPERTIES:
   :EXPORT_FILE_NAME: putting-my-site-on-a-diet
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :EXPORT_HUGO_AUTO_SET_LASTMOD: t
   :END:

   Surfing I ran into [[https://512kb.club/][512kb.club]], which lamented:

   > The internet has become a bloated mess. Massive javascript libraries, countless client-side queries and overly complex frontend frameworks are par for the course these days.

   And I agree, the web is becoming unusable, or at least annoying, and we should all do our part. As the name implies, to become part of the club XXX, the "... total UNCOMPRESSED web resources must not exceed 512KB." Mine did, so, time to put my slim down my site.

   Initial size, 349.9Kb, uncompressed, 558.1Kb:

   #+caption: 558.1 Kb -- not good enough
   [[/images/diet-size.png]]

   The biggest assets my site uses are the *Font Awesome* icons, so that's the obvious place to start. But how to get rid of those files (without loosing my icons)? Looking over my site I noticed that I don't really use all that many icons, just for **mastodon**, **github** and **email**. Why not replace those icons with (inline) svg icons instead? That thought lead me to [[http://oostens.me/posts/hugo-resources-inline-svg-icons/][this excellent page]].

   The short of it is:

   1. Create =<workdir>/assets/svg=, and dump the svgs in here.
   2. Add partial in =<workdir>/layouts/partials/inline-svg.html=.
   3. Add the shortcode in =<workdir>/layouts/shortcodes/inline-svg.html=.
   4. Add scss in =<workdir>/assets/sass/2-components/_svg.scss=

   #+caption: partial inline-svg.html
   #+begin_src html
     {{ $svg := resources.Get (print "svg/" . ".svg") }}
     <i class="inline-svg" >{{ $svg.Content | safeHTML }}</i>
   #+end_src

   #+caption: shortcode inline-svg.html
   #+begin_src html
     {{- partial "inline-svg" (.Get 0) -}}
   #+end_src

   #+caption: _svg.scss
   #+begin_src css
     .inline-svg {
       display: inline-block;
       vertical-align: middle;

       svg {
         width: 1em;
         height: 1em;
         fill: currentColor;
         display: inline-block;
       }
     }
   #+end_src

   All this should result in the following shortcode:

   #+begin_src html
     {{</* inline-svg "mastodon" */>}}
   #+end_src

   And if everything is correct, this prints a mastodon icon: {{< inline-svg "mastodon" >}}, yes!

   5. Next, replace all Font awesome icons.

      Find svg-icons from [[https://iconify.design/icon-sets/][iconify.design]]. Fix your template ... profit!

   #+caption: Much better! 348.3 Kb
   [[/images/diet-size-2.png]]

*** Resources

    - [[http://oostens.me/posts/hugo-resources-inline-svg-icons/][Hugo + resources = inline svg icons]]


** INPROGRESS XMonad from scratch -- day 1 -- Starting small            :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-1
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

*** Intro -- taste and time
    There are plenty of [[https://en.wikipedia.org/wiki/Comparison_of_X_window_managers][Window Managers]] for Linux and *BSD, some of the more famous ones are [[https://i3wm.org/][I3]],

    It is impossible to say which one is the best, the word *best* is a terrible qualifier, what does it mean *best*? The smallest, fastest, the one with the most things you can edit?

    Despite all that, XMonad is **one** of the **best** window managers. Why? Because it is really, really good at managing windows. With a little bit of elbow grease you can make it do whatever you want. And it can even look really good doing it:

    #+CAPTION: This is what your desktop could look like ... if you have taste, and lots of time
    #+NAME:   fig:xmonad-1
    [[/images/xmonad-day1-1.png]]

    In this series we will help you configure XMonad to do what you want, or at least, give you the tools to do so. BTW, allthough this desktop looks really good, it is by no means the most advanced configuration around.

    Links:

    - [[https://github.com/Axarva/dotfiles-2.0][Axarva/dotfiles-2.0]] - really good looking XMonad install

*** TODO Dev-environment

    Experimenting is fun, but loosing all your work not so much, we will set up a simple dev-environment that we can use to play around.

    Script:


    For reference:

    - [[https://wiki.archlinux.org/index.php/Xephyr][Arch wiki - Xephyr]]
*** Mimimal - lets start small

    XMonad is written in [[https://www.haskell.org/][haskell]], which is a really weird language. But, as XMonad proves, it is very powerfull, and you don't have too understand all (any?) of it to be able to use XMonad for yourself. We will start small, and slowly add more functionality to our setup, explaining what we actually added.

    **Installation:**

    A minimal install needs the following, I am using Arch, but you can do the same on Ubuntu Slackware or whatever else you want to run, just use your flavor of package-manager. Arch is just a good base-line, as the packages it installs are as close to upstream as possible:

    #+begin_src shell
      sudo pacman -S xmonad xmonad-contrib xmobar dmenu xterm
    #+end_src

    **XMonad** is XMonad itself, **xmonad-contrib** is a library of extra functionality, this is what makes XMonad so outstanding, **dmenu** is minimal a program launcher, and **xterm** is the default terminal. It looks a bit spartan, but it is enough to get a lot done, actually.

    To start up XMonad, to quote [[https://wiki.archlinux.org/index.php/Xmonad#Starting][the Arch Wiki]]:

    #+begin_quote
    Run xmonad with xinit (1).

    Alternatively, select Xmonad from the session menu in a display manager of choice (2).
    #+end_quote

    1. Which, translated for mortals means you add / create a file called =$HOME/.xinitrc=, which contains the line:

    #+CAPTION: bare xinitrc
    #+begin_src sh
      exec xmonad
    #+end_src

    You can now start XMonad using **startx**

    Note: On arch you need to install **xorg-xinit**, which contains =/usr/bin/startx=

    2. If you use a [[https://wiki.archlinux.org/index.php/Display_manager][display manager]], like GDM or SSDM, you can just choose *xmonad* when you login.

    For reference:

    - [[https://wiki.archlinux.org/index.php/Xmonad][xmonad - ArchWiki]]
    - [[https://wiki.archlinux.org/index.php/Xmobar][xmobar - ArchWiki]]
    - [[https://wiki.archlinux.org/index.php/Dmenu][dmenu - ArchWiki]]
    - [[https://wiki.archlinux.org/index.php/Xterm#Installation][xterm - ArchWiki]]

    Right, now we have the base of our setup.
    We will be following: [[https://wiki.haskell.org/Xmonad/Config_archive/John_Goerzen%27s_Configuration][John Coerzen]]




  About as bare as it gets, the only changes from the default are:

  - favourite terminal
  - favourite keybinding

  #+begin_src haskell :tangle  ~/.xmonad/xmonad.hs
  import XMonad

  main = xmonad defaultConfig
          { modMask = mod4Mask -- Use Super instead of Alt
          , terminal = "alacritty"
          -- more changes
  }
  #+end_src

    Note that xmonad>=0.11 has by default a list of the default keybindings bound to M-S-/ or M-?.

  For reference:

  - [[https://wiki.archlinux.org/index.php/Alacritty][Alacritty - ArchWiki]]

*** PS -- the default configuration

    - [[https://wiki.haskell.org/Xmonad/Config_archive/Template_xmonad.hs_(darcs)][Template_xmonad.hs_(darcs)]]
    - [[https://wiki.haskell.org/Xmonad/Config_archive/yiannist%27s_xmonad.hs][yiannist's xmonad.hs]]

    #+caption: Default XMonad confiuration
    #+begin_src haskell :tangle no
      --
      -- xmonad example config file.
      --
      -- A template showing all available configuration hooks,
      -- and how to override the defaults in your own xmonad.hs conf file.
      --
      -- Normally, you'd only override those defaults you care about.
      --

      import XMonad
      import Data.Monoid
      import System.Exit

      import qualified XMonad.StackSet as W
      import qualified Data.Map        as M

      -- The preferred terminal program, which is used in a binding below and by
      -- certain contrib modules.
      --
      myTerminal      = "xterm"

      -- Whether focus follows the mouse pointer.
      myFocusFollowsMouse :: Bool
      myFocusFollowsMouse = True

      -- Whether clicking on a window to focus also passes the click to the window
      myClickJustFocuses :: Bool
      myClickJustFocuses = False

      -- Width of the window border in pixels.
      --
      myBorderWidth   = 1

      -- modMask lets you specify which modkey you want to use. The default
      -- is mod1Mask ("left alt").  You may also consider using mod3Mask
      -- ("right alt"), which does not conflict with emacs keybindings. The
      -- "windows key" is usually mod4Mask.
      --
      myModMask       = mod1Mask

      -- The default number of workspaces (virtual screens) and their names.
      -- By default we use numeric strings, but any string may be used as a
      -- workspace name. The number of workspaces is determined by the length
      -- of this list.
      --
      -- A tagging example:
      --
      -- > workspaces = ["web", "irc", "code" ] ++ map show [4..9]
      --
      myWorkspaces    = ["1","2","3","4","5","6","7","8","9"]

      -- Border colors for unfocused and focused windows, respectively.
      --
      myNormalBorderColor  = "#dddddd"
      myFocusedBorderColor = "#ff0000"

      ------------------------------------------------------------------------
      -- Key bindings. Add, modify or remove key bindings here.
      --
      myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList $

          -- launch a terminal
          [ ((modm .|. shiftMask, xK_Return), spawn $ XMonad.terminal conf)

          -- launch dmenu
          , ((modm,               xK_p     ), spawn "dmenu_run")

          -- launch gmrun
          , ((modm .|. shiftMask, xK_p     ), spawn "gmrun")

          -- close focused window
          , ((modm .|. shiftMask, xK_c     ), kill)

           -- Rotate through the available layout algorithms
          , ((modm,               xK_space ), sendMessage NextLayout)

          --  Reset the layouts on the current workspace to default
          , ((modm .|. shiftMask, xK_space ), setLayout $ XMonad.layoutHook conf)

          -- Resize viewed windows to the correct size
          , ((modm,               xK_n     ), refresh)

          -- Move focus to the next window
          , ((modm,               xK_Tab   ), windows W.focusDown)

          -- Move focus to the next window
          , ((modm,               xK_j     ), windows W.focusDown)

          -- Move focus to the previous window
          , ((modm,               xK_k     ), windows W.focusUp  )

          -- Move focus to the master window
          , ((modm,               xK_m     ), windows W.focusMaster  )

          -- Swap the focused window and the master window
          , ((modm,               xK_Return), windows W.swapMaster)

          -- Swap the focused window with the next window
          , ((modm .|. shiftMask, xK_j     ), windows W.swapDown  )

          -- Swap the focused window with the previous window
          , ((modm .|. shiftMask, xK_k     ), windows W.swapUp    )

          -- Shrink the master area
          , ((modm,               xK_h     ), sendMessage Shrink)

          -- Expand the master area
          , ((modm,               xK_l     ), sendMessage Expand)

          -- Push window back into tiling
          , ((modm,               xK_t     ), withFocused $ windows . W.sink)

          -- Increment the number of windows in the master area
          , ((modm              , xK_comma ), sendMessage (IncMasterN 1))

          -- Deincrement the number of windows in the master area
          , ((modm              , xK_period), sendMessage (IncMasterN (-1)))

          -- Toggle the status bar gap
          -- Use this binding with avoidStruts from Hooks.ManageDocks.
          -- See also the statusBar function from Hooks.DynamicLog.
          --
          -- , ((modm              , xK_b     ), sendMessage ToggleStruts)

          -- Quit xmonad
          , ((modm .|. shiftMask, xK_q     ), io (exitWith ExitSuccess))

          -- Restart xmonad
          , ((modm              , xK_q     ), spawn "xmonad --recompile; xmonad --restart")

          -- Run xmessage with a summary of the default keybindings (useful for beginners)
          , ((modm .|. shiftMask, xK_slash ), spawn ("echo \"" ++ help ++ "\" | xmessage -file -"))
          ]
          ++

          --
          -- mod-[1..9], Switch to workspace N
          -- mod-shift-[1..9], Move client to workspace N
          --
          [((m .|. modm, k), windows $ f i)
              | (i, k) <- zip (XMonad.workspaces conf) [xK_1 .. xK_9]
              , (f, m) <- [(W.greedyView, 0), (W.shift, shiftMask)]]
          ++

          --
          -- mod-{w,e,r}, Switch to physical/Xinerama screens 1, 2, or 3
          -- mod-shift-{w,e,r}, Move client to screen 1, 2, or 3
          --
          [((m .|. modm, key), screenWorkspace sc >>= flip whenJust (windows . f))
              | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
              , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]


      ------------------------------------------------------------------------
      -- Mouse bindings: default actions bound to mouse events
      --
      myMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $

          -- mod-button1, Set the window to floating mode and move by dragging
          [ ((modm, button1), (\w -> focus w >> mouseMoveWindow w
                                             >> windows W.shiftMaster))

          -- mod-button2, Raise the window to the top of the stack
          , ((modm, button2), (\w -> focus w >> windows W.shiftMaster))

          -- mod-button3, Set the window to floating mode and resize by dragging
          , ((modm, button3), (\w -> focus w >> mouseResizeWindow w
                                             >> windows W.shiftMaster))

          -- you may also bind events to the mouse scroll wheel (button4 and button5)
          ]

      ------------------------------------------------------------------------
      -- Layouts:

      -- You can specify and transform your layouts by modifying these values.
      -- If you change layout bindings be sure to use 'mod-shift-space' after
      -- restarting (with 'mod-q') to reset your layout state to the new
      -- defaults, as xmonad preserves your old layout settings by default.
      --
      -- The available layouts.  Note that each layout is separated by |||,
      -- which denotes layout choice.
      --
      myLayout = tiled ||| Mirror tiled ||| Full
        where
           -- default tiling algorithm partitions the screen into two panes
           tiled   = Tall nmaster delta ratio

           -- The default number of windows in the master pane
           nmaster = 1

           -- Default proportion of screen occupied by master pane
           ratio   = 1/2

           -- Percent of screen to increment by when resizing panes
           delta   = 3/100

      ------------------------------------------------------------------------
      -- Window rules:

      -- Execute arbitrary actions and WindowSet manipulations when managing
      -- a new window. You can use this to, for example, always float a
      -- particular program, or have a client always appear on a particular
      -- workspace.
      --
      -- To find the property name associated with a program, use
      -- > xprop | grep WM_CLASS
      -- and click on the client you're interested in.
      --
      -- To match on the WM_NAME, you can use 'title' in the same way that
      -- 'className' and 'resource' are used below.
      --
      myManageHook = composeAll
          [ className =? "MPlayer"        --> doFloat
          , className =? "Gimp"           --> doFloat
          , resource  =? "desktop_window" --> doIgnore
          , resource  =? "kdesktop"       --> doIgnore ]

      ------------------------------------------------------------------------
      -- Event handling

      -- * EwmhDesktops users should change this to ewmhDesktopsEventHook
      --
      -- Defines a custom handler function for X Events. The function should
      -- return (All True) if the default handler is to be run afterwards. To
      -- combine event hooks use mappend or mconcat from Data.Monoid.
      --
      myEventHook = mempty

      ------------------------------------------------------------------------
      -- Status bars and logging

      -- Perform an arbitrary action on each internal state change or X event.
      -- See the 'XMonad.Hooks.DynamicLog' extension for examples.
      --
      myLogHook = return ()

      ------------------------------------------------------------------------
      -- Startup hook

      -- Perform an arbitrary action each time xmonad starts or is restarted
      -- with mod-q.  Used by, e.g., XMonad.Layout.PerWorkspace to initialize
      -- per-workspace layout choices.
      --
      -- By default, do nothing.
      myStartupHook = return ()

      ------------------------------------------------------------------------
      -- Now run xmonad with all the defaults we set up.

      -- Run xmonad with the settings you specify. No need to modify this.
      --
      main = xmonad defaults

      -- A structure containing your configuration settings, overriding
      -- fields in the default config. Any you don't override, will
      -- use the defaults defined in xmonad/XMonad/Config.hs
      --
      -- No need to modify this.
      --
      defaults = def {
            -- simple stuff
              terminal           = myTerminal,
              focusFollowsMouse  = myFocusFollowsMouse,
              clickJustFocuses   = myClickJustFocuses,
              borderWidth        = myBorderWidth,
              modMask            = myModMask,
              workspaces         = myWorkspaces,
              normalBorderColor  = myNormalBorderColor,
              focusedBorderColor = myFocusedBorderColor,

            -- key bindings
              keys               = myKeys,
              mouseBindings      = myMouseBindings,

            -- hooks, layouts
              layoutHook         = myLayout,
              manageHook         = myManageHook,
              handleEventHook    = myEventHook,
              logHook            = myLogHook,
              startupHook        = myStartupHook
          }

      -- | Finally, a copy of the default bindings in simple textual tabular format.
      help :: String
      help = unlines ["The default modifier key is 'alt'. Default keybindings:",
          "",
          "-- launching and killing programs",
          "mod-Shift-Enter  Launch xterminal",
          "mod-p            Launch dmenu",
          "mod-Shift-p      Launch gmrun",
          "mod-Shift-c      Close/kill the focused window",
          "mod-Space        Rotate through the available layout algorithms",
          "mod-Shift-Space  Reset the layouts on the current workSpace to default",
          "mod-n            Resize/refresh viewed windows to the correct size",
          "",
          "-- move focus up or down the window stack",
          "mod-Tab        Move focus to the next window",
          "mod-Shift-Tab  Move focus to the previous window",
          "mod-j          Move focus to the next window",
          "mod-k          Move focus to the previous window",
          "mod-m          Move focus to the master window",
          "",
          "-- modifying the window order",
          "mod-Return   Swap the focused window and the master window",
          "mod-Shift-j  Swap the focused window with the next window",
          "mod-Shift-k  Swap the focused window with the previous window",
          "",
          "-- resizing the master/slave ratio",
          "mod-h  Shrink the master area",
          "mod-l  Expand the master area",
          "",
          "-- floating layer support",
          "mod-t  Push window back into tiling; unfloat and re-tile it",
          "",
          "-- increase or decrease number of windows in the master area",
          "mod-comma  (mod-,)   Increment the number of windows in the master area",
          "mod-period (mod-.)   Deincrement the number of windows in the master area",
          "",
          "-- quit, or restart",
          "mod-Shift-q  Quit xmonad",
          "mod-q        Restart xmonad",
          "mod-[1..9]   Switch to workSpace N",
          "",
          "-- Workspaces & screens",
          "mod-Shift-[1..9]   Move client to workspace N",
          "mod-{w,e,r}        Switch to physical/Xinerama screens 1, 2, or 3",
          "mod-Shift-{w,e,r}  Move client to screen 1, 2, or 3",
          "",
          "-- Mouse bindings: default actions bound to mouse events",
          "mod-button1  Set the window to floating mode and move by dragging",
          "mod-button2  Raise the window to the top of the stack",
          "mod-button3  Set the window to floating mode and resize by dragging"]

    #+end_src

** TODO XMonad from scratch -- day 2 -- Keybindings                     :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-2
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

*** My own keys - 1

    Add simple(r) keybindings. It will add to the existing ones, overriding them if nececeray.

    Module: [[http://hackage.haskell.org/package/xmonad-contrib-0.14/docs/XMonad-Util-EZConfig.html][XMonad-Util-EZConfig]]

    It's a good habit to read at least the intro of your new modules.

  #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Util.EZConfig(additionalKeys)
    import XMonad.Util.Run(spawnPipe)
    import System.IO

    main = do
        xmonad $ defaultConfig
            { modMask = mod4Mask     -- Rebind Mod to the Windows key
            , terminal = "alacritty"
            } `additionalKeys`
            [ ((mod4Mask .|. shiftMask, xK_z), spawn "xscreensaver-command -lock")
            , ((controlMask, xK_Print), spawn "sleep 0.2; scrot -s")
            , ((0, xK_Print), spawn "scrot")
            , ((mod4Mask, xK_e), spawn "emacsclient -nc")
            , ((mod4Mask, xK_b), spawn "qutebrowser")
            ]
  #+end_src
*** My own keys - 2 Emacs

    Add Emacs-style keybindings (=additionalKeysP=). For a list of keys, see [[http://hackage.haskell.org/package/xmonad-contrib-0.14/docs/XMonad-Util-EZConfig.html#v:mkKeymap][here]].

    Module: [[http://hackage.haskell.org/package/xmonad-contrib-0.14/docs/XMonad-Util-EZConfig.html][XMonad-Util-EZConfig]]

    Notice =XMonad.Util.EZConfig(additionalKeysP)=!

    #+begin_src haskell :tangle no
      import XMonad
      import XMonad.Util.EZConfig(additionalKeysP)
      import XMonad.Util.Run(spawnPipe)
      import System.IO

      main = do
      xmonad $ defaultConfig
        { modMask = mod4Mask     -- Rebind Mod to the Windows key
        , terminal = "alacritty"
        } `additionalKeysP`
        [ -- So much easier!
          ("M-e", spawn "emacsclient -nc")
        , ("M-b", spawn "qutebrowser")
        ]
    #+end_src

*** My own keys - 3 descriptions

    Next we'll be adding [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-NamedActions.html][XMonad.Util.NamedActions]].

    A wrapper for keybinding configuration that can list the available keybindings.

    Notice the difference beween the old help (which we haven't disabled yet) =M-?= and the new =M-<f1>=!

    #+begin_src haskell :tangle no
      import XMonad
      import XMonad.Util.Run(spawnPipe)
      import XMonad.Util.EZConfig
      import XMonad.Util.NamedActions
      import System.IO

      main = do
         xmonad $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
                         defaultConfig { modMask = mod4Mask , terminal = "alacritty"}

      myKeys c = (subtitle "Custom Keys":) $ mkNamedKeymap c $
         [ ("M-e", addName "Emacsclient" $ spawn "emacsclient -nc")
         , ("M-b", addName "Qutebrowser" $ spawn "qutebrowser")
         , ("M-c", sendMessage' Expand)]
          ^++^
         [("<XF86AudioPlay>", spawn "mpc toggle" :: X ()),
          ("<XF86AudioNext>", spawn "mpc next")]
    #+end_src

    See also new-style and old-style (needs =:: X ()=!) used, divided by =^++^=.

**** Multiple key blocks

     With a nice little macro? to make it look better.

    #+begin_src haskell :tangle no
      import XMonad
      import XMonad.Util.Run(spawnPipe)
      import XMonad.Util.EZConfig
      import XMonad.Util.NamedActions
      -- import System.IO

      myTerminal = "alacritty"

      main = do
         xmonad $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
                         defaultConfig { modMask = mod4Mask , terminal = myTerminal}

      myKeys conf = let
          subKeys str ks        = subtitle str : mkNamedKeymap conf ks
          in

          subKeys "My terminal bindings"
          [("M-h", addName "Htop"   $ spawn myTerminal)
          ] ^++^

          subKeys "My Emacs bindings"
          [("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
          ]
    #+end_src



**** More


      Links:

      - [[https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#Terminal_emulator_factories][Xmonad/General xmonad.hs config tips]]
      - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Doc-Extending.html][XMonad Doc Extending]]
      - [[https://wiki.haskell.org/Xmonad][wiki]] (has inkscape keyboard)

      - [[https://hackage.haskell.org/package/xmonad-0.15/docs/XMonad-Core.html#v:XConfig][XConfig]] what =can= be changed in main

** NEXT XMonad from scratch -- day 3 -- Xmobar                          :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-3
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   New module:

   - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-DynamicLog.html][XMonad.Hooks.DynamicLog]]

   Adding the needed plumbing:

   #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Hooks.DynamicLog
    import XMonad.Hooks.ManageDocks
    import XMonad.Util.Run(spawnPipe)
    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import System.IO

    myTerminal = "alacritty"

    myKeys conf = let
        subKeys str ks        = subtitle str : mkNamedKeymap conf ks
        in

        subKeys "My terminal bindings"
        [("M-h", addName "Htop"   $ spawn myTerminal)
        ] ^++^

        subKeys "My Emacs bindings"
        [("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
        ]

    main = do
        xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
        xmonad
            $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
            $ docks defaultConfig
            { layoutHook = avoidStruts  $  layoutHook defaultConfig
            , logHook = dynamicLogWithPP xmobarPP
                            { ppOutput = hPutStrLn xmproc
                            , ppTitle = xmobarColor "green" "" . shorten 50
                            }
            , modMask = mod4Mask
            }
  #+end_src

   And the bar itself:

   #+begin_src haskell :tangle no
    Config { font = "xft:Noto Sans:size=10:style=Bold"
           , bgColor = "black"
           , fgColor = "grey"
           , position = Top --W L 90
           , lowerOnStart = True
           , commands = [ Run Weather "EGPF" ["-t"," <tempF>F","-L","64","-H","77","--normal","green","--high","red","--low","lightblue"] 36000
                        , Run Cpu ["-L","3","-H","50","--normal","green","--high","red"] 10
                        , Run Memory ["-t","Mem: <usedratio>%"] 10
                        , Run Swap [] 10
                        , Run Date "%a %b %_d %l:%M" "date" 10
                        , Run StdinReader
                        ]
           , sepChar = "%"
           , alignSep = "}{"
           , template = "%StdinReader% }{  %cpu% | %memory% * %swap%    <fc=#ee9a00>%date%</fc> | %EGPF%"
           }
  #+end_src

** TODO XMonad from scratch -- day 4 -- Workspaces                      :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-4
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   *Workspaces - switching and naming*

   New module:

   - [[http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-ShowWName.html][XMonad.Layout.ShowWName]]

  #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Hooks.DynamicLog
    import XMonad.Hooks.ManageDocks
    import XMonad.Util.Run(spawnPipe)
    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import System.IO
    import XMonad.Layout.ShowWName

    myTerminal = "alacritty"

    myStatusFG = "#777777"
    myStatusBG = "#222222"
    myStatusFN = "xft:FiraCode Nerd Font Mono:weight=bold:pixelsize=18:antialias=true:hinting=true"
    myLargeFont = "xft:NotoSansMono Nerd Font:bold:size=60:antialias=true:hinting=true"
    myFadeTime  = 1.0

    -- Theme for showWName which prints current workspace when you change workspaces.
    myShowWNameTheme :: SWNConfig
    myShowWNameTheme = def
        { swn_font              = myLargeFont
        , swn_fade              = myFadeTime
        , swn_bgcolor           = myStatusBG
        , swn_color             = myStatusFG
        }

    myKeys conf = let
        subKeys str ks        = subtitle str : mkNamedKeymap conf ks
        in

        subKeys "My terminal bindings"
        [("M-h", addName "Htop"   $ spawn myTerminal)
        ] ^++^

        subKeys "My Emacs bindings"
        [("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
        ]

    main = do
        xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
        xmonad
            $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
            $ docks defaultConfig
            { layoutHook = showWName' myShowWNameTheme $ avoidStruts $ layoutHook defaultConfig
            , logHook = dynamicLogWithPP xmobarPP
                            { ppOutput = hPutStrLn xmproc
                            , ppTitle = xmobarColor "green" "" . shorten 50
                            }
            , modMask = mod4Mask
            }
  #+end_src

*** Naming workspaces

   #+begin_src haskell :tangle no
     import XMonad
     import XMonad.Hooks.DynamicLog
     import XMonad.Hooks.ManageDocks
     import XMonad.Util.Run(spawnPipe)
     import XMonad.Util.EZConfig
     import XMonad.Util.NamedActions
     import System.IO
     import XMonad.Layout.ShowWName

     myTerminal = "alacritty"

     myStatusFG = "#777777"
     myStatusBG = "#222222"
     myStatusFN = "xft:FiraCode Nerd Font Mono:weight=bold:pixelsize=18:antialias=true:hinting=true"
     myLargeFont = "xft:NotoSansMono Nerd Font:bold:size=60:antialias=true:hinting=true"
     myFadeTime  = 1.0

     -- Theme for showWName which prints current workspace when you change workspaces.
     myShowWNameTheme :: SWNConfig
     myShowWNameTheme = def
         { swn_font              = myLargeFont
         , swn_fade              = myFadeTime
         , swn_bgcolor           = myStatusBG
         , swn_color             = myStatusFG
         }

     myKeys conf = let
         subKeys str ks        = subtitle str : mkNamedKeymap conf ks
         in

         subKeys "My terminal bindings"
         [("M-h", addName "Htop"   $ spawn myTerminal)
         ] ^++^

         subKeys "My Emacs bindings"
         [("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
         ]

     wsWEB = "web"
     wsTXT = "txt"
     wsTRM = "term"
     wsSYS = "sys"
     wsCHT = "chat"
     wsFLT = "flot"
     wsMOV = "movies"
     wsTMP = "tmp"

     myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

     main = do
         xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
         xmonad
             $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
             $ docks defaultConfig
             { layoutHook =  showWName' myShowWNameTheme $ avoidStruts $ layoutHook defaultConfig
             , logHook    = dynamicLogWithPP xmobarPP
                             { ppOutput = hPutStrLn xmproc
                             , ppTitle = xmobarColor "green" "" . shorten 50
                             }
             , modMask    = mod4Mask
             , workspaces = myWorkspaces
             }
   #+end_src

** TODO XMonad from scratch -- day 5 -- Layouts                         :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-5
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:


   This is where things get interesting. Xmonad has a /lot/ of different layout. We'll start with my favourites.

   New modules:

   - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-Renamed.html][XMonad.Layout.Renamed]]
   - [[http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-Fullscreen.html][XMonad.Layout.Fullscreen]]

   =Mirror= takes a layout, and rotates it, twicw the fun with one layout!

   Added a keybinding =M-tab=, the default is =M-space=, to go the next layout.

   #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Hooks.DynamicLog
    import XMonad.Hooks.ManageDocks
    import XMonad.Util.Run(spawnPipe)
    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import System.IO
    import XMonad.Layout.ShowWName
    import XMonad.Layout.Fullscreen
    import XMonad.Layout.Renamed

    myTerminal = "alacritty"

    myStatusFG = "#777777"
    myStatusBG = "#222222"
    myStatusFN = "xft:FiraCode Nerd Font Mono:weight=bold:pixelsize=18:antialias=true:hinting=true"
    myLargeFont = "xft:NotoSansMono Nerd Font:bold:size=60:antialias=true:hinting=true"
    myFadeTime  = 1.0

    -- Theme for showWName which prints current workspace when you change workspaces.
    myShowWNameTheme :: SWNConfig
    myShowWNameTheme = def
        { swn_font              = myLargeFont
        , swn_fade              = myFadeTime
        , swn_bgcolor           = myStatusBG
        , swn_color             = myStatusFG
        }

    myKeys conf = let
        subKeys str ks        = subtitle str : mkNamedKeymap conf ks
        in

        subKeys "My terminal bindings"
        [("M-h", addName "Htop"   $ spawn myTerminal)
        ] ^++^

        subKeys "My Emacs bindings"
        [("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
        ] ^++^

        subKeys "Layout bindings"
        [ ("M-<Tab>", addName "Next layout" $ sendMessage NextLayout)
        ]

    wsWEB = "web"
    wsTXT = "txt"
    wsTRM = "term"
    wsSYS = "sys"
    wsCHT = "chat"
    wsFLT = "flot"
    wsMOV = "movies"
    wsTMP = "tmp"

    myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    myLayouthook = avoidStruts $
                   showWName' myShowWNameTheme $
                   -- layoutHook defaultConfig
                   tall ||| wide ||| full
    tall   = renamed [Replace "tall"] $ Tall 1 0.03 0.5
    wide   = renamed [Replace "wide"] $ Mirror tall
    full   = renamed [Replace "full"] $ Full

    main = do
        xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
        xmonad
            $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
            $ docks defaultConfig
            { layoutHook = myLayouthook
            , logHook    = dynamicLogWithPP xmobarPP
                            { ppOutput = hPutStrLn xmproc
                            , ppTitle = xmobarColor "green" "" . shorten 50
                            }
            , modMask    = mod4Mask
            , workspaces = myWorkspaces
            }
  #+end_src

** TODO XMonad from scratch -- day 6 -- Colors, applications and variables :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-6
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

  No new libraries, just some rewriting for future expansion, better colors, and central variables.

  #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Hooks.DynamicLog
    import XMonad.Hooks.ManageDocks
    import XMonad.Util.Run(spawnPipe)
    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import System.IO
    import XMonad.Layout.ShowWName
    import XMonad.Layout.Fullscreen
    import XMonad.Layout.Renamed

    ------------------------------------------------------------------------}}}
    -- General                                                              {{{
    ---------------------------------------------------------------------------

    myModMask                     = mod4Mask
    myTerminal = "alacritty"

    wsWEB = "web"
    wsTXT = "txt"
    wsTRM = "term"
    wsSYS = "sys"
    wsCHT = "chat"
    wsFLT = "flot"
    wsMOV = "movies"
    wsTMP = "tmp"

    myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    ------------------------------------------------------------------------}}}
    -- Theme                                                                {{{
    ---------------------------------------------------------------------------

    myFocusFollowsMouse  = False
    myClickJustFocuses   = True

    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"

    -- sizes
    gap         = 10
    topbar      = 10
    border      = 2
    prompt      = 20
    status      = 20

    myNormalBorderColor     = "#000000"
    myFocusedBorderColor    = active

    active      = blue
    activeWarn  = red
    inactive    = base02
    focusColor  = blue
    unfocusColor = base02

    myFont      = "-*-terminus-medium-*-*-*-*-160-*-*-*-*-*-*"
    myBigFont   = "-*-terminus-medium-*-*-*-*-240-*-*-*-*-*-*"
    myLargeFont = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"

    -- Theme for showWName which prints current workspace when you change workspaces.
    myShowWNameTheme :: SWNConfig
    myShowWNameTheme = def
        { swn_font              = myLargeFont
        , swn_fade              = 1.0
        , swn_bgcolor           = "#000000"
        , swn_color             = "#FFFFFF"
        }

    ------------------------------------------------------------------------}}}
    -- Keys                                                                 {{{
    ---------------------------------------------------------------------------

    myKeys conf = let
        subKeys str ks        = subtitle str : mkNamedKeymap conf ks
        in

        subKeys "My terminal bindings"
        [("M-h", addName "Htop"   $ spawn myTerminal)
        ] ^++^

        subKeys "My Emacs bindings"
        [("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
        ]

    ------------------------------------------------------------------------}}}
    -- Hooks & main                                                         {{{
    ---------------------------------------------------------------------------

    myLayouthook = avoidStruts $
                   showWName' myShowWNameTheme $
                   -- layoutHook defaultConfig
                   tall ||| wide ||| full
    tall   = renamed [Replace "tall"] $ Tall 1 0.03 0.5
    wide   = renamed [Replace "wide"] $ Mirror tall
    full   = renamed [Replace "full"] $ Full

    main = do
        xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
        xmonad
            $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
            $ docks def
                { borderWidth        = border
                , clickJustFocuses   = myClickJustFocuses
                , focusFollowsMouse  = myFocusFollowsMouse
                , normalBorderColor  = myNormalBorderColor
                , focusedBorderColor = myFocusedBorderColor
                , layoutHook =  myLayouthook
                , logHook  = dynamicLogWithPP xmobarPP
                    { ppOutput          = hPutStrLn xmproc
                    , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                    , ppTitle           = xmobarColor active "" . shorten 50
                    , ppVisible         = xmobarColor base0  "" . wrap "(" ")"
                    , ppUrgent          = xmobarColor red    "" . wrap " " " "
                    , ppHiddenNoWindows = const ""
                    , ppSep             = xmobarColor red myNormalBorderColor " : "
                    , ppWsSep           = " "
                    , ppLayout          = xmobarColor yellow ""
                    , ppOrder           = id
                    }
                , modMask    = mod4Mask
                , workspaces = myWorkspaces
                }
  #+end_src

  **And mobar:**

  Three kind of fonts used, regular, bold for the time, and font-awesome for icons.
  Colors the same as in our =xmonad.hs=.

  #+begin_src haskell :tangle ~/.xmonad/xmobar.hs
    Config { font = "xft:Noto Sans:size=10:style=Regular"
           , additionalFonts   = [ "xft:FontAwesome:pixelsize=16:antialias=true:hinting=true",
                                   "xft:Noto Sans:size=10:style=Bold"]
           , allDesktops       = True
           , bgColor           = "#000000"
           , fgColor           = "#586e75"
           , overrideRedirect  = True
           , commands           = [
           Run Cpu [ "--template", "<fc=#a9a1e1><fn=1>ÔÇÖ</fn></fc> <total>%"
                --, "--normal","#bbc2cf"
                , "-L", "40"
                , "-H", "60"
                , "-l", "#586e75"
                , "-h", "#dc322f" -- red
                ] 50
            , Run Memory ["-t","<fc=#51afef><fn=1>Ôãõ</fn></fc> <usedratio>%"
                , "-H","80"
                , "-L","10"
                , "-l", "#586e75"
                , "-h", "#268bd2" -- blue, just to differentiate from cpu bar
                ] 50
            , Run Wireless "" -- will match any wireless device
                [ "-a", "l"
                , "-x", "-"
                , "-t", "<fc=#6c71c4><fn=1>\xf1eb</fn> <essid> <quality>%</fc>"
                , "-L", "50"
                , "-H", "75"
                -- , "-l", "#dc322f" -- red
                , "-l", "#6c71c4" -- violet
                , "-n", "#6c71c4" -- violet
                , "-h", "#6c71c4" -- violet
                ] 10
            , Run StdinReader
            , Run Battery
                [ "-t", "<fc=#b58900><acstatus></fc>"
                , "-L", "20"
                , "-H", "85"
                , "-l", "#dc322f"
                , "-n", "#b58900"
                , "-h", "#b58900"
                , "--" -- battery specific options
                -- discharging status
                , "-o"  , "<fn=1>\xf242</fn> <left>% (<timeleft>) <watts>"
                -- AC "on" status
                , "-O"  , "<fn=1>\xf1e6</fn> <left>%"
                -- charged status
                , "-i"  , "<fn=1>\xf1e6</fn> <left>%"
                , "--off-icon-pattern", "<fn=1>\xf1e6</fn>"
                , "--on-icon-pattern", "<fn=1>\xf1e6</fn>"
                ] 10
            , Run Date "<fc=#268bd2><fn=1>\xf073</fn> %a %_d %b %Y | d.%j w.%W</fc>   <fc=#2AA198><fn=1>ÔÄó</fn><fn=2> %H:%M:%S</fn></fc>" "date" 10
            ]
            , sepChar            = "%"
            , alignSep           = "}{"
            , template           = " %StdinReader% }{ %cpu%  %memory%  %wi%  %battery% | %date% "
    }

  #+end_src

** TODO XMonad from scratch -- day 7 -- Making yourself at home         :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-7
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

  Now that we have a decent window manager, it's time to settle in. To do so we'll add a bunch of keybindings, and start some applications at login.

  New module:

  - [[http://hackage.haskell.org/package/xmonad-contrib-bluetilebranch-0.9.1.4/docs/XMonad-Util-SpawnOnce.html][XMonad.Util.SpawnOnce]] -- A module for spawning a command once, and only once. Useful to start status bars and make session settings inside startupHook.

  #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Hooks.DynamicLog
    import XMonad.Hooks.ManageDocks
    import XMonad.Util.Run(spawnPipe)
    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import System.IO
    import XMonad.Layout.ShowWName
    import XMonad.Layout.Fullscreen
    import XMonad.Layout.Renamed
    import XMonad.Util.SpawnOnce

    ------------------------------------------------------------------------}}}
    -- General                                                              {{{
    ---------------------------------------------------------------------------

    myModMask                     = mod4Mask
    myTerminal = "alacritty"
    myBrowser  = "qutebrowser"

    wsWEB = "web"
    wsTXT = "txt"
    wsTRM = "term"
    wsSYS = "sys"
    wsCHT = "chat"
    wsFLT = "flot"
    wsMOV = "movies"
    wsTMP = "tmp"

    myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    ------------------------------------------------------------------------}}}
    -- Theme                                                                {{{
    ---------------------------------------------------------------------------

    myFocusFollowsMouse  = False
    myClickJustFocuses   = True

    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"

    -- sizes
    gap         = 10
    topbar      = 10
    border      = 2
    prompt      = 20
    status      = 20

    myNormalBorderColor     = "#000000"
    myFocusedBorderColor    = active

    active      = blue
    activeWarn  = red
    inactive    = base02
    focusColor  = blue
    unfocusColor = base02

    myFont      = "-*-terminus-medium-*-*-*-*-160-*-*-*-*-*-*"
    myBigFont   = "-*-terminus-medium-*-*-*-*-240-*-*-*-*-*-*"
    myLargeFont = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"

    -- Theme for showWName which prints current workspace when you change workspaces.
    myShowWNameTheme :: SWNConfig
    myShowWNameTheme = def
        { swn_font              = myLargeFont
        , swn_fade              = 1.0
        , swn_bgcolor           = "#000000"
        , swn_color             = "#FFFFFF"
        }

    ------------------------------------------------------------------------}}}
    -- Keys                                                                 {{{
    ---------------------------------------------------------------------------

    myKeys conf = let
        subKeys str ks        = subtitle str : mkNamedKeymap conf ks
        in

        subKeys "My Applications"
        [ ("M-h", addName "Htop"   $ spawn myTerminal)
        , ("M-b", addName "Browser"   $ spawn myBrowser)
        ] ^++^

        subKeys "My Emacs bindings"
        [("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
        ]



    ------------------------------------------------------------------------}}}
    -- Hooks & main                                                         {{{
    ---------------------------------------------------------------------------

    myLayouthook = avoidStruts $
                   showWName' myShowWNameTheme $
                   -- layoutHook defaultConfig
                   tall ||| wide ||| full
    tall   = renamed [Replace "tall"] $ Tall 1 0.03 0.5
    wide   = renamed [Replace "wide"] $ Mirror tall
    full   = renamed [Replace "full"] $ Full

    -- myStartupHook :: X ()
    myStartupHook = do
          spawnOnce "wallpaper"
          spawnOnce "picom &"
          spawnOnce "dunst &"
          spawnOnce "/usr/bin/emacs --daemon &"
          spawnOnce "unclutter --timeout 4 --jitter 10 --ignore-scrolling -b"

    main = do
        xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
        xmonad
            $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
            $ docks def
                { borderWidth        = border
                , clickJustFocuses   = myClickJustFocuses
                , focusFollowsMouse  = myFocusFollowsMouse
                , normalBorderColor  = myNormalBorderColor
                , focusedBorderColor = myFocusedBorderColor
                , layoutHook =  myLayouthook
                , startupHook        = myStartupHook
                , logHook  = dynamicLogWithPP xmobarPP
                    { ppOutput          = hPutStrLn xmproc
                    , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                    , ppTitle           = xmobarColor active "" . shorten 50
                    , ppVisible         = xmobarColor base0  "" . wrap "(" ")"
                    , ppUrgent          = xmobarColor red    "" . wrap " " " "
                    , ppHiddenNoWindows = const ""
                    , ppSep             = xmobarColor red myNormalBorderColor " : "
                    , ppWsSep           = " "
                    , ppLayout          = xmobarColor yellow ""
                    , ppOrder           = id
                    }
                , modMask    = mod4Mask
                , workspaces = myWorkspaces
                }
  #+end_src

** TODO XMonad from scratch -- day 8 -- Projects                        :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-8
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

  Time to get to work!

  New modules:

  - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-DynamicProjects.html][XMonad.Actions.DynamicProjects]] -- Imbues workspaces with additional features so they can be treated as individual project areas.
  - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Prompt.html][XMonad.Prompt]] -- A module for writing graphical prompts for XMonad
  - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-CycleWS.html][XMonad.Actions.CycleWS]] -- Provides bindings to cycle forward or backward through the list of workspaces, to move windows between workspaces, and to cycle between screens. More general combinators provide ways to cycle through workspaces in various orders, to only cycle through some subset of workspaces, and to cycle by more than one workspace at a time.

  #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Hooks.DynamicLog
    import XMonad.Hooks.ManageDocks
    import XMonad.Util.Run(spawnPipe)
    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import System.IO
    import XMonad.Layout.ShowWName
    import XMonad.Layout.Fullscreen
    import XMonad.Layout.Renamed
    import XMonad.Util.SpawnOnce

    import XMonad.Actions.DynamicProjects
    import XMonad.Prompt
    import XMonad.Actions.CycleWS

    ------------------------------------------------------------------------}}}
    -- General                                                              {{{
    ---------------------------------------------------------------------------

    myModMask                     = mod4Mask
    myTerminal = "alacritty"
    myBrowser  = "qutebrowser"

    wsWEB = "web"
    wsTXT = "txt"
    wsTRM = "term"
    wsSYS = "sys"
    wsCHT = "chat"
    wsFLT = "flot"
    wsMOV = "movies"
    wsTMP = "tmp"
    wsPythonP = "Python"
    wsXmonadP = "Xmonad"

    myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    ---------------------------------------------------------------------------
    -- Projects                                                              --
    ---------------------------------------------------------------------------

    projects :: [Project]
    projects =
        [ Project { projectName     = wsPythonP
            , projectDirectory  = "~/Projects/Python"
            , projectStartHook  = Just $ do spawnOnce (myTerminal ++ " --class pythonP")
                                            spawnOnce "pcmanfm ~/Video/Python"
            }
        , Project { projectName     = wsXmonadP
            , projectDirectory  = "~/Projects/Xmonad-from-scratch"
            , projectStartHook  = Just $ do spawnOnce "emacsclient -nc ~/Projects/Xmonad-from-scratch  -F '((name . \"xmonadP\"))'"
                                            spawnOnce (myTerminal ++ "--class xmonadP")
            }
        ]

    ------------------------------------------------------------------------}}}
    -- Theme                                                                {{{
    ---------------------------------------------------------------------------

    myFocusFollowsMouse  = False
    myClickJustFocuses   = True

    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"

    -- sizes
    gap         = 10
    topbar      = 10
    myBorder    = 2
    myPrompt    = 26
    status      = 20

    myNormalBorderColor     = "#000000"
    myFocusedBorderColor    = active

    active      = blue
    activeWarn  = red
    inactive    = base02
    focusColor  = blue
    unfocusColor = base02

    myFont      = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
    myBigFont   = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
    myLargeFont = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"

    -- Theme for showWName which prints current workspace when you change workspaces.
    myShowWNameTheme :: SWNConfig
    myShowWNameTheme = def
        { swn_font              = myLargeFont
        , swn_fade              = 1.0
        , swn_bgcolor           = "#000000"
        , swn_color             = "#FFFFFF"
        }

    myPromptTheme = def
        { font                  = myFont
        , bgColor               = base03
        , fgColor               = active
        , fgHLight              = base03
        , bgHLight              = active
        , borderColor           = base03
        , promptBorderWidth     = 0
        , height                = myPrompt
        , position              = Top
        }

    warmPromptTheme = myPromptTheme
        { bgColor               = yellow
        , fgColor               = base03
        , position              = Top
        }

    hotPromptTheme = myPromptTheme
        { bgColor               = red
        , fgColor               = base3
        , position              = Top
        }

    ------------------------------------------------------------------------}}}
    -- Keys                                                                 {{{
    ---------------------------------------------------------------------------

    myKeys conf = let
        subKeys str ks        = subtitle str : mkNamedKeymap conf ks
        in

        subKeys "My Applications"
        [ ("M-h", addName "Htop"   $ spawn myTerminal)
        , ("M-b", addName "Browser"   $ spawn myBrowser)
        ] ^++^

        subKeys "My Emacs bindings"
        [ ("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
        ] ^++^

        subKeys "Projects"
        [ ("M-w", addName "switch Project Prompt" $ switchProjectPrompt warmPromptTheme)
        , ("M-S-w", addName "shift To Project Prompt" $ shiftToProjectPrompt warmPromptTheme)
        , ("M-<Left>", addName "next workspace" $ prevWS)
        , ("M-<Right>", addName "previous workspace" $ nextWS)
        , ("M-z", addName "toggle last workspace" $ toggleWS)
        , ("M-S-<Left>", addName "XX next workspace" $ shiftToNext >> prevWS)
        , ("M-S-<Right>", addName "XX previous workspace" $ shiftToNext >> nextWS)
        ]

    ------------------------------------------------------------------------}}}
    -- Hooks & main                                                         {{{
    ---------------------------------------------------------------------------

    myLayouthook = avoidStruts $
                   showWName' myShowWNameTheme $
                   -- layoutHook defaultConfig
                   tall ||| wide ||| full
    tall   = renamed [Replace "tall"] $ Tall 1 0.03 0.5
    wide   = renamed [Replace "wide"] $ Mirror tall
    full   = renamed [Replace "full"] $ Full

    -- myStartupHook :: X ()
    myStartupHook = do
          spawnOnce "wallpaper"
          spawnOnce "picom &"
          spawnOnce "dunst &"
          spawnOnce "/usr/bin/emacs --daemon &"
          spawnOnce "unclutter --timeout 4 --jitter 10 --ignore-scrolling -b"

    main = do
        xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
        xmonad
            $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
            $ dynamicProjects projects
            $ docks def
                { borderWidth        = myBorder
                , clickJustFocuses   = myClickJustFocuses
                , focusFollowsMouse  = myFocusFollowsMouse
                , normalBorderColor  = myNormalBorderColor
                , focusedBorderColor = myFocusedBorderColor
                , layoutHook =  myLayouthook
                , startupHook        = myStartupHook
                , logHook  = dynamicLogWithPP xmobarPP
                    { ppOutput          = hPutStrLn xmproc
                    , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                    , ppTitle           = xmobarColor active "" . shorten 50
                    , ppVisible         = xmobarColor base0  "" . wrap "(" ")"
                    , ppUrgent          = xmobarColor red    "" . wrap " " " "
                    , ppHiddenNoWindows = const ""
                    , ppSep             = xmobarColor red myNormalBorderColor " : "
                    , ppWsSep           = " "
                    , ppLayout          = xmobarColor yellow ""
                    , ppOrder           = id
                    }
                , modMask    = mod4Mask
                , workspaces = myWorkspaces
                }
  #+end_src

** TODO XMonad from scratch -- day 9 -- Layouts - noborders --   Why gaps :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-9
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

  * TODO Layouts - noborders --   Why gaps, see schoonover video

  - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-NoBorders.html][XMonad.Layout.NoBorders]] -- Make a given layout display without borders. This is useful for full-screen or tabbed layouts, where you don't really want to waste a couple of pixels of real estate just to inform yourself that the visible window has focus.
  - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-Gaps.html][XMonad.Layout.Gaps]] -- Create manually-sized gaps along edges of the screen which will not be used for tiling, along with support for toggling gaps on and off.
  - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-Spacing.html][XMonad.Layout.Spacing]] -- Add a configurable amount of space around windows.

  #+begin_src haskell :tangle no
    import XMonad
    import XMonad.Hooks.DynamicLog
    import XMonad.Hooks.ManageDocks
    import XMonad.Util.Run(spawnPipe)
    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import System.IO
    import XMonad.Layout.ShowWName
    import XMonad.Layout.Fullscreen
    import XMonad.Layout.Renamed
    import XMonad.Util.SpawnOnce

    import XMonad.Actions.DynamicProjects
    import XMonad.Prompt
    import XMonad.Actions.CycleWS

    import XMonad.Layout.Gaps
    import XMonad.Layout.NoBorders
    import XMonad.Layout.Spacing

    ------------------------------------------------------------------------}}}
    -- General                                                              {{{
    ---------------------------------------------------------------------------

    myModMask                     = mod4Mask
    myTerminal = "alacritty"
    myBrowser  = "qutebrowser"

    wsWEB = "web"
    wsTXT = "txt"
    wsTRM = "term"
    wsSYS = "sys"
    wsCHT = "chat"
    wsFLT = "flot"
    wsMOV = "movies"
    wsTMP = "tmp"
    wsPythonP = "Python"
    wsXmonadP = "Xmonad"

    myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    ---------------------------------------------------------------------------
    -- Projects                                                              --
    ---------------------------------------------------------------------------

    projects :: [Project]
    projects =
        [ Project { projectName     = wsPythonP
            , projectDirectory  = "~/Projects/Python"
            , projectStartHook  = Just $ do spawnOnce (myTerminal ++ " --class pythonP")
                                            spawnOnce "pcmanfm ~/Video/Python"
            }
        , Project { projectName     = wsXmonadP
            , projectDirectory  = "~/Projects/Xmonad-from-scratch"
            , projectStartHook  = Just $ do spawnOnce "emacsclient -nc ~/Projects/Xmonad-from-scratch  -F '((name . \"xmonadP\"))'"
                                            spawnOnce (myTerminal ++ "--class xmonadP")
            }
        ]

    ------------------------------------------------------------------------}}}
    -- Theme                                                                {{{
    ---------------------------------------------------------------------------

    myFocusFollowsMouse  = False
    myClickJustFocuses   = True

    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"

    -- sizes
    gap         = 10
    topbar      = 10
    myBorder    = 2
    myPrompt    = 26
    status      = 20

    myNormalBorderColor     = "#000000"
    myFocusedBorderColor    = active

    active      = blue
    activeWarn  = red
    inactive    = base02
    focusColor  = blue
    unfocusColor = base02

    myFont      = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
    myBigFont   = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
    myLargeFont = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"

    -- Theme for showWName which prints current workspace when you change workspaces.
    myShowWNameTheme :: SWNConfig
    myShowWNameTheme = def
        { swn_font              = myLargeFont
        , swn_fade              = 1.0
        , swn_bgcolor           = "#000000"
        , swn_color             = "#FFFFFF"
        }

    myPromptTheme = def
        { font                  = myFont
        , bgColor               = base03
        , fgColor               = active
        , fgHLight              = base03
        , bgHLight              = active
        , borderColor           = base03
        , promptBorderWidth     = 0
        , height                = myPrompt
        , position              = Top
        }

    warmPromptTheme = myPromptTheme
        { bgColor               = yellow
        , fgColor               = base03
        , position              = Top
        }

    hotPromptTheme = myPromptTheme
        { bgColor               = red
        , fgColor               = base3
        , position              = Top
        }

    ------------------------------------------------------------------------}}}
    -- Keys                                                                 {{{
    ---------------------------------------------------------------------------

    myKeys conf = let
        subKeys str ks        = subtitle str : mkNamedKeymap conf ks
        in

        subKeys "My Applications"
        [ ("M-h", addName "Htop"   $ spawn myTerminal)
        , ("M-b", addName "Browser"   $ spawn myBrowser)
        ] ^++^

        subKeys "My Emacs bindings"
        [ ("M-x a", addName "Emacsclient"   $ spawn "emacsclient -nc")
        ] ^++^

        subKeys "Projects"
        [ ("M-w", addName "switch Project Prompt" $ switchProjectPrompt warmPromptTheme)
        , ("M-S-w", addName "shift To Project Prompt" $ shiftToProjectPrompt warmPromptTheme)
        , ("M-<Left>", addName "next workspace" $ prevWS)
        , ("M-<Right>", addName "previous workspace" $ nextWS)
        , ("M-z", addName "toggle last workspace" $ toggleWS)
        , ("M-S-<Left>", addName "XX next workspace" $ shiftToNext >> prevWS)
        , ("M-S-<Right>", addName "XX previous workspace" $ shiftToNext >> nextWS)
        ]

    ------------------------------------------------------------------------}}}
    -- Hooks & main                                                         {{{
    ---------------------------------------------------------------------------

    myLayouthook = avoidStruts
                 $ smartBorders
                 $ showWName' myShowWNameTheme
                 $ tall ||| wide ||| full
                 where
                     tall   = renamed [Replace "tall"] $ mySpacing $ Tall 1 0.03 0.5
                     wide   = renamed [Replace "wide"] $ mySpacing $ Mirror tall
                     full   = renamed [Replace "full"] $ Full

                     mySpacing           = smartSpacing gap

    -- myStartupHook :: X ()
    myStartupHook = do
          spawnOnce "wallpaper"
          spawnOnce "picom &"
          spawnOnce "dunst &"
          spawnOnce "/usr/bin/emacs --daemon &"
          spawnOnce "unclutter --timeout 4 --jitter 10 --ignore-scrolling -b"

    main = do
        xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
        xmonad
            $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
            $ dynamicProjects projects
            $ docks def
                { borderWidth        = myBorder
                , clickJustFocuses   = myClickJustFocuses
                , focusFollowsMouse  = myFocusFollowsMouse
                , normalBorderColor  = myNormalBorderColor
                , focusedBorderColor = myFocusedBorderColor
                , layoutHook =  myLayouthook
                , startupHook        = myStartupHook
                , logHook  = dynamicLogWithPP xmobarPP
                    { ppOutput          = hPutStrLn xmproc
                    , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                    , ppTitle           = xmobarColor active "" . shorten 50
                    , ppVisible         = xmobarColor base0  "" . wrap "(" ")"
                    , ppUrgent          = xmobarColor red    "" . wrap " " " "
                    , ppHiddenNoWindows = const ""
                    , ppSep             = xmobarColor red myNormalBorderColor " : "
                    , ppWsSep           = " "
                    , ppLayout          = xmobarColor yellow ""
                    , ppOrder           = id
                    }
                , modMask    = mod4Mask
                , workspaces = myWorkspaces
                }
  #+end_src

** TODO XMonad from scratch -- day 10 -- keybindings, for realz         :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-10
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   * Setting up my keybindings, for realz                                  :export:

  After accidently closing everything instead of a stupid zoom-popup:

   New modules:

   - [[http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Prompt-ConfirmPrompt.html][XMonad.Prompt.ConfirmPrompt]] -- Prompt the user to confirm a given action. We offer no completion and simply ask to confirm (ENTER) or cancel (ESCAPE).
   - System.Exit

*** Imports

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      import XMonad
      import System.IO
      import System.Exit -- exitWith

      import XMonad.Actions.DynamicProjects
      import XMonad.Actions.CycleWS

      import XMonad.Hooks.DynamicLog
      import XMonad.Hooks.ManageDocks
      import XMonad.Hooks.EwmhDesktops -- for some fullscreen events, also for xcomposite in obs.

      import XMonad.Layout.Gaps
      import XMonad.Layout.NoBorders
      import XMonad.Layout.Spacing
      import XMonad.Layout.ShowWName
      import XMonad.Layout.Fullscreen
      import XMonad.Layout.Renamed

      import XMonad.Prompt
      import XMonad.Prompt.ConfirmPrompt

      import XMonad.Util.Run(spawnPipe)
      import XMonad.Util.EZConfig
      import XMonad.Util.NamedActions
      import XMonad.Util.SpawnOnce
    #+end_src

*** General

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- General                                                              ---
      ---------------------------------------------------------------------------

      myModMask                     = mod4Mask
      myTerminal = "alacritty"
      myBrowser  = "qutebrowser"

      wsWEB = "web"
      wsTXT = "txt"
      wsTRM = "term"
      wsSYS = "sys"
      wsCHT = "chat"
      wsFLT = "flot"
      wsMOV = "movies"
      wsTMP = "tmp"
      wsPythonP = "Python"
      wsXmonadP = "Xmonad"

      myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    #+end_src

*** Projects
    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Projects                                                              --
      ---------------------------------------------------------------------------

      projects :: [Project]
      projects =
          [ Project { projectName     = wsPythonP
              , projectDirectory  = "~/Projects/Python"
              , projectStartHook  = Just $ do spawnOnce (myTerminal ++ " --class pythonP")
                                              spawnOnce "pcmanfm ~/Video/Python"
              }
          , Project { projectName     = wsXmonadP
              , projectDirectory  = "~/Projects/Xmonad-from-scratch"
              , projectStartHook  = Just $ do spawnOnce "emacsclient -nc ~/Projects/Xmonad-from-scratch  -F '((name . \"xmonadP\"))'"
                                              spawnOnce (myTerminal ++ "--class xmonadP")
              }
          ]

    #+end_src

*** Theme
    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Theme                                                                ---
      ---------------------------------------------------------------------------

      myFocusFollowsMouse  = False
      myClickJustFocuses   = True

      base03  = "#002b36"
      base02  = "#073642"
      base01  = "#586e75"
      base00  = "#657b83"
      base0   = "#839496"
      base1   = "#93a1a1"
      base2   = "#eee8d5"
      base3   = "#fdf6e3"
      yellow  = "#b58900"
      orange  = "#cb4b16"
      red     = "#dc322f"
      magenta = "#d33682"
      violet  = "#6c71c4"
      blue    = "#268bd2"
      cyan    = "#2aa198"
      green   = "#859900"

      -- sizes
      gap         = 10
      topbar      = 10
      myBorder    = 2
      myPrompt    = 26
      status      = 20

      myNormalBorderColor     = "#000000"
      myFocusedBorderColor    = active

      active      = blue
      activeWarn  = red
      inactive    = base02
      focusColor  = blue
      unfocusColor = base02

      myFont      = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
      myBigFont   = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
      myLargeFont = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"

      -- Theme for showWName which prints current workspace when you change workspaces.
      myShowWNameTheme :: SWNConfig
      myShowWNameTheme = def
          { swn_font              = myLargeFont
          , swn_fade              = 1.0
          , swn_bgcolor           = "#000000"
          , swn_color             = "#FFFFFF"
          }

      myPromptTheme = def
          { font                  = myFont
          , bgColor               = base03
          , fgColor               = active
          , fgHLight              = base03
          , bgHLight              = active
          , borderColor           = base03
          , promptBorderWidth     = 0
          , height                = myPrompt
          , position              = Top
          }

      warmPromptTheme = myPromptTheme
          { bgColor               = yellow
          , fgColor               = base03
          , position              = Top
          }

      hotPromptTheme = myPromptTheme
          { bgColor               = red
          , fgColor               = base3
          , position              = Top
          }
    #+end_src

*** TODO Keys -  instead of libnotify use flashtext

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Keys                                                                 ---
      ---------------------------------------------------------------------------

      myKeys conf = let
          subKeys str ks        = subtitle str : mkNamedKeymap conf ks
          in

          subKeys "Xmonad"
          [ ("M-q", addName "Restart XMonad"                  $ confirmPrompt hotPromptTheme "Restart XMonad" $ restartXmonad)
          , ("M-C-q", addName "Rebuild & restart XMonad"        $ confirmPrompt hotPromptTheme "Recompile and Restart XMonad" $ reburesXmonad)
          , ("M-C-r", addName "Rebuild & restart XMonad"        $ confirmPrompt hotPromptTheme "Recompile and Restart XMonad" $ rebuildXmonad)
          , ("M-S-q", addName "Quit XMonad"                     $ confirmPrompt hotPromptTheme "Quit XMonad" $ io (exitWith ExitSuccess))
          ] ^++^

          subKeys "Multi Media"
          [ ("<XF86PowerOff>"         , addName "Power off"                  $ confirmPrompt hotPromptTheme "Shutdown Linux" $ spawn "shutdown -h now")
          , ("<XF86MonBrightnessUp>"  , addName "Up brightness"             $ spawn "sudo light -A 10  & notify-send  \"Bright Up\"")
          , ("<XF86MonBrightnessDown>", addName "Down brightness"           $ spawn "sudo light -U 10  & notify-send  \"Bright Down\"")
          , ("<XF86AudioRaiseVolume>" , addName "Up audio"                  $ spawn "amixer set Master 5%+ unmute & notify-send  \"Audio Up\" $(pamixer --get-volume-human)")
          , ("<XF86AudioLowerVolume>" , addName "Down audio"                $ spawn "amixer set Master 5%- unmute & notify-send  \"Audio Down\" $(pamixer --get-volume-human)")
          , ("<XF86AudioMute>"        , addName "MUTE audio"                $ spawn "amixer set Master toggle")
          , ("M-<XF86Display>"        , addName "Display - force internal"  $ spawn "displayctl internal")
          , ("<XF86ScreenSaver>"      , addName "Lock screen"               $ spawn "alacritty")
          , ("<XF86TouchpadToggle>"   , addName "Toggle touchpad"           $ spawn "alacritty")
          ] ^++^

          subKeys "My Applications"
          [ ("M-h", addName "Htop"   $ spawn myTerminal)
          , ("M-b", addName "Browser"   $ spawn myBrowser)
          , ("M-a", addName "Volume control"   $ spawn "pavucontrol")
          ] ^++^

          subKeys "My Emacs bindings"
          [ ("M-e e", addName "Emacsclient"   $ spawn "emacsclient -nc")
          ] ^++^

          subKeys "Projects"
          [ ("M-w", addName "switch Project Prompt" $ switchProjectPrompt warmPromptTheme)
          , ("M-S-w", addName "shift To Project Prompt" $ shiftToProjectPrompt warmPromptTheme)
          , ("M-<Left>", addName "next workspace" $ prevWS)
          , ("M-<Right>", addName "previous workspace" $ nextWS)
          , ("M-z", addName "toggle last workspace" $ toggleWS)
          , ("M-S-<Left>", addName "XX next workspace" $ shiftToNext >> prevWS)
          , ("M-S-<Right>", addName "XX previous workspace" $ shiftToNext >> nextWS)
          ]
    #+end_src

*** Hooks and main

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Hooks & main                                                         ---
      ---------------------------------------------------------------------------

      myLayouthook = avoidStruts
                   $ smartBorders
                   $ showWName' myShowWNameTheme
                   $ tall ||| wide ||| full
                   where
                       tall   = renamed [Replace "tall"] $ mySpacing $ Tall 1 0.03 0.5
                       wide   = renamed [Replace "wide"] $ mySpacing $ Mirror tall
                       full   = renamed [Replace "full"] $ Full

                       mySpacing           = smartSpacing gap

      -- myStartupHook :: X ()
      myStartupHook = do
            spawnOnce "wallpaper"
            spawnOnce "picom &"
            spawnOnce "dunst &"
            spawnOnce "/usr/bin/emacs --daemon &"
            spawnOnce "unclutter --timeout 4 --jitter 10 --ignore-scrolling -b"

      main = do
          xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
          xmonad
              $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
              $ dynamicProjects projects
              $ docks def
                  { borderWidth        = myBorder
                  , clickJustFocuses   = myClickJustFocuses
                  , focusFollowsMouse  = myFocusFollowsMouse
                  , normalBorderColor  = myNormalBorderColor
                  , focusedBorderColor = myFocusedBorderColor
                  , layoutHook =  myLayouthook
                  , startupHook        = myStartupHook
                  , logHook  = dynamicLogWithPP xmobarPP
                      { ppOutput          = hPutStrLn xmproc
                      , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                      , ppTitle           = xmobarColor active "" . shorten 50
                      , ppVisible         = xmobarColor base0  "" . wrap "(" ")"
                      , ppUrgent          = xmobarColor red    "" . wrap " " " "
                      , ppHiddenNoWindows = const ""
                      , ppSep             = xmobarColor red myNormalBorderColor " : "
                      , ppWsSep           = " "
                      , ppLayout          = xmobarColor yellow ""
                      , ppOrder           = id
                      }
                  , modMask    = mod4Mask
                  , workspaces = myWorkspaces
                  }
    #+end_src

*** TODO Misc functions

    Source: ???

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      quitXmonad :: X ()
      quitXmonad = io (exitWith ExitSuccess)

      reburesXmonad :: X ()
      reburesXmonad = do
          spawn "xmonad --recompile && xmonad --restart"

      rebuildXmonad :: X ()
      rebuildXmonad = do
          spawn "xmonad --recompile"

      restartXmonad :: X ()
      restartXmonad = do
          spawn "xmonad --restart"

    #+end_src

** TODO XMonad from scratch -- day 11 -- Managing Windows aka Manage Hooks :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-11-manage-hooks
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   Managing Windows aka Manage Hooks                                    :export:

*** TODO Manage windows

    #+BEGIN_SRC emacs-lisp -n
      (defun org-xor (a b)
        "Eadasxclusive or. "
        (if a (not b) b))ss
    #+END_SRC

    After accidently closing Xmonad instead of a stupid zoom-popup:

    New modules:

    - [[http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Prompt-ConfirmPrompt.html][XMonad.Prompt.ConfirmPrompt]] -- Prompt the user to confirm a given action. We offer no completion and simply ask to confirm (ENTER) or cancel (ESCAPE).
    - System.Exit


    Some windows just are not a part of your regular workflow, take /pavucontrol/, it's meant to control your audio, and then it's closed again. No need to keep it around, give it a place. That's the kind of window you typecally want to /float/.

    Then there are the popup windows, annoying, but they exist. They should not take up real-estate, move around your carefully grafted grid. For this we use the XXX module.

    New modules:

    - [[https://hackage.haskell.org/package/xmonad-0.15/docs/XMonad-StackSet.html#t:StackSet][XMonad.StackSet]]
    - [[http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-ManageHelpers.html][XMonad.Hooks.ManageHelpers]] - This module provides helper functions to be used in manageHook. For one it has the function =isDialog=, which you can use to match dialogs, =OBS= has a gazillion of them, so having a catch-all makes things a /lot/ easier.

      We added [[(mhelpimport)][import]]

*** TODO EWMH rewrite

    [[https://en.wikipedia.org/wiki/Extended_Window_Manager_Hints][EWMH]] might not sound very interesting, but X11 has some great utilities that use /Extended Window Manager Hints/.

    Two examples are =Wmctrl= and =xdotool=, great time-savers that can be used in scripts to glue things together.

    Module: [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-EwmhDesktops.html][XMonad.Hooks.EwmhDesktops]] - Makes xmonad use the EWMH hints to tell panel applications about its workspaces and the windows therein. It also allows the user to interact with xmonad by clicking on panels and window lists.

    To use it, [[(ewmhimport)][import]] it, and then [[(ewmh)][activate]] it. ???activate

*** Imports

    #+begin_src haskell +n :tangle "~/.xmonad/xmonad.hs"
      import XMonad
      import System.IO
      import System.Exit -- exitWith
      import qualified XMonad.StackSet as W

      import XMonad.Actions.DynamicProjects
      import XMonad.Actions.CycleWS

      import XMonad.Hooks.DynamicLog
      import XMonad.Hooks.ManageDocks
      import XMonad.Hooks.EwmhDesktops -- for some fullscreen events, also for xcomposite in obs. (ref:ewmhimport)
      import XMonad.Hooks.ManageHelpers                                                         --(ref:mhelpimport)

      import XMonad.Layout.Gaps
      import XMonad.Layout.NoBorders
      import XMonad.Layout.Spacing
      import XMonad.Layout.ShowWName
      import XMonad.Layout.Fullscreen
      import XMonad.Layout.Renamed

      import XMonad.Prompt
      import XMonad.Prompt.ConfirmPrompt

      import XMonad.Util.Run(spawnPipe)
      import XMonad.Util.EZConfig
      import XMonad.Util.NamedActions
      import XMonad.Util.SpawnOnce
    #+end_src

*** General

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- General                                                              ---
      ---------------------------------------------------------------------------

      myModMask     = mod4Mask
      myTerminal    = "alacritty"
      myBrowser     = "qutebrowser"
      myMusicPlayer = myTerminal ++ " --class mymusic -e ncmpcpp"
      myIrc         = myTerminal ++ " --class myirc   -e tmux new-session -A -s irc \"weechat\""
      myNews        = "mynewsboat" --script, there can only be one newsboat
      myTop         = myTerminal ++ " --class mytop   -e htop"

      wsWEB     = "web"
      wsTXT     = "txt"
      wsTRM     = "term"
      wsSYS     = "sys"
      wsCHT     = "chat"
      wsFLT     = "flot"
      wsMOV     = "movies"
      wsTMP     = "tmp"
      wsPythonP = "Python"
      wsXmonadP = "Xmonad"
      wsKBorgP  = "KBorg"

      myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    #+end_src

*** Projects
    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Projects                                                              --
      ---------------------------------------------------------------------------
      -- Use either a string as project name, or a variable declared under 'workspaces'

      projects :: [Project]
      projects =
          [ Project { projectName     = wsPythonP
              , projectDirectory  = "~/Projects/Python"
              , projectStartHook  = Just $ do spawnOnce (myTerminal ++ " --class pythonP")
                                              spawnOnce "pcmanfm ~/Video/Python"
              }
          , Project { projectName     = wsXmonadP
              , projectDirectory  = "~/Projects/Xmonad-from-scratch"
              , projectStartHook  = Just $ do spawnOnce "emacsclient -nc ~/Projects/Xmonad-from-scratch  -F '((name . \"xmonadP\"))'"
                                              spawnOnce (myTerminal ++ " --class xmonadP")
              }
          , Project { projectName     = wsKBorgP
              , projectDirectory  = "~/Documents/KBorg"
              , projectStartHook  = Just $ do spawnOnce "emacsclient -nc ~/Documents/KBorg  -F '((name . \"kborgP\"))'"
                                              spawnOnce (myTerminal ++ " --class kborgP")
              }
          ]

    #+end_src

*** Theme
    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Theme                                                                ---
      ---------------------------------------------------------------------------

      myFocusFollowsMouse  = False
      myClickJustFocuses   = True

      base03  = "#002b36"
      base02  = "#073642"
      base01  = "#586e75"
      base00  = "#657b83"
      base0   = "#839496"
      base1   = "#93a1a1"
      base2   = "#eee8d5"
      base3   = "#fdf6e3"
      yellow  = "#b58900"
      orange  = "#cb4b16"
      red     = "#dc322f"
      magenta = "#d33682"
      violet  = "#6c71c4"
      blue    = "#268bd2"
      cyan    = "#2aa198"
      green   = "#859900"

      -- sizes
      gap         = 10
      topbar      = 10
      myBorder    = 2
      myPrompt    = 26
      status      = 20

      myNormalBorderColor     = "#000000"
      myFocusedBorderColor    = active

      active      = blue
      activeWarn  = red
      inactive    = base02
      focusColor  = blue
      unfocusColor = base02

      myFont      = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
      myBigFont   = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
      myLargeFont = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"

      -- Theme for showWName which prints current workspace when you change workspaces.
      myShowWNameTheme :: SWNConfig
      myShowWNameTheme = def
          { swn_font              = myLargeFont
          , swn_fade              = 1.0
          , swn_bgcolor           = "#000000"
          , swn_color             = "#FFFFFF"
          }

      myPromptTheme = def
          { font                  = myFont
          , bgColor               = base03
          , fgColor               = active
          , fgHLight              = base03
          , bgHLight              = active
          , borderColor           = base03
          , promptBorderWidth     = 0
          , height                = myPrompt
          , position              = Top
          }

      warmPromptTheme = myPromptTheme
          { bgColor               = yellow
          , fgColor               = base03
          , position              = Top
          }

      hotPromptTheme = myPromptTheme
          { bgColor               = red
          , fgColor               = base3
          , position              = Top
          }
    #+end_src

*** Keys

    General Xmonad key-bindings:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Keys                                                                 ---
      ---------------------------------------------------------------------------

      myKeys conf = let
          subKeys str ks        = subtitle str : mkNamedKeymap conf ks
          in

          subKeys "Xmonad"
          [ ("M-q", addName "Restart XMonad"               $ confirmPrompt hotPromptTheme "Restart XMonad" $ restartXmonad)
          , ("M-C-q", addName "Rebuild & restart XMonad"   $ confirmPrompt hotPromptTheme "Recompile and Restart XMonad" $ reburesXmonad)
          , ("M-C-r", addName "Rebuild & restart XMonad"   $ confirmPrompt hotPromptTheme "Recompile and Restart XMonad" $ rebuildXmonad)
          , ("M-S-q", addName "Quit XMonad"                $ confirmPrompt hotPromptTheme "Quit XMonad" $ io (exitWith ExitSuccess))
          ] ^++^
    #+end_src

    Multi-media key-bindings:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"

      subKeys "Multi Media"
      [ ("<XF86PowerOff>"         , addName "Power off"                 $ confirmPrompt hotPromptTheme "Shutdown Linux" $ spawn "shutdown -h now")
      , ("<XF86MonBrightnessUp>"  , addName "Up brightness"             $ spawn "sudo light -A 10  & notify-send  \"Bright Up\"")
      , ("<XF86MonBrightnessDown>", addName "Down brightness"           $ spawn "sudo light -U 10  & notify-send  \"Bright Down\"")
      , ("<XF86AudioRaiseVolume>" , addName "Up audio"                  $ spawn "amixer set Master 5%+ unmute & notify-send  \"Audio Up\" $(pamixer --get-volume-human)")
      , ("<XF86AudioLowerVolume>" , addName "Down audio"                $ spawn "amixer set Master 5%- unmute & notify-send  \"Audio Down\" $(pamixer --get-volume-human)")
      , ("<XF86AudioMute>"        , addName "MUTE audio"                $ spawn "amixer set Master toggle")
      , ("M-<XF86Display>"        , addName "Display - force internal"  $ spawn "displayctl internal")
      , ("<XF86ScreenSaver>"      , addName "Lock screen"               $ spawn "alacritty")
      , ("<XF86TouchpadToggle>"   , addName "Toggle touchpad"           $ spawn "alacritty")
      , ("M-m p"                  , addName "Play music"                $ spawn "mpc play")
      , ("M-m ,"                  , addName "Play next"                 $ spawn "mpc next")
      , ("M-m ."                  , addName "Play previous"             $ spawn "mpc prev")
      , ("M-m <Space>"            , addName "Toggle play"               $ spawn "mpc toggle")
      , ("M-m /"                  , addName "Music player"              $ spawn myMusicPlayer)
      ] ^++^
    #+end_src

    Applications key-bindings:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"

      subKeys "My Applications"
      [ ("M-<Return>"             , addName "Terminal"          $ spawn myTerminal)
      , ("M-b"                    , addName "Browser"           $ spawn myBrowser)
      , ("M-a"                    , addName "Volume control"    $ spawn "pavucontrol")
      , ("M-x i"                  , addName "Weechat"           $ spawn myIrc)
      , ("M-x n"                  , addName "Newsboat"          $ spawn myNews)
      , ("M-x h"                  , addName "Htop"              $ spawn myTop)
      ] ^++^

      subKeys "My Emacs bindings"
      [ ("M-e e"                  , addName "Emacsclient"       $ spawn "emacsclient -nc")
      ] ^++^

      subKeys "Window actions"
      [ ("M-S <Return>"           , addName "Swap current window to master"   $ windows W.swapMaster)
      ] ^++^
    #+end_src

    Actions key-bindings:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs" :tangle no

      -- subKeys "Actions"
      -- [ ("M-a"                       , addName "Notify w current X selection"    $ unsafeWithSelection "notify-send")

      -- , ("M-M1-/"                    , addName "On-screen keys (on/off) "        $ spawn "killall screenkey &>/dev/null || screenkey --no-systray")
      -- , ("M-M1-S-/"                  , addName "On-screen keys settings"         $ spawn "screenkey --show-settings")
      -- , ("M-M1-s"                    , addName "Capture screen"                  $ spawn "screenshot" )
      -- , ("M-M1-S-s"                  , addName "Capture screen - area select"    $ spawn "screenshot area" )
      -- , ("M-M1-r"                    , addName "Record screen"                   $ spawn "screencast" )
      -- , ("M-M1-S-r"                  , addName "Record screen - area select"     $ spawn "screencast area" )
      -- ] ^++^
    #+end_src

    Project key-bindings:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"

      subKeys "Projects"
      [ ("M-w", addName "switch Project Prompt" $ switchProjectPrompt warmPromptTheme)
      , ("M-S-w", addName "shift To Project Prompt" $ shiftToProjectPrompt warmPromptTheme)
      ]
    #+end_src

    Workspace key-bindings:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"

      subKeys "Workspaces"
      [ ("M-<Left>", addName "next workspace" $ prevWS)
      , ("M-<Right>", addName "previous workspace" $ nextWS)
      , ("M-z", addName "toggle last workspace" $ toggleWS)
      , ("M-S-<Left>", addName "XX next workspace" $ shiftToNext >> prevWS)
      , ("M-S-<Right>", addName "XX previous workspace" $ shiftToNext >> nextWS)
      ]
    #+end_src

*** TODO Hooks and main

    xprop
    classname wont work without Pavu
    resource wont work with Pavu

    Notice possible unite several rules into one [[(manage)][here]]

    #+begin_src haskell -n  :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Hooks & main                                                         ---
      ---------------------------------------------------------------------------

      myManageHook :: ManageHook
      myManageHook = composeAll . concat $
          [ [ className  =? c                     --> doFloat | c <- myFun]
          , [ resource   =? "gsimplecal"          --> doFloatAt' (1554/1920) (30/1040) ]
          , [ resource   =? "myFloat"             --> forceCenterFloat]
          --, [ resource =? "pavucontrol"         --> largeFloat]                                      (ref:manage)
          --, [ resource =? "myMusic"             --> largeFloat]
          , [ resource   =? c                     --> largeFloat | c <- floatApps ]
          , [ className  =? c                     --> doShift ( myWorkspaces !! 0 )| c <- myBrowsers ]
          , [ (className =? "obs" <&&> title =? "Scripts" ) --> largeFloat ]
          , [ (className =? "obs" <&&> isDialog ) --> largeFloat ]
          , [ (title     =? "emacs-capture" )     --> smallFloat ]
          ]
          where
              floatApps  = ["pavucontrol", "myMusic"]
              myBrowsers = ["chromium", "Firefox"]
              myFun      = ["Gimp"]
              obsFloats  = [ "Scripts"]
              doMaster = doF W.shiftMaster --append this to all floats so new windows always go on top, regardless of the current focus
              doFloatAt' x y = doFloatAt x y <+> doMaster

      myLayouthook = avoidStruts
                   $ smartBorders
                   $ showWName' myShowWNameTheme
                   $ tall ||| wide ||| full
                   where
                       tall   = renamed [Replace "tall"] $ mySpacing $ Tall 1 0.03 0.5
                       wide   = renamed [Replace "wide"] $ mySpacing $ Mirror tall
                       full   = renamed [Replace "full"] $ Full

                       mySpacing           = smartSpacing gap

      -- myStartupHook :: X ()
      myStartupHook = do
            spawnOnce "wallpaper"
            spawnOnce "picom &"
            spawnOnce "dunst &"
            spawnOnce "/usr/bin/emacs --daemon &"
            spawnOnce "unclutter --timeout 4 --jitter 10 --ignore-scrolling -b"

      main = do
          xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
          xmonad
              $ addDescrKeys ((mod4Mask, xK_F1), xMessage) myKeys
              $ dynamicProjects projects
              $ ewmh                                                                      -- (ref:ewmh)
              $ docks def
                  { borderWidth        = myBorder
                  , clickJustFocuses   = myClickJustFocuses
                  , focusFollowsMouse  = myFocusFollowsMouse
                  , normalBorderColor  = myNormalBorderColor
                  , focusedBorderColor = myFocusedBorderColor
                  , layoutHook         = myLayouthook
                  , manageHook         = myManageHook
                  , startupHook        = myStartupHook
                  , logHook  = dynamicLogWithPP xmobarPP
                      { ppOutput          = hPutStrLn xmproc
                      , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                      , ppTitle           = xmobarColor active "" . shorten 50
                      , ppVisible         = xmobarColor base0  "" . wrap "(" ")"
                      , ppUrgent          = xmobarColor red    "" . wrap " " " "
                      , ppHiddenNoWindows = const ""
                      , ppSep             = xmobarColor red myNormalBorderColor " : "
                      , ppWsSep           = " "
                      , ppLayout          = xmobarColor yellow ""
                      , ppOrder           = id
                      }
                  , modMask    = mod4Mask
                  , workspaces = myWorkspaces
                  }
    #+end_src

*** Misc functions

    Source: [[https://github.com/altercation/dotfiles-tilingwm/blob/master/.xmonad/xmonad.hs][Ethan Schoonover's xmonad.hs]]

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      quitXmonad :: X ()
      quitXmonad = io (exitWith ExitSuccess)

      reburesXmonad :: X ()
      reburesXmonad = do
          spawn "xmonad --recompile && xmonad --restart"

      rebuildXmonad :: X ()
      rebuildXmonad = do
          spawn "xmonad --recompile"

      restartXmonad :: X ()
      restartXmonad = do
          spawn "xmonad --restart"

    #+end_src

    Custom hook helpers

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Custom hook helpers
      ---------------------------------------------------------------------------

      -- from:
      -- https://github.com/pjones/xmonadrc/blob/master/src/XMonad/Local/Action.hs
      --
      -- Useful when a floating window requests stupid dimensions.

      forceCenterFloat :: ManageHook
      forceCenterFloat = doFloatDep move
        where
          move :: W.RationalRect -> W.RationalRect
          move _ = W.RationalRect x y w h
          w, h, x, y :: Rational
          w = 2/3
          h = 2/3
          x = (1-w)/2
          y = (1-h)/2

      largeFloat :: ManageHook
      largeFloat = doFloatDep move
        where
          move :: W.RationalRect -> W.RationalRect
          move _ = W.RationalRect x y w h
          w, h, x, y :: Rational
          w = 3/4
          h = 3/4
          x = (1-w)/2
          y = (1-h)/2

      smallFloat :: ManageHook
      smallFloat = doFloatDep move
        where
          move :: W.RationalRect -> W.RationalRect
          move _ = W.RationalRect x y w h
          w, h, x, y :: Rational
          w = 2/3
          h = 1/4
          x = (1-w)/2
          y = (1-h)/2

    #+end_src

** TODO XMonad from scratch -- day 12 -- Prompts                        :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-12-prompts
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:


   Using prompts for recurring actions

   Add more

   Many things we keep doing over and over:

   - searching online with a search engine
   - looking up someting on the Arch wiki

   Xmonad has a prompt module, let's add some more functionality to it:


*** TODO Manage windows

    #+BEGIN_SRC emacs-lisp -n
      (defun org-xor (a b)
        "Eadasxclusive or. "
        (if a (not b) b))ss
    #+END_SRC

    After accidently closing Xmonad instead of a stupid zoom-popup:

    New modules:

    - [[http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Prompt-ConfirmPrompt.html][XMonad.Prompt.ConfirmPrompt]] -- Prompt the user to confirm a given action. We offer no completion and simply ask to confirm (ENTER) or cancel (ESCAPE).
    - System.Exit


    Some windows just are not a part of your regular workflow, take /pavucontrol/, it's meant to control your audio, and then it's closed again. No need to keep it around, give it a place. That's the kind of window you typecally want to /float/.

    Then there are the popup windows, annoying, but they exist. They should not take up real-estate, move around your carefully grafted grid. For this we use the XXX module.

    New modules:

    - [[https://hackage.haskell.org/package/xmonad-0.15/docs/XMonad-StackSet.html#t:StackSet][XMonad.StackSet]]
    - [[http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-ManageHelpers.html][XMonad.Hooks.ManageHelpers]] - This module provides helper functions to be used in manageHook. For one it has the function =isDialog=, which you can use to match dialogs, =OBS= has a gazillion of them, so having a catch-all makes things a /lot/ easier.

      We added import

*** TODO EWMH rewrite

    [[https://en.wikipedia.org/wiki/Extended_Window_Manager_Hints][EWMH]] might not sound very interesting, but X11 has some great utilities that use /Extended Window Manager Hints/.

    Two examples are =Wmctrl= and =xdotool=, great time-savers that can be used in scripts to glue things together.

    Module: [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-EwmhDesktops.html][XMonad.Hooks.EwmhDesktops]] - Makes xmonad use the EWMH hints to tell panel applications about its workspaces and the windows therein. It also allows the user to interact with xmonad by clicking on panels and window lists.

    To use it, import it, and then activate it. ???activate

*** Imports

    #+begin_src haskell +n :tangle "~/.xmonad/xmonad.hs"
      import XMonad
      import System.IO
      import System.Exit -- exitWith
      import qualified XMonad.StackSet as W

      import Data.Char (isSpace, toUpper)
      import qualified Data.Map as M

      import XMonad.Actions.DynamicProjects
      import XMonad.Actions.CycleWS
      import qualified XMonad.Actions.Search as S                                    -- (ref:searchM)
      import qualified XMonad.Actions.Submap as SM
      import XMonad.Actions.ShowText                                                 -- (ref:showM)

      import XMonad.Hooks.DynamicLog
      import XMonad.Hooks.ManageDocks
      import XMonad.Hooks.EwmhDesktops -- for some fullscreen events, also for xcomposite in obs. (ref:ewmM)
      import XMonad.Hooks.ManageHelpers                                              --(ref:mhelpM)

      --layouts

      import XMonad.Layout.GridVariants (Grid(Grid))                                 -- (ref:gridM)
      import XMonad.Layout.SimplestFloat
      import XMonad.Layout.ResizableTile                                             -- (ref:resizeM)
      import XMonad.Layout.Tabbed                                                    -- (ref:tabM)
      --variants

      import XMonad.Layout.Gaps
      import XMonad.Layout.NoBorders
      import XMonad.Layout.Spacing
      import XMonad.Layout.ShowWName
      -- import XMonad.Layout.Fullscreen                                                -- (ref:fsM)
      import XMonad.Layout.Renamed
      import XMonad.Layout.Magnifier                                                 -- (ref:magnifyM)
      import XMonad.Layout.WindowNavigation                                          -- (ref:windownavM)
      import XMonad.Layout.LimitWindows (limitWindows, increaseLimit, decreaseLimit) -- (ref:limitwinM)
      import XMonad.Layout.Simplest

      import XMonad.Prompt
      import XMonad.Prompt.ConfirmPrompt
      import XMonad.Prompt.FuzzyMatch                                                -- (ref:fuzzymatch) TODO
      import XMonad.Prompt.Man

      import XMonad.Util.Run(spawnPipe)
      import XMonad.Util.EZConfig
      import XMonad.Util.NamedActions
      import XMonad.Util.SpawnOnce
    #+end_src

*** General

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- General                                                              ---
      ---------------------------------------------------------------------------

      myModMask     = mod4Mask
      myTerminal    = "alacritty"
      myBrowser     = "qutebrowser"
      myMusicPlayer = myTerminal ++ " --class mymusic -e ncmpcpp"
      myIrc         = myTerminal ++ " --class myirc   -e tmux new-session -A -s irc \"weechat\""
      myNews        = "mynewsboat" --script, there can only be one newsboat
      myTop         = myTerminal ++ " --class mytop   -e htop"
      myFilemanager = "pcmanfm --name myFloat"
      myFastmanager = myTerminal ++ " -e lf"

      getvol        = "awk -F\"[][]\" '/Left:/ { print $2 }' <(amixer sget Master)"


      wsWEB     = "web"
      wsTXT     = "txt"
      wsTRM     = "term"
      wsSYS     = "sys"
      wsCHT     = "chat"
      wsFLT     = "flot"
      wsMOV     = "movies"
      wsTMP     = "tmp"
      wsPythonP = "Python"
      wsXmonadP = "Xmonad"
      wsKBorgP  = "KBorg"
      wsHaskell = "haskell"

      myWorkspaces = [wsWEB, wsTXT, wsTRM, wsSYS, wsCHT, wsFLT, wsMOV, wsTMP]

    #+end_src

*** Projects
    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Projects                                                              --
      ---------------------------------------------------------------------------
      -- Use either a string as project name, or a variable declared under 'workspaces'

      projects :: [Project]
      projects =
          [ Project { projectName = wsPythonP
              , projectDirectory  = "~/Projects/Python"
              , projectStartHook  = Just $ do spawnOnce (myTerminal ++ " --class pythonP")
                                              spawnOnce "pcmanfm ~/Video/Python"
              }
          , Project { projectName = wsXmonadP
              , projectDirectory  = "~/Projects/Xmonad-from-scratch"
              , projectStartHook  = Just $ do spawnOnce "emacsclient -nc ~/Projects/Xmonad-from-scratch  -F '((name . \"xmonadP\"))'"
                                              spawnOnce (myTerminal ++ " --class xmonadP")
              }
          , Project { projectName = wsKBorgP
              , projectDirectory  = "~/Documents/KBorg"
              , projectStartHook  = Just $ do spawnOnce "emacsclient -nc ~/Documents/KBorg  -F '((name . \"kborgP\"))'"
                                              spawnOnce (myTerminal ++ " --class kborgP")
              }
          , Project { projectName = wsHaskell
              , projectDirectory  = "~/Video/Haskell"
              , projectStartHook  = Just $ do spawnOnce (myFastmanager ++ " --class wsHaskell")
              }
          , Project { projectName = wsMOV
              , projectDirectory  = "~/Video/"
              , projectStartHook  = Just $ do spawnOnce (myFastmanager ++ " --class wsMOV")
              }
          ]

    #+end_src

*** Theme
    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Theme                                                                ---
      ---------------------------------------------------------------------------

      myFocusFollowsMouse  = False
      myClickJustFocuses   = True

      base03  = "#002b36"
      base02  = "#073642"
      base01  = "#586e75"
      base00  = "#657b83"
      base0   = "#839496"
      base1   = "#93a1a1"
      base2   = "#eee8d5"
      base3   = "#fdf6e3"
      yellow  = "#b58900"
      orange  = "#cb4b16"
      red     = "#dc322f"
      magenta = "#d33682"
      violet  = "#6c71c4"
      blue    = "#268bd2"
      cyan    = "#2aa198"
      green   = "#859900"

      -- sizes
      gap         = 10
      topbar      = 10
      myBorder    = 2
      myPrompt    = 26
      status      = 20

      myNormalBorderColor     = "#000000"
      myFocusedBorderColor    = active

      active       = blue
      activeWarn   = red
      inactive     = base02
      focusColor   = blue
      unfocusColor = base02

      myFont       = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
      myMediumFont = "xft:NotoSansMono Nerd Font:style=Regular:size=32:antialias=true:hinting=true"
      myBigFont    = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
      myLargeFont  = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"

      -- Theme for showWName which prints current workspace when you change workspaces.
      myShowWNameTheme :: SWNConfig
      myShowWNameTheme = def
          { swn_font              = myMediumFont
          , swn_fade              = 1.0
          , swn_bgcolor           = base03
          , swn_color             = base3
          }

      myTabTheme = def
          { fontName              = myFont
          , activeColor           = active
          , inactiveColor         = base02
          , activeBorderColor     = active
          , inactiveBorderColor   = base02
          , activeTextColor       = base03
          , inactiveTextColor     = base00
          }

      -- Flash text config (ref:showConfig)
      myFlashConfig :: ShowTextConfig
      myFlashConfig = STC
              { st_font = myMediumFont
              , st_bg   = base03
              , st_fg   = base3
              }

    #+end_src

*** Prompts

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      myPromptTheme :: XPConfig
      myPromptTheme = def
          { font                  = myFont
          , bgColor               = base03
          , fgColor               = active
          , fgHLight              = base03
          , bgHLight              = active
          , borderColor           = base03
          , promptBorderWidth     = 0
          , height                = myPrompt + 4
          , promptKeymap          = emacsLikeXPKeymap
          , position              = Top
          -- , position            = CenteredAt { xpCenterY = 0.3, xpWidth = 0.3 }
          , historySize           = 256
          , historyFilter         = id
          , defaultText           = []
          -- , autoComplete        = Just 100000  -- set Just 100000 for .1 sec
          , showCompletionOnTab   = False
          -- , complCaseSensitivity  = ComplCaseSensitive False -- newer version :-(!
          , searchPredicate       = fuzzyMatch   --
          , sorter                = fuzzySort
          , defaultPrompter       = id $ map toUpper  -- change prompt to UPPER
          , alwaysHighlight       = True
          , maxComplRows          = Just 15 -- Nothing -- Nothing is unlimited
          }

      warmPromptTheme = myPromptTheme
          { bgColor               = yellow
          , fgColor               = base03
          , position              = Top
          }

      hotPromptTheme = myPromptTheme
          { bgColor               = red
          , fgColor               = base3
          , position              = Top
          }

    #+end_src

    Search engines:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      archwiki, news, reddit, urban :: S.SearchEngine

      archwiki = S.searchEngine "archwiki" "https://wiki.archlinux.org/index.php?search="
      news     = S.searchEngine "news" "https://news.google.com/search?q="
      reddit   = S.searchEngine "reddit" "https://www.reddit.com/search/?q="
      urban    = S.searchEngine "urban" "https://www.urbandictionary.com/define.php?term="

      searchList :: [(String, S.SearchEngine)]
      searchList = [ ("g", S.google)
                   , ("h", S.hoogle)
                   , ("w", S.wikipedia)
                   , ("a", archwiki)
                   , ("n", news)
                   , ("r", reddit)
                   , ("u", urban)
                   , ("c", S.hackage)
                   ]
    #+end_src
*** Hooks and main
**** Manage
     xprop
     classname wont work without Pavu
     resource wont work with Pavu

     Notice possible unite several rules into one

     #+begin_src haskell -n  :tangle "~/.xmonad/xmonad.hs"
       ---------------------------------------------------------------------------
       -- ManageHook                                                           ---
       ---------------------------------------------------------------------------

       myManageHook :: ManageHook
       myManageHook = composeAll . concat $
           [ [ className  =? c                     --> doFloat | c <- myFun]
           , [ resource   =? "gsimplecal"          --> doFloatAt' (1554/1920) (30/1040) ]
           , [ resource   =? "myFloat"             --> forceCenterFloat]
           --, [ resource =? "pavucontrol"         --> largeFloat]                                      (ref:manage)
           --, [ resource =? "myMusic"             --> largeFloat]
           , [ resource   =? c                     --> largeFloat | c <- floatApps ]
           , [ className  =? c                     --> doShift ( myWorkspaces !! 0 )| c <- myBrowsers ]
           , [ (className =? "obs" <&&> title =? "Scripts" ) --> largeFloat ]
           , [ (className =? "obs" <&&> isDialog ) --> largeFloat ]
           , [ (title     =? "emacs-capture" )     --> smallFloat ]
           ]
           where
               floatApps  = ["pavucontrol", "myMusic", "xmessage" ]
               myBrowsers = ["chromium", "Firefox"]
               myFun      = ["Gimp"]
               obsFloats  = [ "Scripts"]
               doMaster = doF W.shiftMaster --append this to all floats so new windows always go on top, regardless of the current focus
               doFloatAt' x y = doFloatAt x y <+> doMaster

     #+end_src

**** Layout

      Extending layouts for daily use:

      - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-WindowNavigation.html][XMonad.Layout.WindowNavigation]] -- WindowNavigation is an extension to allow easy navigation of a workspace. See here for the new key bindings. TODO alternative for =windows W.focusUp=
      - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-LimitWindows.html][XMonad.Layout.LimitWindows]] -- A layout modifier that limits the number of windows that can be =shown=. My screen is not all that big, more then four windows is silly in most cases. Notice that the layout =shows= four windows, the other ones are still there, just not shown!

      Magnifing a layout:

      - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-Magnifier.html][XMonad.Layout.Magnifier]] -- This is a layout modifier that will make a layout increase the size of the window that has focus.
      - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-ResizableTile.html][XMonad.Layout.ResizableTile]] -- More useful tiled layout that allows you to change a width/height of window.

      I use this to flip back and forth between a video, playing at 2/3d of the screen and a terminal, also at 2/3d where I follow the lesson / video. Uses ref:resize and ref:magnify

      Floating windows:

      Fullscreensupport: [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-Fullscreen.html][XMonad.Layout.Fullscreen]] -- Provides a ManageHook and an EventHook that sends layout messages with information about fullscreening windows. This allows layouts to make their own decisions about what they should to with a window that requests fullscreen.

      Testing, works with browsers - (fsmain) (fs)

    #+begin_src haskell -n  :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- LayoutHook                                                           ---
      ---------------------------------------------------------------------------
      myLayouthook = avoidStruts
                     $ smartBorders
                     $ showWName' myShowWNameTheme
                     $ tall ||| tabs ||| wide ||| full ||| grid ||| magnify ||| floats

      mySpacing           = smartSpacing gap

      tall    = renamed [Replace "tall"] $ mySpacing $ Tall 1 0.03 0.5
      wide    = renamed [Replace "wide"] $ mySpacing $ Mirror tall
      full    = renamed [Replace "full"] $ Full
      magnify  = renamed [Replace "magnify"]
                 $ windowNavigation
                 $ addTabs shrinkText myTabTheme
                 -- $ subLayout [0,1,2] (smartBorders Simplest)
                 $ magnifier
                 $ limitWindows 2
                 -- $ mySpacing 8
                 $ ResizableTall 1 (3/100) (1/2) []
      grid     = renamed [Replace "grid"]
                 $ windowNavigation
                 $ addTabs shrinkText myTabTheme
                 -- $ subLayout [0,1,2] (smartBorders Simplest)
                 $ limitWindows 4
                 $ mySpacing
                 -- $ mkToggle (single MIRROR)
                 $ Grid (16/10)
      floats   = renamed [Replace "floats"]
                 $ windowNavigation
                 $ addTabs shrinkText myTabTheme
                 -- $ subLayout [] (smartBorders Simplest)
                 $ limitWindows 20 simplestFloat
      sTabbed  = renamed [Replace "tabbed"]
                 $ simpleTabbed
      tabs     = renamed [Replace "tabs"]
                 $ avoidStruts
                 -- $ addTopBar
                 -- $ addTabs shrinkText myTabTheme
                 -- $ Simplest
                 $ tabbed shrinkText myTabTheme
    #+end_src

**** Startup

     #+begin_src haskell -n  :tangle "~/.xmonad/xmonad.hs"
       ---------------------------------------------------------------------------
       -- StartupHook                                                           ---
       ---------------------------------------------------------------------------
       -- myStartupHook :: X ()
       myStartupHook = do
           spawnOnce "wallpaper"
           spawnOnce "picom &"
           spawnOnce "dunst &"
           spawnOnce "/usr/bin/emacs --daemon &"
           spawnOnce "unclutter --timeout 4 --jitter 10 --ignore-scrolling -b"
     #+end_src

**** Main

     #+begin_src haskell -n  :tangle "~/.xmonad/xmonad.hs"
       ---------------------------------------------------------------------------
       -- Main                                                                 ---
       ---------------------------------------------------------------------------
       main = do
         xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
         xmonad
           $ addDescrKeys2 ((mod4Mask, xK_F1), xMessage) myKeys -- addDescrKeys' without defaults
           $ dynamicProjects projects
           -- $ fullscreenSupport                                                         -- (ref:fsmain)
           $ ewmh                                                                      -- (ref:ewmain)
           $ docks def
           { borderWidth        = myBorder
           , clickJustFocuses   = myClickJustFocuses
           , focusFollowsMouse  = myFocusFollowsMouse
           , normalBorderColor  = myNormalBorderColor
           , focusedBorderColor = myFocusedBorderColor
           , layoutHook         = myLayouthook
           , handleEventHook    = handleTimerEvent                                     -- ref (showH)
           , manageHook         = myManageHook
           , startupHook        = myStartupHook
           , logHook  = dynamicLogWithPP xmobarPP
                        { ppOutput          = hPutStrLn xmproc
                        , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                        , ppTitle           = xmobarColor active "" . shorten 50
                        , ppVisible         = xmobarColor base0  "" . wrap "(" ")"
                        , ppUrgent          = xmobarColor red    "" . wrap " " " "
                        , ppHiddenNoWindows = const ""
                        , ppSep             = xmobarColor red myNormalBorderColor " : "
                        , ppWsSep           = " "
                        , ppLayout          = xmobarColor yellow ""
                        , ppOrder           = id
                        }
           , modMask    = mod4Mask
           , workspaces = myWorkspaces
           }
     #+end_src

*** Keys

    New module:

    - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-ShowText.html][XMonad.Actions.ShowText]] -- ShowText displays text for sometime on the screen.


    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      -- | Merge the supplied keys with 'defaultKeysDescr', also adding a keybinding
      -- to run an action for showing the keybindings.
      addDescrKeys2 :: (HasName b1, HasName b) =>
          ((KeyMask, KeySym),[((KeyMask, KeySym), NamedAction)] -> b)
          -> (XConfig Layout -> [((KeyMask, KeySym), b1)])
          -> XConfig l
          -> XConfig l
      addDescrKeys2 k ks = addDescrKeys' k (\l -> defaultKeysDescr2 l ^++^ ks l)

    #+end_src

    New Xmonad key-bindings:

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Keys                                                                 ---
      ---------------------------------------------------------------------------

      myKeys conf = let
          subKeys str ks        = subtitle str : mkNamedKeymap conf ks
          in

          subKeys "Xmonad"
          [ ("M-q", addName "Restart XMonad"               $ confirmPrompt hotPromptTheme "Restart XMonad" $ restartXmonad)
          , ("M-C-q", addName "Rebuild & restart XMonad"   $ confirmPrompt hotPromptTheme "Recompile and Restart XMonad" $ reburesXmonad)
          , ("M-C-r", addName "Rebuild & restart XMonad"   $ confirmPrompt hotPromptTheme "Recompile and Restart XMonad" $ rebuildXmonad)
          , ("M-S-q", addName "Quit XMonad"                $ confirmPrompt hotPromptTheme "Quit XMonad" $ io (exitWith ExitSuccess))
          ] ^++^

          subKeys "Multi Media"
          [ ("<XF86PowerOff>"         , addName "Power off"                 $ confirmPrompt hotPromptTheme "Shutdown Linux" $ spawn "shutdown -h now")
          , ("<XF86MonBrightnessUp>"  , addName "Up brightness"             $ spawn "sudo light -A 10  & notify-send  \"Bright Up\"")
          , ("<XF86MonBrightnessDown>", addName "Down brightness"           $ spawn "sudo light -U 10  & notify-send  \"Bright Down\"")
          , ("<XF86AudioRaiseVolume>" , addName "Up audio"   $ flashText myFlashConfig 1 "Volume(+)" >> spawn "amixer set Master 5%+ unmute")
          , ("<XF86AudioLowerVolume>" , addName "Down audio" $ flashText myFlashConfig 1 "Volume(-)" >> spawn "amixer set Master 5%- unmute")
          , ("<XF86AudioMute>"        , addName "MUTE audio"                $ spawn "amixer set Master toggle")
          , ("M-<XF86Display>"        , addName "Display - force internal"  $ spawn "displayctl internal")
          , ("<XF86ScreenSaver>"      , addName "Lock screen"               $ spawn "alacritty")
          , ("<XF86TouchpadToggle>"   , addName "Toggle touchpad"           $ spawn "alacritty")
          , ("M-u p"                  , addName "Play music"                $ spawn "mpc play")
          , ("M-u ,"                  , addName "Play next"                 $ spawn "mpc next")
          , ("M-u ."                  , addName "Play previous"             $ spawn "mpc prev")
          , ("M-u <Space>"            , addName "Toggle play"               $ flashText myFlashConfig 1 "Pause" >>spawn "mpc toggle")
          , ("M-u /"                  , addName "Music player"              $ spawn myMusicPlayer)
          ] ^++^

          subKeys "My Applications"
          [ ("M-<Return>"          , addName "Terminal"           $ spawn myTerminal)
          , ("M-b"                 , addName "Browser"            $ spawn myBrowser)
          , ("M-a"                 , addName "Volume control"     $ spawn "pavucontrol")
          , ("M-x i"               , addName "Weechat"            $ spawn myIrc)
          , ("M-x n"               , addName "Newsboat"           $ spawn myNews)
          , ("M-x h"               , addName "Htop"               $ spawn myTop)
          , ("M-d"                 , addName "Dmenu (I3 binding)" $ spawn "dmenu_run")
          , ("M-f"                 , addName "Filemanager"        $ spawn myFastmanager)
          , ("M-S-f"               , addName "Filemanager"        $ spawn myFilemanager)
          ] ^++^

          subKeys "My Emacs bindings"
          [ ("M-e e"               , addName "Emacsclient"        $ spawn "emacsclient -nc")
          ] ^++^

          subKeys "Window actions"
          [ ("M-S-<Return>" , addName "Swap current window to master"   $ windows W.swapMaster)
          , ("M-j"          , addName "Focus down list"                 $ windows W.focusDown)
          , ("M-k"          , addName "Focus up list"                   $ windows W.focusUp)
          , ("M-m"          , addName "Focus the master"                $ windows W.focusMaster)
          , ("M-C-<Right>"  , addName "Focus right"                     $ sendMessage $ Go R) -- (ref:windownavKeys)
          , ("M-C-<Left>"   , addName "Focus left"                      $ sendMessage $ Go L)
          , ("M-C-<Up>"     , addName "Focus left"                      $ sendMessage $ Go U)
          , ("M-C-<Down>"   , addName "Focus left"                      $ sendMessage $ Go D)
          , ("M-S-C-<Right>", addName "Focus and move right"            $ sendMessage $ Swap R)
          , ("M-S-C-<Left>" , addName "Focus and move left"             $ sendMessage $ Swap L)
          , ("M-S-C-<Up>"   , addName "Focus and move left"             $ sendMessage $ Swap U)
          , ("M-S-C-<Down>" , addName "Focus and move left"             $ sendMessage $ Swap D)
          ] ^++^

          subKeys "Prompts"
          [ ("M-s m", addName "Man-page Prompt" $ manPrompt myPromptTheme)] ^++^

          subKeys "Searchengines"
          [ ("M-p " ++ k, addName "Search Engines" $ S.promptSearch myPromptTheme f) | (k,f) <- searchList
          ] ^++^

          subKeys "Projects"
          [ ("M-w"   , addName "switch Project Prompt"   $ switchProjectPrompt warmPromptTheme)
          , ("M-S-w" , addName "shift To Project Prompt" $ shiftToProjectPrompt warmPromptTheme)
          ] ^++^

          subKeys "Workspaces"
          [ ("M-<Left>"     , addName "next workspace"        $ prevWS)
          , ("M-<Right>"    , addName "previous workspace"    $ nextWS)
          , ("M-z"          , addName "toggle last workspace" $ toggleWS)
          , ("M-S-<Left>"   , addName "XX next workspace"     $ shiftToNext >> prevWS)
          , ("M-S-<Right>"  , addName "XX previous workspace" $ shiftToNext >> nextWS)
          ]

         -- subKeys "Actions"
         -- [ ("M-a"                       , addName "Notify w current X selection"    $ unsafeWithSelection "notify-send")

             -- , ("M-M1-/"                    , addName "On-screen keys (on/off) "        $ spawn "killall screenkey &>/dev/null || screenkey --no-systray")
             -- , ("M-M1-S-/"                  , addName "On-screen keys settings"         $ spawn "screenkey --show-settings")
             -- , ("M-M1-s"                    , addName "Capture screen"                  $ spawn "screenshot" )
             -- , ("M-M1-S-s"                  , addName "Capture screen - area select"    $ spawn "screenshot area" )
             -- , ("M-M1-r"                    , addName "Record screen"                   $ spawn "screencast" )
             -- , ("M-M1-S-r"                  , addName "Record screen - area select"     $ spawn "screencast area" )
             -- ] ^++^
     #+end_src

    Original layout:

    #+begin_src  haskell :tangle "~/.xmonad/xmonad.hs"
      defaultKeysDescr2 :: XConfig Layout -> [((KeyMask, KeySym), NamedAction)]
      defaultKeysDescr2 conf@(XConfig {XMonad.modMask = modm}) =
          [ subtitle "launching and killing programs"
          , ((modm .|. shiftMask, xK_Return), addName "Launch Terminal" $ spawn $ XMonad.terminal conf) -- %! Launch terminal
          , ((modm,               xK_p     ), addName "Launch dmenu" $ spawn "exe=`dmenu_path | dmenu` && eval \"exec $exe\"") -- %! Launch dmenu
          -- , ((modm .|. shiftMask, xK_p     ), addName "Launch gmrun" $ spawn "gmrun") -- %! Launch gmrun
          , ((modm .|. shiftMask, xK_c     ), addName "Close the focused window" kill) -- %! Close the focused window

          , subtitle "changing layouts"
          , ((modm,               xK_space ), sendMessage' NextLayout) -- %! Rotate through the available layout algorithms
          , ((modm .|. shiftMask, xK_space ), addName "Reset the layout" $ setLayout $ XMonad.layoutHook conf) -- %!  Reset the layouts on the current workspace to default

          , separator
          , ((modm,               xK_n     ), addName "Refresh" refresh) -- %! Resize viewed windows to the correct size

          , subtitle "move focus up or down the window stack"
          , ((modm,               xK_Tab   ), addName "Focus down" $ windows W.focusDown) -- %! Move focus to the next window
          , ((modm .|. shiftMask, xK_Tab   ), addName "Focus up"   $ windows W.focusUp  ) -- %! Move focus to the previous window
          , ((modm,               xK_j     ), addName "Focus down" $ windows W.focusDown) -- %! Move focus to the next window
          , ((modm,               xK_k     ), addName "Focus up"   $ windows W.focusUp  ) -- %! Move focus to the previous window
          , ((modm,               xK_m     ), addName "Focus the master" $ windows W.focusMaster  ) -- %! Move focus to the master window

          , subtitle "modifying the window order"
          , ((modm,               xK_Return), addName "Swap with the master" $ windows W.swapMaster) -- %! Swap the focused window and the master window
          , ((modm .|. shiftMask, xK_j     ), addName "Swap down" $ windows W.swapDown  ) -- %! Swap the focused window with the next window
          , ((modm .|. shiftMask, xK_k     ), addName "Swap up"   $ windows W.swapUp    ) -- %! Swap the focused window with the previous window

          , subtitle "resizing the master/slave ratio"
          , ((modm,               xK_h     ), sendMessage' Shrink) -- %! Shrink the master area
          , ((modm,               xK_l     ), sendMessage' Expand) -- %! Expand the master area

          , subtitle "floating layer support"
          , ((modm,               xK_t     ), addName "Push floating to tiled" $ withFocused $ windows . W.sink) -- %! Push window back into tiling

          , subtitle "change the number of windows in the master area"
          , ((modm              , xK_comma ), sendMessage' (IncMasterN 1)) -- %! Increment the number of windows in the master area
          , ((modm              , xK_period), sendMessage' (IncMasterN (-1))) -- %! Deincrement the number of windows in the master area

          , subtitle "quit, or restart"
          , ((modm .|. shiftMask, xK_q     ), addName "Quit" $ io (exitWith ExitSuccess)) -- %! Quit xmonad
          , ((modm              , xK_q     ), addName "Restart" $ spawn "xmonad --recompile && xmonad --restart") -- %! Restart xmonad
          ]

          -- mod-[1..9] %! Switch to workspace N
          -- mod-shift-[1..9] %! Move client to workspace N
          ++
          subtitle "switching workspaces":
          [((m .|. modm, k), addName (n ++ i) $ windows $ f i)
              | (f, m, n) <- [(W.greedyView, 0, "Switch to workspace "), (W.shift, shiftMask, "Move client to workspace ")]
              , (i, k) <- zip (XMonad.workspaces conf) [xK_1 .. xK_9]]
          -- mod-{w,e,r} %! Switch to physical/Xinerama screens 1, 2, or 3
          -- mod-shift-{w,e,r} %! Move client to screen 1, 2, or 3
         ++
         subtitle "switching screens" :
         [((m .|. modm, key), addName (n ++ show sc) $ screenWorkspace sc >>= flip whenJust (windows . f))
              | (f, m, n) <- [(W.view, 0, "Switch to screen number "), (W.shift, shiftMask, "Move client to screen number ")]
              , (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]]

    #+end_src

*** Misc functions

    Source: [[https://github.com/altercation/dotfiles-tilingwm/blob/master/.xmonad/xmonad.hs][Ethan Schoonover's xmonad.hs]]

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      quitXmonad :: X ()
      quitXmonad = io (exitWith ExitSuccess)

      reburesXmonad :: X ()
      reburesXmonad = do
          spawn "xmonad --recompile && xmonad --restart"

      rebuildXmonad :: X ()
      rebuildXmonad = do
          spawn "xmonad --recompile"

      restartXmonad :: X ()
      restartXmonad = do
          spawn "xmonad --restart"

    #+end_src

    Custom hook helpers

    #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
      ---------------------------------------------------------------------------
      -- Custom hook helpers
      ---------------------------------------------------------------------------

      -- from:
      -- https://github.com/pjones/xmonadrc/blob/master/src/XMonad/Local/Action.hs
      --
      -- Useful when a floating window requests stupid dimensions.

      forceCenterFloat :: ManageHook
      forceCenterFloat = doFloatDep move
        where
          move :: W.RationalRect -> W.RationalRect
          move _ = W.RationalRect x y w h
          w, h, x, y :: Rational
          w = 2/3
          h = 2/3
          x = (1-w)/2
          y = (1-h)/2

      largeFloat :: ManageHook
      largeFloat = doFloatDep move
        where
          move :: W.RationalRect -> W.RationalRect
          move _ = W.RationalRect x y w h
          w, h, x, y :: Rational
          w = 3/4
          h = 3/4
          x = (1-w)/2
          y = (1-h)/2

      smallFloat :: ManageHook
      smallFloat = doFloatDep move
        where
          move :: W.RationalRect -> W.RationalRect
          move _ = W.RationalRect x y w h
          w, h, x, y :: Rational
          w = 2/3
          h = 1/4
          x = (1-w)/2
          y = (1-h)/2

    #+end_src


*** COMMENT More

    #+begin_src haskell
 -- > import XMonad.Prompt
 -- > import XMonad.Prompt.Window ( windowPrompt )
 -- > import XMonad.Prompt.FuzzyMatch
 -- >
 -- > myXPConfig = def { searchPredicate = fuzzyMatch
 -- >                  , sorter          = fuzzySort
 -- >                  }

    #+end_src

** TODO XMonad from scratch -- day 13 -- Scratchpads                    :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-13
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   Scratchpads

  [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-NamedScratchpad.html][XMonad.Util.NamedScratchpad]] --



  #+begin_src haskell
    ---------------------------------------------------------------------------
    -- SCRATCHPADS                                                           --
    ---------------------------------------------------------------------------
    myScratchPads :: [NamedScratchpad]
    myScratchPads = [ NS "scratchpad" spawnTerm findTerm manageTerm
                    , NS "myPavu" spawnPavu findPavu managePavu
                    -- , NS "scrEmacs" spawnEmacs findEmacs manageEmacs
                    , NS "myMusic" spawnMocp findMocp manageMocp
                    , NS "myWhatsApp" spawnWhatsApp findWhatsApp manageWhatsApp
                    , NS "myProtonmail" spawnProtonmail findProtonmail manageProtonmail
                    ]
      where
        spawnTerm  = myTerminal ++ " --class scratchPad"
        findTerm   = resource =? "scratchPad"
        manageTerm = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.6
                     w = 0.9
                     t = 1 - h     -- bottom edge
                     l = (1 - w)/2 -- centered left/right
        spawnPavu  = myAudiocontrol ++ " --class myPavu"
        findPavu   = resource =? "pavucontrol" --TODO how to catch second field?
        managePavu = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.7
                     w = 0.7
                     t = (1 - h)/2 -- centered top/bottom
                     l = (1 - w)/2 -- centered left/right
        -- spawnEmacs  = "emacsclient -c -name scrEmacs ~/Documents"
        -- spawnEmacs  = "emacsclient -c -a \"\" -F '((name . \"emacs-scratch\"))'"
        -- findEmacs   = title =? "emacs-scratch" --TODO how to catch second field?
        -- manageEmacs = customFloating $ W.RationalRect l t w h
        --            where
        --              h = 0.9
        --              w = 0.9
        --              t = 0.95 -h
        --              l = 0.95 -w
        spawnMocp  = "alacritty --class myMusic -e ncmpcpp"
        findMocp   = resource =? "myMusic"
        manageMocp = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.9
                     w = 0.9
                     t = 0.95 -h
                     l = 0.95 -w
        spawnWhatsApp  = "chromium --app=https://web.whatsapp.com/"
        findWhatsApp   = appName =? "web.whatsapp.com"
        manageWhatsApp = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.9
                     w = 0.9
                     t = 0.95 -h
                     l = 0.95 -w
        spawnProtonmail  = "chromium --app=https://mail.protonmail.com/"
        findProtonmail   = appName =? "mail.protonmail.com"
        manageProtonmail = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.9
                     w = 0.9
                     t = 0.95 -h
                     l = 0.95 -w
  #+end_src

** TODO XMonad from scratch -- day 14 -- Functions                      :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-14-functions
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   Misc functions

  Source: [[https://github.com/altercation/dotfiles-tilingwm/blob/master/.xmonad/xmonad.hs][Ethan Schoonover's xmonad.hs]]

  #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
    quitXmonad :: X ()
    quitXmonad = io (exitWith ExitSuccess)

    reburesXmonad :: X ()
    reburesXmonad = do
        spawn "xmonad --recompile && xmonad --restart"

    rebuildXmonad :: X ()
    rebuildXmonad = do
        spawn "xmonad --recompile"

    restartXmonad :: X ()
    restartXmonad = do
        spawn "xmonad --restart"

  #+end_src

  Custom hook helpers

  #+begin_src haskell :tangle "~/.xmonad/xmonad.hs"
    ---------------------------------------------------------------------------
    -- Custom hook helpers
    ---------------------------------------------------------------------------

    -- from:
    -- https://github.com/pjones/xmonadrc/blob/master/src/XMonad/Local/Action.hs
    --
    -- Useful when a floating window requests stupid dimensions.

    forceCenterFloat :: ManageHook
    forceCenterFloat = doFloatDep move
      where
        move :: W.RationalRect -> W.RationalRect
        move _ = W.RationalRect x y w h
        w, h, x, y :: Rational
        w = 2/3
        h = 2/3
        x = (1-w)/2
        y = (1-h)/2

    largeFloat :: ManageHook
    largeFloat = doFloatDep move
      where
        move :: W.RationalRect -> W.RationalRect
        move _ = W.RationalRect x y w h
        w, h, x, y :: Rational
        w = 3/4
        h = 3/4
        x = (1-w)/2
        y = (1-h)/2

    smallFloat :: ManageHook
    smallFloat = doFloatDep move
      where
        move :: W.RationalRect -> W.RationalRect
        move _ = W.RationalRect x y w h
        w, h, x, y :: Rational
        w = 2/3
        h = 1/4
        x = (1-w)/2
        y = (1-h)/2

  #+end_src

** TODO XMonad from scratch -- day 15 -- Xmobar II                      :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-15-xmobar-II
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   Buttons, icons and scripts

** TODO XMonad from scratch -- day 16 -- Kitchensink                    :xmonad:
   :PROPERTIES:
   :EXPORT_FILE_NAME: xmonad-from-scratch-day-16-kitchensink
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description
   :END:

   What else can we add? See first image

** COMMENT Local Variables                          :ARCHIVE:
   # Local Variables:
   # eval: (org-hugo-auto-export-mode)
   # End:
